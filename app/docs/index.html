<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Helm Docs | Docs</title>

  <meta name="description" content="Documentation for Helm - The Kubernetes Package Manager.">
  <meta name="author" content="">
  <meta property="og:title" content="Helm - The Package Manager for Kubernetes." />
  <meta property="og:url" content="https://helm.sh/" />
  <meta property="og:image" content="https://helm.sh//src/img/favicon-152.png" />
  <meta name="google-site-verification" content="dCa3wS47cErhx0IpaxbB85NfcOP-vFxevknVk6fzf5I" />

  <link rel="icon" href="/src/img/favicon-152.png" type="image/x-icon">
  <link rel="apple-touch-icon-precomposed" href="/src/img/apple-touch-icon-precomposed.png">
  <link href="/src/css/styles.min.css" rel="stylesheet">
</head>

<body id="landing">

  <div class="off-canvas-wrap" data-offcanvas>
    <div class="inner-wrap">

      <a class="left-off-canvas-toggle show-for-medium-down" href="#off-canvas-navigation">
        <i class="fa fa-bars"></i>
      </a>
      <aside class="left-off-canvas-menu" id="off-canvas-navigation" data-topbar>
  <div class="drawer-wrap">

    <ul class="off-canvas-list current sidebar-main">
      <li>
        <a class="sidebar-nav-item" href="https://helm.sh/">
          <span class="ripple">Docs Home <span></span></span>
        </a>
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="using_helm" state="">
          <span class="ripple">Using Helm <span></span></span>
        </a>
        
        <ul class="current">
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#quickstart-guide" title="Switch to Quickstart">
              Quickstart
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#installing-helm" title="Switch to Installing Helm">
              Installing Helm
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#kubernetes-distribution-guide" title="Switch to Kubernetes Distro Notes">
              Kubernetes Distro Notes
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#installation-frequently-asked-questions" title="Switch to Install FAQ">
              Install FAQ
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#using-helm" title="Switch to Using Helm">
              Using Helm
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#the-helm-plugins-guide" title="Switch to Plugins">
              Plugins
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#role-based-access-control" title="Switch to Role-Based Access Control">
              Role-Based Access Control
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#using-ssl-between-helm-and-tiller" title="Switch to TLS/SSL for Helm and Tiller">
              TLS/SSL for Helm and Tiller
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../using_helm/#securing-your-helm-installation" title="Switch to Securing Helm">
              Securing Helm
            </a>
          </li>
          
        </ul>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="helm" state="">
          <span class="ripple">Helm Commands <span></span></span>
        </a>
        
        <ul class="current">
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm" title="Switch to Helm">
              Helm
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-completion" title="Switch to Helm Completion">
              Helm Completion
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-create" title="Switch to Helm Create">
              Helm Create
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-delete" title="Switch to Helm Delete">
              Helm Delete
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-dependency" title="Switch to Helm Dependency">
              Helm Dependency
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-dependency-build" title="Switch to Helm Dependency Build">
              Helm Dependency Build
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-dependency-list" title="Switch to Helm Dependency List">
              Helm Dependency List
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-dependency-update" title="Switch to Helm Dependency Update">
              Helm Dependency Update
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-fetch" title="Switch to Helm Fetch">
              Helm Fetch
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-get" title="Switch to Helm Get">
              Helm Get
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-get-hooks" title="Switch to Helm Get Hooks">
              Helm Get Hooks
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-get-manifest" title="Switch to Helm Get Manifest">
              Helm Get Manifest
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-get-values" title="Switch to Helm Get Values">
              Helm Get Values
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-history" title="Switch to Helm History">
              Helm History
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-home" title="Switch to Helm Home">
              Helm Home
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-init" title="Switch to Helm Init">
              Helm Init
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-inspect" title="Switch to Helm Inspect">
              Helm Inspect
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-inspect-chart" title="Switch to Helm Inspect Chart">
              Helm Inspect Chart
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-inspect-values" title="Switch to Helm Inspect Values">
              Helm Inspect Values
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-install" title="Switch to Helm Install">
              Helm Install
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-lint" title="Switch to Helm Lint">
              Helm Lint
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-list" title="Switch to Helm List">
              Helm List
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-package" title="Switch to Helm Package">
              Helm Package
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-plugin" title="Switch to Helm Plugin">
              Helm Plugin
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-plugin-install" title="Switch to Helm Plugin Install">
              Helm Plugin Install
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-plugin-list" title="Switch to Helm Plugin List">
              Helm Plugin List
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-plugin-remove" title="Switch to Helm Plugin Remove">
              Helm Plugin Remove
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-plugin-update" title="Switch to Helm Plugin Update">
              Helm Plugin Update
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-repo" title="Switch to Helm Repo">
              Helm Repo
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-repo-add" title="Switch to Helm Repo Add">
              Helm Repo Add
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-repo-index" title="Switch to Helm Repo Index">
              Helm Repo Index
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-rep-list" title="Switch to Helm Repo List">
              Helm Repo List
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-repo-remove" title="Switch to Helm Repo Remove">
              Helm Repo Remove
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-repo-update" title="Switch to Helm Repo Update">
              Helm Repo Update
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-reset" title="Switch to Helm Reset">
              Helm Reset
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-rollback" title="Switch to Helm Rollback">
              Helm Rollback
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-search" title="Switch to Helm Search">
              Helm Search
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-serve" title="Switch to Helm Serve">
              Helm Serve
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-status" title="Switch to Helm Status">
              Helm Status
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-template" title="Switch to Helm Template">
              Helm Template
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-test" title="Switch to Helm Test">
              Helm Test
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-upgrade" title="Switch to Helm Upgrade">
              Helm Upgrade
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-verify" title="Switch to Helm Verify">
              Helm Verify
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../helm/#helm-version" title="Switch to Helm Version">
              Helm Version
            </a>
          </li>
          
        </ul>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="developing_charts" state="">
          <span class="ripple">Charts <span></span></span>
        </a>
        
        <ul class="current">
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#charts" title="Switch to Intro to Charts">
              Intro to Charts
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#hooks" title="Switch to Chart Lifecycle Hooks">
              Chart Lifecycle Hooks
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#chart-development-tips-and-tricks" title="Switch to Charts Tips and Tricks">
              Charts Tips and Tricks
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#the-chart-repository-guide" title="Switch to Charts Repository Guide">
              Charts Repository Guide
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#syncing-your-chart-repository" title="Switch to Syncing Your Chart Repo">
              Syncing Your Chart Repo
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#helm-provenance-and-integrity" title="Switch to Signing Charts">
              Signing Charts
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#chart-tests" title="Switch to Chart Tests">
              Chart Tests
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../developing_charts/#chart-repositories-frequently-asked-questions" title="Switch to Chart Repository FAQ">
              Chart Repository FAQ
            </a>
          </li>
          
        </ul>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="chart_template_guide" state="">
          <span class="ripple">Developing Templates <span></span></span>
        </a>
        
        <ul class="current">
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#the-chart-template-developer-s-guide" title="Switch to Intro">
              Intro
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#getting-started-with-a-chart-template" title="Switch to Getting Started">
              Getting Started
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#built-in-objects" title="Switch to Built-In Objects">
              Built-In Objects
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#values-files" title="Switch to Values Files">
              Values Files
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#template-functions-and-pipelines" title="Switch to Template Functions and Pipelines">
              Template Functions and Pipelines
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#flow-control" title="Switch to Flow Control">
              Flow Control
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#variables" title="Switch to Variables">
              Variables
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#named-templates" title="Switch to Named Templates">
              Named Templates
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#accessing-files-inside-templates" title="Switch to Accessing Files Inside Templates">
              Accessing Files Inside Templates
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#creating-a-notes-txt-file" title="Switch to Creating a NOTES.txt File">
              Creating a NOTES.txt File
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#subcharts-and-global-values" title="Switch to Subcharts and Global Values">
              Subcharts and Global Values
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#debugging-templates" title="Switch to Debugging Templates">
              Debugging Templates
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#wrapping-up" title="Switch to Next Steps">
              Next Steps
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#yaml-techniques" title="Switch to Appendix: YAML Techniques">
              Appendix: YAML Techniques
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_template_guide/#appendix-go-data-types-and-templates" title="Switch to Appendix: Go Data Types and Templates">
              Appendix: Go Data Types and Templates
            </a>
          </li>
          
        </ul>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/chart_best_practices/" state="">
          <span class="ripple">Best Practices <span></span></span>
        </a>
        
        <ul class="current">
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#the-chart-best-practices-guide" title="Switch to Intro">
              Intro
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#general-conventions" title="Switch to General Conventions">
              General Conventions
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#values" title="Switch to Values">
              Values
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#templates" title="Switch to Templates">
              Templates
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#requirements-files" title="Switch to Requirements">
              Requirements
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#labels-and-annotations" title="Switch to Labels &amp; Annotations">
              Labels &amp; Annotations
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#pods-and-podtemplates" title="Switch to Pods &amp; PodTemplates">
              Pods &amp; PodTemplates
            </a>
          </li>
          
          <li class="toctree-l2 ">
            <a href="../../chart_best_practices/#custom-resource-definitions" title="Switch to Custom Resource Definitions">
              Custom Resource Definitions
            </a>
          </li>
          
        </ul>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/docs/related/" state="">
          <span class="ripple">Related Projects <span></span></span>
        </a>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/docs/architecture/" state="">
          <span class="ripple">Architecture <span></span></span>
        </a>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/docs/developers/" state="">
          <span class="ripple">Developer Guide <span></span></span>
        </a>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/docs/history/" state="">
          <span class="ripple">History <span></span></span>
        </a>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="/docs/glossary/" state="">
          <span class="ripple">Glossary <span></span></span>
        </a>
        
      </li>
      
      <li class="sidebar-nav-item toctree-l1 ">
        <a class="reference internal" href="http://github.com/helm/charts" state="">
          <span class="ripple">Find Charts <span></span></span>
        </a>
        
      </li>
      
    </ul>

    <div class="drawer-line"></div>

    <div class="button-wrap">
      <a href="https://github.com/helm/helm" class="button small primary expand email-support"><i class="fa fa-github"></i> Contribute to Docs</a>
    </div>

  </div>
</aside>

  <div class="container container-full">
    <div class="sidebar show-for-large-up">
  <h1>
    <a href="/">
      <svg height="50" viewBox="0 0 121 126" xmlns="http://www.w3.org/2000/svg"><title>Helm Logo</title><g fill="none" fill-rule="evenodd"><g fill="#277A9F"><path d="M85.218 94.1435c2.0246-1.4178 6.6492 1.6934 10.3293 6.949 3.68 5.2556 5.0218 10.6654 2.997 12.0832-2.0247 1.4177-6.6493-1.6935-10.3293-6.949-3.68-5.2557-5.022-10.6655-2.997-12.0832zM36.782 94.1435c-2.0246-1.4178-6.6492 1.6934-10.3293 6.949-3.68 5.2556-5.0218 10.6654-2.997 12.0832 2.0247 1.4177 6.6493-1.6935 10.3293-6.949 3.68-5.2557 5.022-10.6655 2.997-12.0832zM60.9755 102.3724c-2.4717 0-4.4755 5.201-4.4755 11.617 0 6.416 2.0038 11.617 4.4755 11.617 2.4718 0 4.4755-5.201 4.4755-11.617 0-6.416-2.0037-11.617-4.4755-11.617z"/></g><g fill="#277A9F"><path d="M85.218 31.8565c2.0246 1.4178 6.6492-1.6934 10.3293-6.949 3.68-5.2556 5.0218-10.6654 2.997-12.0832-2.0247-1.4177-6.6493 1.6935-10.3293 6.949-3.68 5.2557-5.022 10.6655-2.997 12.0832zM36.782 31.8565c-2.0246 1.4178-6.6492-1.6934-10.3293-6.949-3.68-5.2556-5.0218-10.6654-2.997-12.0832 2.0247-1.4177 6.6493 1.6935 10.3293 6.949 3.68 5.2557 5.022 10.6655 2.997 12.0832zM60.9755 23.6276c-2.4717 0-4.4755-5.201-4.4755-11.617 0-6.416 2.0038-11.617 4.4755-11.617 2.4718 0 4.4755 5.201 4.4755 11.617 0 6.416-2.0037 11.617-4.4755 11.617z"/></g><path d="M95.5044 42.1636c-7.2176-11.883-20.2966-19.8232-35.2333-19.8232-14.528 0-27.2986 7.5117-34.6276 18.8568m.7842 45.6688c7.4352 10.689 19.8207 17.6872 33.8435 17.6872 14.0484 0 26.4534-7.0237 33.884-17.7455" stroke="#277A9F" stroke-width="7.1608"/><path d="M.609 47.6948h8.6217v12.1304h9.7244V47.6948h8.6218v32.5818H18.955V67.344H9.2308v12.9326H.609V47.6948zm34.186 0h21.0528v7.218H43.4166v5.113h10.6266v7.218H43.4166v5.8147H56.349v7.218H34.795V47.695zm27.87 0h8.6215v25.3637h12.331v7.218H62.665V47.695zm26.5666 0h8.9224l5.113 13.534 1.8044 5.3133h.2005l1.8044-5.3132 4.9124-13.534h8.9224v32.5818h-8.0202v-9.6242c0-.8354.0418-1.7544.1253-2.757.0836-1.0024.1755-2.03.2757-3.0826.1003-1.0527.2172-2.0803.351-3.0828.1336-1.0025.2505-1.9048.3508-2.7068h-.2005l-2.7068 7.6192-4.5113 10.9775h-3.208l-4.5114-10.9776-2.6066-7.6192h-.2005c.1003.802.2172 1.7043.351 2.7068.1336 1.0025.2505 2.03.3508 3.0828.1002 1.0526.192 2.0802.2757 3.0827.0835 1.0025.1253 1.9215.1253 2.757v9.624h-7.92V47.695z" fill="#277A9F"/></g></svg>
      <span>Documentation</span>
    </a>
  </h1>

  <div class="sidebar-wrap">

    <nav class="sidebar-nav">
      <ul class="current sidebar-main">
        <li>
          <a class="sidebar-nav-item" href="https://helm.sh/docs">
            <span class="ripple">Docs Home <span></span></span>
          </a>
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="using_helm" state="">
            <span class="ripple">Using Helm <span></span></span>
          </a>
          
          <ul class="current">
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#quickstart-guide" title="Switch to Quickstart">
                Quickstart
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#installing-helm" title="Switch to Installing Helm">
                Installing Helm
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#kubernetes-distribution-guide" title="Switch to Kubernetes Distro Notes">
                Kubernetes Distro Notes
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#installation-frequently-asked-questions" title="Switch to Install FAQ">
                Install FAQ
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#using-helm" title="Switch to Using Helm">
                Using Helm
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#the-helm-plugins-guide" title="Switch to Plugins">
                Plugins
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#role-based-access-control" title="Switch to Role-Based Access Control">
                Role-Based Access Control
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#using-ssl-between-helm-and-tiller" title="Switch to TLS/SSL for Helm and Tiller">
                TLS/SSL for Helm and Tiller
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/using_helm/#securing-your-helm-installation" title="Switch to Securing Helm">
                Securing Helm
              </a>
            </li>
            
          </ul>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="helm" state="">
            <span class="ripple">Helm Commands <span></span></span>
          </a>
          
          <ul class="current">
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm" title="Switch to Helm">
                Helm
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-completion" title="Switch to Helm Completion">
                Helm Completion
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-create" title="Switch to Helm Create">
                Helm Create
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-delete" title="Switch to Helm Delete">
                Helm Delete
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-dependency" title="Switch to Helm Dependency">
                Helm Dependency
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-dependency-build" title="Switch to Helm Dependency Build">
                Helm Dependency Build
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-dependency-list" title="Switch to Helm Dependency List">
                Helm Dependency List
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-dependency-update" title="Switch to Helm Dependency Update">
                Helm Dependency Update
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-fetch" title="Switch to Helm Fetch">
                Helm Fetch
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-get" title="Switch to Helm Get">
                Helm Get
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-get-hooks" title="Switch to Helm Get Hooks">
                Helm Get Hooks
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-get-manifest" title="Switch to Helm Get Manifest">
                Helm Get Manifest
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-get-values" title="Switch to Helm Get Values">
                Helm Get Values
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-history" title="Switch to Helm History">
                Helm History
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-home" title="Switch to Helm Home">
                Helm Home
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-init" title="Switch to Helm Init">
                Helm Init
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-inspect" title="Switch to Helm Inspect">
                Helm Inspect
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-inspect-chart" title="Switch to Helm Inspect Chart">
                Helm Inspect Chart
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-inspect-values" title="Switch to Helm Inspect Values">
                Helm Inspect Values
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-install" title="Switch to Helm Install">
                Helm Install
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-lint" title="Switch to Helm Lint">
                Helm Lint
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-list" title="Switch to Helm List">
                Helm List
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-package" title="Switch to Helm Package">
                Helm Package
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-plugin" title="Switch to Helm Plugin">
                Helm Plugin
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-plugin-install" title="Switch to Helm Plugin Install">
                Helm Plugin Install
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-plugin-list" title="Switch to Helm Plugin List">
                Helm Plugin List
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-plugin-remove" title="Switch to Helm Plugin Remove">
                Helm Plugin Remove
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-plugin-update" title="Switch to Helm Plugin Update">
                Helm Plugin Update
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-repo" title="Switch to Helm Repo">
                Helm Repo
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-repo-add" title="Switch to Helm Repo Add">
                Helm Repo Add
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-repo-index" title="Switch to Helm Repo Index">
                Helm Repo Index
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-rep-list" title="Switch to Helm Repo List">
                Helm Repo List
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-repo-remove" title="Switch to Helm Repo Remove">
                Helm Repo Remove
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-repo-update" title="Switch to Helm Repo Update">
                Helm Repo Update
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-reset" title="Switch to Helm Reset">
                Helm Reset
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-rollback" title="Switch to Helm Rollback">
                Helm Rollback
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-search" title="Switch to Helm Search">
                Helm Search
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-serve" title="Switch to Helm Serve">
                Helm Serve
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-status" title="Switch to Helm Status">
                Helm Status
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-template" title="Switch to Helm Template">
                Helm Template
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-test" title="Switch to Helm Test">
                Helm Test
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-upgrade" title="Switch to Helm Upgrade">
                Helm Upgrade
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-verify" title="Switch to Helm Verify">
                Helm Verify
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/helm/#helm-version" title="Switch to Helm Version">
                Helm Version
              </a>
            </li>
            
          </ul>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="developing_charts" state="">
            <span class="ripple">Charts <span></span></span>
          </a>
          
          <ul class="current">
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#charts" title="Switch to Intro to Charts">
                Intro to Charts
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#hooks" title="Switch to Chart Lifecycle Hooks">
                Chart Lifecycle Hooks
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#chart-development-tips-and-tricks" title="Switch to Charts Tips and Tricks">
                Charts Tips and Tricks
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#the-chart-repository-guide" title="Switch to Charts Repository Guide">
                Charts Repository Guide
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#syncing-your-chart-repository" title="Switch to Syncing Your Chart Repo">
                Syncing Your Chart Repo
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#helm-provenance-and-integrity" title="Switch to Signing Charts">
                Signing Charts
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#chart-tests" title="Switch to Chart Tests">
                Chart Tests
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/developing_charts/#chart-repositories-frequently-asked-questions" title="Switch to Chart Repository FAQ">
                Chart Repository FAQ
              </a>
            </li>
            
          </ul>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="chart_template_guide" state="">
            <span class="ripple">Developing Templates <span></span></span>
          </a>
          
          <ul class="current">
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#the-chart-template-developer-s-guide" title="Switch to Intro">
                Intro
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#getting-started-with-a-chart-template" title="Switch to Getting Started">
                Getting Started
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#built-in-objects" title="Switch to Built-In Objects">
                Built-In Objects
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#values-files" title="Switch to Values Files">
                Values Files
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#template-functions-and-pipelines" title="Switch to Template Functions and Pipelines">
                Template Functions and Pipelines
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#flow-control" title="Switch to Flow Control">
                Flow Control
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#variables" title="Switch to Variables">
                Variables
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#named-templates" title="Switch to Named Templates">
                Named Templates
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#accessing-files-inside-templates" title="Switch to Accessing Files Inside Templates">
                Accessing Files Inside Templates
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#creating-a-notes-txt-file" title="Switch to Creating a NOTES.txt File">
                Creating a NOTES.txt File
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#subcharts-and-global-values" title="Switch to Subcharts and Global Values">
                Subcharts and Global Values
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#debugging-templates" title="Switch to Debugging Templates">
                Debugging Templates
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#wrapping-up" title="Switch to Next Steps">
                Next Steps
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#yaml-techniques" title="Switch to Appendix: YAML Techniques">
                Appendix: YAML Techniques
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_template_guide/#appendix-go-data-types-and-templates" title="Switch to Appendix: Go Data Types and Templates">
                Appendix: Go Data Types and Templates
              </a>
            </li>
            
          </ul>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/chart_best_practices/" state="">
            <span class="ripple">Best Practices <span></span></span>
          </a>
          
          <ul class="current">
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#the-chart-best-practices-guide" title="Switch to Intro">
                Intro
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#general-conventions" title="Switch to General Conventions">
                General Conventions
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#values" title="Switch to Values">
                Values
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#templates" title="Switch to Templates">
                Templates
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#requirements-files" title="Switch to Requirements">
                Requirements
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#labels-and-annotations" title="Switch to Labels &amp; Annotations">
                Labels &amp; Annotations
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#pods-and-podtemplates" title="Switch to Pods &amp; PodTemplates">
                Pods &amp; PodTemplates
              </a>
            </li>
            
            <li class="toctree-l2 ">
              <a href="../../docs/chart_best_practices/#custom-resource-definitions" title="Switch to Custom Resource Definitions">
                Custom Resource Definitions
              </a>
            </li>
            
          </ul>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/docs/related/" state="">
            <span class="ripple">Related Projects <span></span></span>
          </a>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/docs/architecture/" state="">
            <span class="ripple">Architecture <span></span></span>
          </a>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/docs/developers/" state="">
            <span class="ripple">Developer Guide <span></span></span>
          </a>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/docs/history/" state="">
            <span class="ripple">History <span></span></span>
          </a>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="/docs/glossary/" state="">
            <span class="ripple">Glossary <span></span></span>
          </a>
          
        </li>
        
        <li class="sidebar-nav-item toctree-l1 ">
          <a class="reference internal" href="http://github.com/helm/charts" state="">
            <span class="ripple">Find Charts <span></span></span>
          </a>
          
        </li>
        
      </ul>
    </nav>

    <aside class="sidebar-buttons">
      <div class="button-wrap">
        <a href="https://github.com/helm/helm" class="button small primary expand email-support"><i class="fa fa-github"></i> Contribute to Docs</a>
      </div>
    </aside>
  </div>
</div>


    <div class="main page" id="scrollpane">
      <nav class="top-bar">
  <div class="breadcrumb">
    <a href="../">Docs</a>
  </div>
  <ul class="inline right text-right">
    <li><a href="https://helm.sh" target="_blank" title="Find out more about Helm."><i class="fa fa-home"></i> Helm.sh</a></li>
    <li><a href="https://github.com/helm/helm" target="_blank" title="Go to the Helm project on Github."><i class="fa fa-github"></i> Github</a></li>
    <li><a href="http://github.com/helm/charts" target="_blank" title="Go find apps via the Kubernetes Chart repository."><i class="fa fa-search"></i> Find Charts</a></li>
  </ul>
</nav>


      <div class="row">
        <div class="small-1 columns">&nbsp;</div>
        <div class="small-10 columns content-wrap">
          
            <article id="">
  <div>

<h1 id="helm-docs-content">Helm Docs Content</h1>

<p>This is where you would normally find markdown files used by Hugo to generate the website docs content - but this directory is intentionally empty as the files are imported and generated from the external source during the site build task.</p>

<h2 id="build-task">Build Task</h2>

<p>The <a href="https://github.com/helm/helm-www/blob/master/docs.helm.sh/gulpfile.js#L112L118">gulpfile</a> clones the main Helm Repo, and imports the docs directly from there.</p>

<h2 id="editing-docs">Editing Docs</h2>

<p>The writing and editing of docs should take place at <a href="https://github.com/helm/helm">the source</a>.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="the-kubernetes-helm-architecture">The Kubernetes Helm Architecture</h1>

<p>This document describes the Helm architecture at a high level.</p>

<h2 id="the-purpose-of-helm">The Purpose of Helm</h2>

<p>Helm is a tool for managing Kubernetes packages called <em>charts</em>. Helm
can do the following:</p>

<ul>
<li>Create new charts from scratch</li>
<li>Package charts into chart archive (tgz) files</li>
<li>Interact with chart repositories where charts are stored</li>
<li>Install and uninstall charts into an existing Kubernetes cluster</li>
<li>Manage the release cycle of charts that have been installed with Helm</li>
</ul>

<p>For Helm, there are three important concepts:</p>

<ol>
<li>The <em>chart</em> is a bundle of information necessary to create an
instance of a Kubernetes application.</li>
<li>The <em>config</em> contains configuration information that can be merged
into a packaged chart to create a releasable object.</li>
<li>A <em>release</em> is a running instance of a <em>chart</em>, combined with a
specific <em>config</em>.</li>
</ol>

<h2 id="components">Components</h2>

<p>Helm has two major components:</p>

<p><strong>The Helm Client</strong> is a command-line client for end users. The client
is responsible for the following domains:</p>

<ul>
<li>Local chart development</li>
<li>Managing repositories</li>
<li>Interacting with the Tiller server

<ul>
<li>Sending charts to be installed</li>
<li>Asking for information about releases</li>
<li>Requesting upgrading or uninstalling of existing releases</li>
</ul></li>
</ul>

<p><strong>The Tiller Server</strong> is an in-cluster server that interacts with the
Helm client, and interfaces with the Kubernetes API server. The server
is responsible for the following:</p>

<ul>
<li>Listening for incoming requests from the Helm client</li>
<li>Combining a chart and configuration to build a release</li>
<li>Installing charts into Kubernetes, and then tracking the subsequent
release</li>
<li>Upgrading and uninstalling charts by interacting with Kubernetes</li>
</ul>

<p>In a nutshell, the client is responsible for managing charts, and the
server is responsible for managing releases.</p>

<h2 id="implementation">Implementation</h2>

<p>The Helm client is written in the Go programming language, and uses the
gRPC protocol suite to interact with the Tiller server.</p>

<p>The Tiller server is also written in Go. It provides a gRPC server to
connect with the client, and it uses the Kubernetes client library to
communicate with Kubernetes. Currently, that library uses REST+JSON.</p>

<p>The Tiller server stores information in ConfigMaps located inside of
Kubernetes. It does not need its own database.</p>

<p>Configuration files are, when possible, written in YAML.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="the-chart-best-practices-guide">The Chart Best Practices Guide</h1>

<p>This guide covers the Helm Team&rsquo;s considered best practices for creating charts.
It focuses on how charts should be structured.</p>

<p>We focus primarily on best practices for charts that may be publicly deployed.
We know that many charts are for internal-use only, and authors of such charts
may find that their internal interests override our suggestions here.</p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
<li><a href="./#conventions">General Conventions</a>: Learn about general chart conventions.</li>
<li><a href="./#values">Values Files</a>: See the best practices for structuring <code>values.yaml</code>.</li>
<li><a href="./#templates">Templates</a>: Learn some of the best techniques for writing templates.</li>
<li><a href="./#requirements">Requirements</a>: Follow best practices for <code>requirements.yaml</code> files.</li>
<li><a href="./#labels">Labels and Annotations</a>: Helm has a <em>heritage</em> of labeling and annotating.</li>
<li>Kubernetes Resources:

<ul>
<li><a href="./#pods">Pods and Pod Specs</a>: See the best practices for working with pod specifications.</li>
<li><a href="./#role-based-access-control">Role-Based Access Control</a>: Guidance on creating and using service accounts, roles, and role bindings.</li>
<li><a href="./#custom_resource_definitions">Custom Resource Definitions</a>: Custom Resource Definitions (CRDs) have their own associated best practices.</li>
</ul></li>
</ul>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="general-conventions">General Conventions</h1>

<p>This part of the Best Practices Guide explains general conventions.</p>

<h2 id="chart-names">Chart Names</h2>

<p>Chart names should use lower case letters and numbers, and start with a letter.</p>

<p>Hyphens (-) are allowed, but are known to be a little trickier to work with in Helm templates (see <a href="https://github.com/helm/helm/issues/2192">issue #2192</a> for more information).</p>

<p>Here are a few examples of good chart names from the <a href="https://github.com/helm/charts">Helm Community Charts</a>:</p>

<pre><code>drupal
cert-manager
oauth2-proxy
</code></pre>

<p>Neither uppercase letters nor underscores should be used in chart names. Dots should not be used in chart names.</p>

<p>The directory that contains a chart MUST have the same name as the chart. Thus, the chart <code>cert-manager</code> MUST be created in a directory called <code>cert-manager/</code>. This is not merely a stylistic detail, but a requirement of the Helm Chart format.</p>

<h2 id="version-numbers">Version Numbers</h2>

<p>Wherever possible, Helm uses <a href="http://semver.org">SemVer 2</a> to represent version numbers. (Note that Docker image tags do not necessarily follow SemVer, and are thus considered an unfortunate exception to the rule.)</p>

<p>When SemVer versions are stored in Kubernetes labels, we conventionally alter the <code>+</code> character to an <code>_</code> character, as labels do not allow the <code>+</code> sign as a value.</p>

<h2 id="formatting-yaml">Formatting YAML</h2>

<p>YAML files should be indented using <em>two spaces</em> (and never tabs).</p>

<h2 id="usage-of-the-words-helm-tiller-and-chart">Usage of the Words Helm, Tiller, and Chart</h2>

<p>There are a few small conventions followed for using the words Helm, helm, Tiller, and tiller.</p>

<ul>
<li>Helm refers to the project, and is often used as an umbrella term</li>
<li><code>helm</code> refers to the client-side command</li>
<li>Tiller is the proper name of the backend</li>
<li><code>tiller</code> is the name of the binary run on the backend</li>
<li>The term &lsquo;chart&rsquo; does not need to be capitalized, as it is not a proper noun.</li>
</ul>

<p>When in doubt, use <em>Helm</em> (with an uppercase &lsquo;H&rsquo;).</p>

<h2 id="restricting-tiller-by-version">Restricting Tiller by Version</h2>

<p>A <code>Chart.yaml</code> file can specify a <code>tillerVersion</code> SemVer constraint:</p>

<pre><code class="language-yaml">name: mychart
version: 0.2.0
tillerVersion: &quot;&gt;=2.4.0&quot;
</code></pre>

<p>This constraint should be set when templates use a new feature that was not
supported in older versions of Helm. While this parameter will accept sophisticated
SemVer rules, the best practice is to default to the form <code>&gt;=2.4.0</code>, where <code>2.4.0</code>
is the version that introduced the new feature used in the chart.</p>

<p>This feature was introduced in Helm 2.4.0, so any version of Tiller older than
2.4.0 will simply ignore this field.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="custom-resource-definitions">Custom Resource Definitions</h1>

<p>This section of the Best Practices Guide deals with creating and using Custom Resource Definition
objects.</p>

<p>When working with Custom Resource Definitions (CRDs), it is important to distinguish
two different pieces:</p>

<ul>
<li>There is a declaration of a CRD. This is the YAML file that has the kind <code>CustomResourceDefinition</code></li>
<li>Then there are resources that <em>use</em> the CRD. Say a CRD defines <code>foo.example.com/v1</code>. Any resource
that has <code>apiVersion: example.com/v1</code> and kind <code>Foo</code> is a resource that uses the CRD.</li>
</ul>

<h2 id="install-a-crd-declaration-before-using-the-resource">Install a CRD Declaration Before Using the Resource</h2>

<p>Helm is optimized to load as many resources into Kubernetes as fast as possible.
By design, Kubernetes can take an entire set of manifests and bring them all
online (this is called the reconciliation loop).</p>

<p>But there&rsquo;s a difference with CRDs.</p>

<p>For a CRD, the declaration must be registered before any resources of that CRDs
kind(s) can be used. And the registration process sometimes takes a few seconds.</p>

<h3 id="method-1-separate-charts">Method 1: Separate Charts</h3>

<p>One way to do this is to put the CRD definition in one chart, and then put any
resources that use that CRD in <em>another</em> chart.</p>

<p>In this method, each chart must be installed separately.</p>

<h3 id="method-2-pre-install-hooks">Method 2: Pre-install Hooks</h3>

<p>To package the two together, add a <code>pre-install</code> hook to the CRD definition so
that it is fully installed before the rest of the chart is executed.</p>

<p>Note that if you create the CRD with a <code>pre-install</code> hook, that CRD definition
will not be deleted when <code>helm delete</code> is run.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="labels-and-annotations">Labels and Annotations</h1>

<p>This part of the Best Practices Guide discusses the best practices for using
labels and annotations in your chart.</p>

<h2 id="is-it-a-label-or-an-annotation">Is it a Label or an Annotation?</h2>

<p>An item of metadata should be a label under the following conditions:</p>

<ul>
<li>It is used by Kubernetes to identify this resource</li>
<li>It is useful to expose to operators for the purpose of querying the system.</li>
</ul>

<p>For example, we suggest using <code>helm.sh/chart: NAME-VERSION</code> as a label so that operators
can conveniently find all of the instances of a particular chart to use.</p>

<p>If an item of metadata is not used for querying, it should be set as an annotation
instead.</p>

<p>Helm hooks are always annotations.</p>

<h2 id="standard-labels">Standard Labels</h2>

<p>The following table defines common labels that Helm charts use. Helm itself never requires that a particular label be present. Labels that are marked REC
are recommended, and <em>should</em> be placed onto a chart for global consistency. Those marked OPT are optional. These are idiomatic or commonly in use, but are not relied upon frequently for operational purposes.</p>

<table>
<thead>
<tr>
<th>Name</th>
<th>Status</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>app.kubernetes.io/name</code></td>
<td>REC</td>
<td>This should be the app name, reflecting the entire app. Usually <code>{{ template &quot;name&quot; . }}</code> is used for this. This is used by many Kubernetes manifests, and is not Helm-specific.</td>
</tr>

<tr>
<td><code>helm.sh/chart</code></td>
<td>REC</td>
<td>This should be the chart name and version: <code>{{ .Chart.Name }}-{{ .Chart.Version \| replace &quot;+&quot; &quot;_&quot; }}</code>.</td>
</tr>

<tr>
<td><code>app.kubernetes.io/managed-by</code></td>
<td>REC</td>
<td>This should always be set to <code>{{ .Release.Service }}</code>. It is for finding all things managed by Tiller.</td>
</tr>

<tr>
<td><code>app.kubernetes.io/instance</code></td>
<td>REC</td>
<td>This should be the <code>{{ .Release.Name }}</code>. It aids in differentiating between different instances of the same application.</td>
</tr>

<tr>
<td><code>app.kubernetes.io/version</code></td>
<td>OPT</td>
<td>The version of the app and can be set to <code>{{ .Chart.AppVersion }}</code>.</td>
</tr>

<tr>
<td><code>app.kubernetes.io/component</code></td>
<td>OPT</td>
<td>This is a common label for marking the different roles that pieces may play in an application. For example, <code>app.kubernetes.io/component: frontend</code>.</td>
</tr>

<tr>
<td><code>app.kubernetes.io/part-of</code></td>
<td>OPT</td>
<td>When multiple charts or pieces of software are used together to make one application. For example, application software and a database to produce a website. This can be set to the top level application being supported.</td>
</tr>
</tbody>
</table>

<p>You can find more information on the Kubernetes labels, prefixed with <code>app.kubernetes.io</code>, in the <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/">Kubernetes documentation</a>.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="pods-and-podtemplates">Pods and PodTemplates</h1>

<p>This part of the Best Practices Guide discusses formatting the Pod and PodTemplate
portions in chart manifests.</p>

<p>The following (non-exhaustive) list of resources use PodTemplates:</p>

<ul>
<li>Deployment</li>
<li>ReplicationController</li>
<li>ReplicaSet</li>
<li>DaemonSet</li>
<li>StatefulSet</li>
</ul>

<h2 id="images">Images</h2>

<p>A container image should use a fixed tag or the SHA of the image. It should not use the tags <code>latest</code>, <code>head</code>, <code>canary</code>, or other tags that are designed to be &ldquo;floating&rdquo;.</p>

<p>Images <em>may</em> be defined in the <code>values.yaml</code> file to make it easy to swap out images.</p>

<pre><code>image: {{ .Values.redisImage | quote }}
</code></pre>

<p>An image and a tag <em>may</em> be defined in <code>values.yaml</code> as two separate fields:</p>

<pre><code>image: &quot;{{ .Values.redisImage }}:{{ .Values.redisTag }}&quot;
</code></pre>

<h2 id="imagepullpolicy">ImagePullPolicy</h2>

<p><code>helm create</code> sets the <code>imagePullPolicy</code> to <code>IfNotPresent</code> by default by doing the following in your <code>deployment.yaml</code>:</p>

<pre><code class="language-yaml">imagePullPolicy: {{ .Values.image.pullPolicy }}
</code></pre>

<p>And <code>values.yaml</code>:</p>

<pre><code class="language-yaml">pullPolicy: IfNotPresent
</code></pre>

<p>Similarly, Kubernetes defaults the <code>imagePullPolicy</code> to <code>IfNotPresent</code> if it is not defined at all. If you want a value other than <code>IfNotPresent</code>, simply update the value in <code>values.yaml</code> to your desired value.</p>

<h2 id="podtemplates-should-declare-selectors">PodTemplates Should Declare Selectors</h2>

<p>All PodTemplate sections should specify a selector. For example:</p>

<pre><code class="language-yaml">selector:
  matchLabels:
      app.kubernetes.io/name: MyName
template:
  metadata:
    labels:
      app.kubernetes.io/name: MyName
</code></pre>

<p>This is a good practice because it makes the relationship between the set and
the pod.</p>

<p>But this is even more important for sets like Deployment.
Without this, the <em>entire</em> set of labels is used to select matching pods, and
this will break if you use labels that change, like version or release date.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="role-based-access-control">Role-Based Access Control</h1>

<p>This part of the Best Practices Guide discusses the creation and formatting of RBAC resources in chart manifests.</p>

<p>RBAC resources are:</p>

<ul>
<li>ServiceAccount (namespaced)</li>
<li>Role (namespaced)</li>
<li>ClusterRole</li>
<li>RoleBinding (namespaced)</li>
<li>ClusterRoleBinding</li>
</ul>

<h2 id="yaml-configuration">YAML Configuration</h2>

<p>RBAC and ServiceAccount configuration should happen under separate keys. They are separate things. Splitting these two concepts out in the YAML disambiguates them and make this clearer.</p>

<pre><code class="language-yaml">rbac:
  # Specifies whether RBAC resources should be created
  create: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  name:
</code></pre>

<p>This structure can be extended for more complex charts that require multiple ServiceAccounts.</p>

<pre><code class="language-yaml">serviceAccounts:
  client:
    create: true
    name:
  server: 
    create: true
    name:
</code></pre>

<h2 id="rbac-resources-should-be-created-by-default">RBAC Resources Should be Created by Default</h2>

<p><code>rbac.create</code> should be a boolean value controlling whether RBAC resources are created.  The default should be <code>true</code>.  Users who wish to manage RBAC access controls themselves can set this value to <code>false</code> (in which case see below).</p>

<h2 id="using-rbac-resources">Using RBAC Resources</h2>

<p><code>serviceAccount.name</code> should set to the name of the ServiceAccount to be used by access-controlled resources created by the chart.  If <code>serviceAccount.create</code> is true, then a ServiceAccount with this name should be created.  If the name is not set, then a name is generated using the <code>fullname</code> template, If <code>serviceAccount.create</code> is false, then it should not be created, but it should still be associated with the same resources so that manually-created RBAC resources created later that reference it will function correctly.  If <code>serviceAccount.create</code> is false and the name is not specified, then the default ServiceAccount is used.</p>

<p>The following helper template should be used for the ServiceAccount.</p>

<pre><code class="language-yaml">{{/*
Create the name of the service account to use
*/}}
{{- define &quot;mychart.serviceAccountName&quot; -}}
{{- if .Values.serviceAccount.create -}}
    {{ default (include &quot;mychart.fullname&quot; .) .Values.serviceAccount.name }}
{{- else -}}
    {{ default &quot;default&quot; .Values.serviceAccount.name }}
{{- end -}}
{{- end -}}
</code></pre>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="requirements-files">Requirements Files</h1>

<p>This section of the guide covers best practices for <code>requirements.yaml</code> files.</p>

<h2 id="versions">Versions</h2>

<p>Where possible, use version ranges instead of pinning to an exact version. The suggested default is to use a patch-level version match:</p>

<pre><code class="language-yaml">version: ~1.2.3
</code></pre>

<p>This will match version <code>1.2.3</code> and any patches to that release.  In other words, <code>~1.2.3</code> is equivalent to <code>&gt;= 1.2.3, &lt; 1.3.0</code></p>

<p>For the complete version matching syntax, please see the <a href="https://github.com/Masterminds/semver#checking-version-constraints">semver documentation</a></p>

<h3 id="repository-urls">Repository URLs</h3>

<p>Where possible, use <code>https://</code> repository URLs, followed by <code>http://</code> URLs.</p>

<p>If the repository has been added to the repository index file, the repository name can be used as an alias of URL. Use <code>alias:</code> or <code>@</code> followed by repository names.</p>

<p>File URLs (<code>file://...</code>) are considered a &ldquo;special case&rdquo; for charts that are assembled by a fixed deployment pipeline. Charts that use <code>file://</code> in a <code>requirements.yaml</code> file are not allowed in the official Helm repository.</p>

<h2 id="conditions-and-tags">Conditions and Tags</h2>

<p>Conditions or tags should be added to any dependencies that <em>are optional</em>.</p>

<p>The preferred form of a condition is:</p>

<pre><code class="language-yaml">condition: somechart.enabled
</code></pre>

<p>Where <code>somechart</code> is the chart name of the dependency.</p>

<p>When multiple subcharts (dependencies) together provide an optional or swappable feature, those charts should share the same tags.</p>

<p>For example, if both <code>nginx</code> and <code>memcached</code> together provided performance optimizations for the main app in the chart, and were required to both be present when that feature is enabled, then they might both have a
tags section like this:</p>

<pre><code>tags:
  - webaccelerator
</code></pre>

<p>This allows a user to turn that feature on and off with one tag.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="templates">Templates</h1>

<p>This part of the Best Practices Guide focuses on templates.</p>

<h2 id="structure-of-templates">Structure of templates/</h2>

<p>The templates directory should be structured as follows:</p>

<ul>
<li>Template files should have the extension <code>.yaml</code> if they produce YAML output. The
extension <code>.tpl</code> may be used for template files that produce no formatted content.</li>
<li>Template file names should use dashed notation (<code>my-example-configmap.yaml</code>), not camelcase.</li>
<li>Each resource definition should be in its own template file.</li>
<li>Template file names should reflect the resource kind in the name. e.g. <code>foo-pod.yaml</code>,
<code>bar-svc.yaml</code></li>
</ul>

<h2 id="names-of-defined-templates">Names of Defined Templates</h2>

<p>Defined templates (templates created inside a <code>{{ define }}</code> directive) are
globally accessible. That means that a chart and all of its subcharts will have
access to all of the templates created with <code>{{ define }}</code>.</p>

<p>For that reason, <em>all defined template names should be namespaced.</em></p>

<p>Correct:</p>

<pre><code class="language-yaml">{{- define &quot;nginx.fullname&quot; }}
{{/* ... */}}
{{ end -}}
</code></pre>

<p>Incorrect:</p>

<pre><code class="language-yaml">{{- define &quot;fullname&quot; -}}
{{/* ... */}}
{{ end -}}
</code></pre>

<p>It is highly recommended that new charts are created via <code>helm create</code> command as the template names are automatically defined as per this best practice.</p>

<h2 id="formatting-templates">Formatting Templates</h2>

<p>Templates should be indented using <em>two spaces</em> (never tabs).</p>

<p>Template directives should have whitespace after the opening  braces and before the
closing braces:</p>

<p>Correct:</p>

<pre><code>{{ .foo }}
{{ print &quot;foo&quot; }}
{{- print &quot;bar&quot; -}}
</code></pre>

<p>Incorrect:</p>

<pre><code>{{.foo}}
{{print &quot;foo&quot;}}
{{-print &quot;bar&quot;-}}
</code></pre>

<p>Templates should chomp whitespace where possible:</p>

<pre><code>foo:
  {{- range .Values.items }}
  {{ . }}
  {{ end -}}
</code></pre>

<p>Blocks (such as control structures) may be indented to indicate flow of the template code.</p>

<pre><code>{{ if $foo -}}
  {{- with .Bar }}Hello{{ end -}}
{{- end -}} 
</code></pre>

<p>However, since YAML is a whitespace-oriented language, it is often not possible for code indentation to follow that convention.</p>

<h2 id="whitespace-in-generated-templates">Whitespace in Generated Templates</h2>

<p>It is preferable to keep the amount of whitespace in generated templates to
a minimum. In particular, numerous blank lines should not appear adjacent to each
other. But occasional empty lines (particularly between logical sections) is
fine.</p>

<p>This is best:</p>

<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: example
  labels:
    first: first
    second: second
</code></pre>

<p>This is okay:</p>

<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job

metadata:
  name: example

  labels:
    first: first
    second: second

</code></pre>

<p>But this should be avoided:</p>

<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job

metadata:
  name: example





  labels:
    first: first

    second: second

</code></pre>

<h2 id="resource-naming-in-templates">Resource Naming in Templates</h2>

<p>Hard-coding the <code>name:</code> into a resource is usually considered to be bad practice.
Names should be unique to a release. So we might want to generate a name field
by inserting the release name - for example:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: {{ .Release.Name }}-myservice
</code></pre>

<p>Or if there is only one resource of this kind then we could use .Release.Name or the template fullname function defined in _helpers.tpl (which uses release name):</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: {{ template &quot;fullname&quot; . }}
</code></pre>

<p>However, there may be cases where it is known that there won&rsquo;t be naming conflicts from a fixed name.
In these cases a fixed name might make it easier for an application to find a resource such as a Service.
If the option for fixed names is needed then one way to manage this might be to make the setting of the name explicit by using a service.name value from the values.yaml if provided:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  {{- if .Values.service.name }}
    name: {{ .Values.service.name }}
  {{- else }}
    name: {{ template &quot;fullname&quot; . }}
  {{- end }}
</code></pre>

<h2 id="comments-yaml-comments-vs-template-comments">Comments (YAML Comments vs. Template Comments)</h2>

<p>Both YAML and Helm Templates have comment markers.</p>

<p>YAML comments:</p>

<pre><code class="language-yaml"># This is a comment
type: sprocket
</code></pre>

<p>Template Comments:</p>

<pre><code class="language-yaml">{{- /*
This is a comment.
*/ -}}
type: frobnitz
</code></pre>

<p>Template comments should be used when documenting features of a template, such as explaining a defined template:</p>

<pre><code class="language-yaml">{{- /*
mychart.shortname provides a 6 char truncated version of the release name.
*/ -}}
{{ define &quot;mychart.shortname&quot; -}}
{{ .Release.Name | trunc 6 }}
{{- end -}}

</code></pre>

<p>Inside of templates, YAML comments may be used when it is useful for Helm users to (possibly) see the comments during debugging.</p>

<pre><code># This may cause problems if the value is more than 100Gi
memory: {{ .Values.maxMem | quote }}
</code></pre>

<p>The comment above is visible when the user runs <code>helm install --debug</code>, while
comments specified in <code>{{- /* */ -}}</code> sections are not.</p>

<h2 id="use-of-json-in-templates-and-template-output">Use of JSON in Templates and Template Output</h2>

<p>YAML is a superset of JSON. In some cases, using a JSON syntax can be more
readable than other YAML representations.</p>

<p>For example, this YAML is closer to the normal YAML method of expressing lists:</p>

<pre><code class="language-yaml">arguments: 
  - &quot;--dirname&quot;
  - &quot;/foo&quot;
</code></pre>

<p>But it is easier to read when collapsed into a JSON list style:</p>

<pre><code class="language-yaml">arguments: [&quot;--dirname&quot;, &quot;/foo&quot;]
</code></pre>

<p>Using JSON for increased legibility is good. However, JSON syntax should not
be used for representing more complex constructs.</p>

<p>When dealing with pure JSON embedded inside of YAML (such as init container
configuration), it is of course appropriate to use the JSON format.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="values">Values</h1>

<p>This part of the best practices guide covers using values. In this part of the
guide, we provide recommendations on how you should structure and use your
values, with focus on designing a chart&rsquo;s <code>values.yaml</code> file.</p>

<h2 id="naming-conventions">Naming Conventions</h2>

<p>Variables names should begin with a lowercase letter, and words should be
separated with camelcase:</p>

<p>Correct:</p>

<pre><code class="language-yaml">chicken: true
chickenNoodleSoup: true
</code></pre>

<p>Incorrect:</p>

<pre><code class="language-yaml">Chicken: true  # initial caps may conflict with built-ins
chicken-noodle-soup: true # do not use hyphens in the name
</code></pre>

<p>Note that all of Helm&rsquo;s built-in variables begin with an uppercase letter to
easily distinguish them from user-defined values: <code>.Release.Name</code>,
<code>.Capabilities.KubeVersion</code>.</p>

<h2 id="flat-or-nested-values">Flat or Nested Values</h2>

<p>YAML is a flexible format, and values may be nested deeply or flattened.</p>

<p>Nested:</p>

<pre><code class="language-yaml">server:
  name: nginx
  port: 80
</code></pre>

<p>Flat:</p>

<pre><code class="language-yaml">serverName: nginx
serverPort: 80
</code></pre>

<p>In most cases, flat should be favored over nested. The reason for this is that
it is simpler for template developers and users.</p>

<p>For optimal safety, a nested value must be checked at every level:</p>

<pre><code>{{ if .Values.server }}
  {{ default &quot;none&quot; .Values.server.name }}
{{ end }}
</code></pre>

<p>For every layer of nesting, an existence check must be done. But for flat
configuration, such checks can be skipped, making the template easier to read
and use.</p>

<pre><code>{{ default &quot;none&quot; .Values.serverName }}
</code></pre>

<p>When there are a large number of related variables, and at least one of them
is non-optional, nested values may be used to improve readability.</p>

<h2 id="make-types-clear">Make Types Clear</h2>

<p>YAML&rsquo;s type coercion rules are sometimes counterintuitive. For example,
<code>foo: false</code> is not the same as <code>foo: &quot;false&quot;</code>. Large integers like <code>foo: 12345678</code>
will get converted to scientific notation in some cases.</p>

<p>The easiest way to avoid type conversion errors is to be explicit about strings,
and implicit about everything else. Or, in short, <em>quote all strings</em>.</p>

<p>Often, to avoid the integer casting issues, it is advantageous to store your
integers as strings as well, and use <code>{{ int $value }}</code> in the template to convert
from a string back to an integer.</p>

<p>In most cases, explicit type tags are respected, so <code>foo: !!string 1234</code> should
treat <code>1234</code> as a string. <em>However</em>, the YAML parser consumes tags, so the type
data is lost after one parse.</p>

<h2 id="consider-how-users-will-use-your-values">Consider How Users Will Use Your Values</h2>

<p>There are three potential sources of values:</p>

<ul>
<li>A chart&rsquo;s <code>values.yaml</code> file</li>
<li>A values file supplied by <code>helm install -f</code> or <code>helm upgrade -f</code></li>
<li>The values passed to a <code>--set</code> or <code>--set-string</code> flag on <code>helm install</code> or <code>helm upgrade</code></li>
<li>The content of a file passed to <code>--set-file</code> flag on <code>helm install</code> or <code>helm upgrade</code></li>
</ul>

<p>When designing the structure of your values, keep in mind that users of your
chart may want to override them via either the <code>-f</code> flag or with the <code>--set</code>
option.</p>

<p>Since <code>--set</code> is more limited in expressiveness, the first guidelines for writing
your <code>values.yaml</code> file is <em>make it easy to override from <code>--set</code></em>.</p>

<p>For this reason, it&rsquo;s often better to structure your values file using maps.</p>

<p>Difficult to use with <code>--set</code>:</p>

<pre><code class="language-yaml">servers:
  - name: foo
    port: 80
  - name: bar
    port: 81
</code></pre>

<p>The above cannot be expressed with <code>--set</code> in Helm <code>&lt;=2.4</code>. In Helm 2.5, the
accessing the port on foo is <code>--set servers[0].port=80</code>. Not only is it harder
for the user to figure out, but it is prone to errors if at some later time the
order of the <code>servers</code> is changed.</p>

<p>Easy to use:</p>

<pre><code class="language-yaml">servers:
  foo:
    port: 80
  bar:
    port: 81
</code></pre>

<p>Accessing foo&rsquo;s port is much more obvious: <code>--set servers.foo.port=80</code>.</p>

<h2 id="document-values-yaml">Document &lsquo;values.yaml&rsquo;</h2>

<p>Every defined property in &lsquo;values.yaml&rsquo; should be documented. The documentation string should begin with the name of the property that it describes, and then give at least a one-sentence description.</p>

<p>Incorrect:</p>

<pre><code># the host name for the webserver
serverHost = example
serverPort = 9191
</code></pre>

<p>Correct:</p>

<pre><code># serverHost is the host name for the webserver
serverHost = example
# serverPort is the HTTP listener port for the webserver
serverPort = 9191

</code></pre>

<p>Beginning each comment with the name of the parameter it documents makes it easy to grep out documentation, and will enable documentation tools to reliably correlate doc strings with the parameters they describe.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="the-chart-repository-guide">The Chart Repository Guide</h1>

<p>This section explains how to create and work with Helm chart repositories. At a
high level, a chart repository is a location where packaged charts can be
stored and shared.</p>

<p>The official chart repository is maintained by the
<a href="https://github.com/helm/charts">Helm Charts</a>, and we welcome
participation. But Helm also makes it easy to create and run your own chart
repository. This guide explains how to do so.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>Go through the <a href="./#quickstart">Quickstart</a> Guide</li>
<li>Read through the <a href="./#charts">Charts</a> document</li>
</ul>

<h2 id="create-a-chart-repository">Create a chart repository</h2>

<p>A <em>chart repository</em> is an HTTP server that houses an <code>index.yaml</code> file and
optionally some packaged charts.  When you&rsquo;re ready to share your charts, the
preferred way to do so is by uploading them to a chart repository.</p>

<p><strong>Note:</strong> For Helm 2.0.0, chart repositories do not have any intrinsic
authentication. There is an <a href="https://github.com/helm/helm/issues/1038">issue tracking progress</a>
in GitHub.</p>

<p>Because a chart repository can be any HTTP server that can serve YAML and tar
files and can answer GET requests, you have a plethora of options when it comes
down to hosting your own chart repository. For example, you can use a Google
Cloud Storage (GCS) bucket, Amazon S3 bucket, Github Pages, or even create your
own web server.</p>

<h3 id="the-chart-repository-structure">The chart repository structure</h3>

<p>A chart repository consists of packaged charts and a special file called
<code>index.yaml</code> which contains an index of all of the charts in the repository.
Frequently, the charts that <code>index.yaml</code> describes are also hosted on the same
server, as are the <a href="./#helm-provenance-and-integrity">provenance files</a>.</p>

<p>For example, the layout of the repository <code>https://example.com/charts</code> might
look like this:</p>

<pre><code>charts/
  |
  |- index.yaml
  |
  |- alpine-0.1.2.tgz
  |
  |- alpine-0.1.2.tgz.prov
</code></pre>

<p>In this case, the index file would contain information about one chart, the Alpine
chart, and provide the download URL <code>https://example.com/charts/alpine-0.1.2.tgz</code>
for that chart.</p>

<p>It is not required that a chart package be located on the same server as the
<code>index.yaml</code> file. However, doing so is often the easiest.</p>

<h3 id="the-index-file">The index file</h3>

<p>The index file is a yaml file called <code>index.yaml</code>. It
contains some metadata about the package, including the contents of a
chart&rsquo;s <code>Chart.yaml</code> file. A valid chart repository must have an index file. The
index file contains information about each chart in the chart repository. The
<code>helm repo index</code> command will generate an index file based on a given local
directory that contains packaged charts.</p>

<p>This is an example of an index file:</p>

<pre><code>apiVersion: v1
entries:
  alpine:
    - created: 2016-10-06T16:23:20.499814565-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz
      version: 0.2.0
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz
      version: 0.1.0
  nginx:
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Create a basic nginx HTTP server
      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff
      home: https://k8s.io/helm
      name: nginx
      sources:
      - https://github.com/helm/charts
      urls:
      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz
      version: 1.1.0
generated: 2016-10-06T16:23:20.499029981-06:00
</code></pre>

<p>A generated index and packages can be served from a basic webserver. You can test
things out locally with the <code>helm serve</code> command, which starts a local server.</p>

<pre><code class="language-console">$ helm serve --repo-path ./charts
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
</code></pre>

<p>The above starts a local webserver, serving the charts it finds in <code>./charts</code>. The
serve command will automatically generate an <code>index.yaml</code> file for you during
startup.</p>

<h2 id="hosting-chart-repositories">Hosting Chart Repositories</h2>

<p>This part shows several ways to serve a chart repository.</p>

<h3 id="google-cloud-storage">Google Cloud Storage</h3>

<p>The first step is to <strong>create your GCS bucket</strong>. We&rsquo;ll call ours
<code>fantastic-charts</code>.</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-bucket.png" alt="Create a GCS Bucket" /></p>

<p>Next, make your bucket public by <strong>editing the bucket permissions</strong>.</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/edit-permissions.png" alt="Edit Permissions" /></p>

<p>Insert this line item to <strong>make your bucket public</strong>:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/make-bucket-public.png" alt="Make Bucket Public" /></p>

<p>Congratulations, now you have an empty GCS bucket ready to serve charts!</p>

<p>You may upload your chart repository using the Google Cloud Storage command line
tool, or using the GCS web UI. This is the technique the official Kubernetes
Charts repository hosts its charts, so you may want to take a
<a href="https://github.com/helm/charts">peek at that project</a> if you get stuck.</p>

<p><strong>Note:</strong> A public GCS bucket can be accessed via simple HTTPS at this address
<code>https://bucket-name.storage.googleapis.com/</code>.</p>

<h3 id="jfrog-artifactory">JFrog Artifactory</h3>

<p>You can also set up chart repositories using JFrog Artifactory.
Read more about chart repositories with JFrog Artifactory <a href="https://www.jfrog.com/confluence/display/RTF/Helm+Chart+Repositories">here</a></p>

<h3 id="github-pages-example">Github Pages example</h3>

<p>In a similar way you can create charts repository using GitHub Pages.</p>

<p>GitHub allows you to serve static web pages in two different ways:</p>

<ul>
<li>By configuring a project to serve the contents of its <code>docs/</code> directory</li>
<li>By configuring a project to serve a particular branch</li>
</ul>

<p>We&rsquo;ll take the second approach, though the first is just as easy.</p>

<p>The first step will be to <strong>create your gh-pages branch</strong>.  You can do that
locally as.</p>

<pre><code class="language-console">$ git checkout -b gh-pages
</code></pre>

<p>Or via web browser using <strong>Branch</strong> button on your Github repository:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-gh-page-button.png" alt="Create Github Pages branch" /></p>

<p>Next, you&rsquo;ll want to make sure your <strong>gh-pages branch</strong> is set as Github Pages,
click on your repo <strong>Settings</strong> and scroll down to <strong>Github pages</strong> section and
set as per below:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/set-a-gh-page.png" alt="Create Github Pages branch" /></p>

<p>By default <strong>Source</strong> usually gets set to <strong>gh-pages branch</strong>. If this is not set by default, then select it.</p>

<p>You can use a <strong>custom domain</strong> there if you wish so.</p>

<p>And check that <strong>Enforce HTTPS</strong> is ticked, so the <strong>HTTPS</strong> will be used when
charts are served.</p>

<p>In such setup you can use <strong>master branch</strong> to store your charts code, and
<strong>gh-pages branch</strong> as charts repository, e.g.:
<code>https://USERNAME.github.io/REPONAME</code>. The demonstration <a href="https://github.com/technosophos/tscharts">TS Charts</a>
repository is accessible at <code>https://technosophos.github.io/tscharts/</code>.</p>

<h3 id="ordinary-web-servers">Ordinary web servers</h3>

<p>To configure an ordinary web server to serve Helm charts, you merely need to do
the following:</p>

<ul>
<li>Put your index and charts in a directory that the server can serve</li>
<li>Make sure the <code>index.yaml</code> file can be accessed with no authentication requirement</li>
<li>Make sure <code>yaml</code> files are served with the correct content type (<code>text/yaml</code> or
<code>text/x-yaml</code>)</li>
</ul>

<p>For example, if you want to serve your charts out of <code>$WEBROOT/charts</code>, make sure
there is a <code>charts/</code> directory in your web root, and put the index file and
charts inside of that folder.</p>

<h2 id="managing-chart-repositories">Managing Chart Repositories</h2>

<p>Now that you have a chart repository, the last part of this guide explains how
to maintain charts in that repository.</p>

<h3 id="store-charts-in-your-chart-repository">Store charts in your chart repository</h3>

<p>Now that you have a chart repository, let&rsquo;s upload a chart and an index file to
the repository.  Charts in a chart repository must be packaged
(<code>helm package chart-name/</code>) and versioned correctly (following
<a href="https://semver.org/">SemVer 2</a> guidelines).</p>

<p>These next steps compose an example workflow, but you are welcome to use
whatever workflow you fancy for storing and updating charts in your chart
repository.</p>

<p>Once you have a packaged chart ready, create a new directory, and move your
packaged chart to that directory.</p>

<pre><code class="language-console">$ helm package docs/examples/alpine/
$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
$ helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>The last command takes the path of the local directory that you just created and
the URL of your remote chart repository and composes an <code>index.yaml</code> file inside the
given directory path.</p>

<p>Now you can upload the chart and the index file to your chart repository using
a sync tool or manually. If you&rsquo;re using Google Cloud Storage, check out this
<a href="./#developing_charts_sync_example">example workflow</a> using the gsutil client. For
GitHub, you can simply put the charts in the appropriate destination branch.</p>

<h3 id="add-new-charts-to-an-existing-repository">Add new charts to an existing repository</h3>

<p>Each time you want to add a new chart to your repository, you must regenerate
the index. The <code>helm repo index</code> command will completely rebuild the <code>index.yaml</code>
file from scratch, including only the charts that it finds locally.</p>

<p>However, you can use the <code>--merge</code> flag to incrementally add new charts to an
existing <code>index.yaml</code> file (a great option when working with a remote repository
like GCS). Run <code>helm repo index --help</code> to learn more,</p>

<p>Make sure that you upload both the revised <code>index.yaml</code> file and the chart. And
if you generated a provenance file, upload that too.</p>

<h3 id="share-your-charts-with-others">Share your charts with others</h3>

<p>When you&rsquo;re ready to share your charts, simply let someone know what the URL of
your repository is.</p>

<p>From there, they will add the repository to their helm client via the <code>helm
repo add [NAME] [URL]</code> command with any name they would like to use to
reference the repository.</p>

<pre><code class="language-console">$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>If the charts are backed by HTTP basic authentication, you can also supply the
username and password here:</p>

<pre><code class="language-console">$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com --username my-username --password my-password
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre>

<p><strong>Note:</strong> A repository will not be added if it does not contain a valid
<code>index.yaml</code>.</p>

<p>After that, your users will be able to search through your charts. After you&rsquo;ve updated
the repository, they can use the <code>helm repo update</code> command to get the latest
chart information.</p>

<p><em>Under the hood, the <code>helm repo add</code> and <code>helm repo update</code> commands are
fetching the index.yaml file and storing them in the
<code>$HELM_HOME/repository/cache/</code> directory. This is where the <code>helm search</code>
function finds information about charts.</em></p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="chart-repositories-frequently-asked-questions">Chart Repositories: Frequently Asked Questions</h1>

<p>This section tracks some of the more frequently encountered issues with using chart repositories.</p>

<p><strong>We&rsquo;d love your help</strong> making this document better. To add, correct, or remove
information, <a href="https://github.com/helm/helm/issues">file an issue</a> or
send us a pull request.</p>

<h2 id="fetching">Fetching</h2>

<p><strong>Q: Why do I get a <code>unsupported protocol scheme &quot;&quot;</code> error when trying to fetch a chart from my custom repo?</strong></p>

<p>A: (Helm &lt; 2.5.0) This is likely caused by you creating your chart repo index without specifying the <code>--url</code> flag.
Try recreating your <code>index.yaml</code> file with a command like <code>helm repo index --url http://my-repo/charts .</code>,
and then re-uploading it to your custom charts repo.</p>

<p>This behavior was changed in Helm 2.5.0.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="syncing-your-chart-repository">Syncing Your Chart Repository</h1>

<p><em>Note: This example is specifically for a Google Cloud Storage (GCS) bucket which serves a chart repository.</em></p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>Install the <a href="https://cloud.google.com/storage/docs/gsutil">gsutil</a> tool. <em>We rely heavily on the gsutil rsync functionality</em></li>
<li>Be sure to have access to the Helm binary</li>
<li>_Optional: We recommend you set <a href="https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#top_of_page">object versioning</a> on your GCS bucket in case you accidentally delete something._</li>
</ul>

<h2 id="set-up-a-local-chart-repository-directory">Set up a local chart repository directory</h2>

<p>Create a local directory like we did in <a href="./#developing_charts">the chart repository guide</a>, and place your packaged charts in that directory.</p>

<p>For example:</p>

<pre><code class="language-console">$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
</code></pre>

<h2 id="generate-an-updated-index-yaml">Generate an updated index.yaml</h2>

<p>Use Helm to generate an updated index.yaml file by passing in the directory path and the url of the remote repository to the <code>helm repo index</code> command like this:</p>

<pre><code class="language-console">$ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>This will generate an updated index.yaml file and place in the <code>fantastic-charts/</code> directory.</p>

<h2 id="sync-your-local-and-remote-chart-repositories">Sync your local and remote chart repositories</h2>

<p>Upload the contents of the directory to your GCS bucket by running <code>scripts/sync-repo.sh</code> and pass in the local directory name and the GCS bucket name.</p>

<p>For example:</p>

<pre><code class="language-console">$ pwd
/Users/funuser/go/src/github.com/helm/helm
$ scripts/sync-repo.sh fantastic-charts/ fantastic-charts
Getting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts
Verifying Prerequisites....
Thumbs up! Looks like you have gsutil. Let's continue.
Building synchronization state...
Starting synchronization
Would copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz
Would copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml
Are you sure you would like to continue with these changes?? [y/N]} y
Building synchronization state...
Starting synchronization
Copying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]...
Uploading   gs://fantastic-charts/alpine-0.1.0.tgz:              740 B/740 B
Copying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]...
Uploading   gs://fantastic-charts/index.yaml:                    347 B/347 B
Congratulations your remote chart repository now matches the contents of fantastic-charts/
</code></pre>

<h2 id="updating-your-chart-repository">Updating your chart repository</h2>

<p>You&rsquo;ll want to keep a local copy of the contents of your chart repository or use <code>gsutil rsync</code> to copy the contents of your remote chart repository to a local directory.</p>

<p>For example:</p>

<pre><code class="language-console">$ gsutil rsync -d -n gs://bucket-name local-dir/    # the -n flag does a dry run
Building synchronization state...
Starting synchronization
Would copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz
Would copy gs://bucket-name/index.yaml to file://local-dir/index.yaml

$ gsutil rsync -d gs://bucket-name local-dir/       # performs the copy actions
Building synchronization state...
Starting synchronization
Copying gs://bucket-name/alpine-0.1.0.tgz...
Downloading file://local-dir/alpine-0.1.0.tgz:                        740 B/740 B
Copying gs://bucket-name/index.yaml...
Downloading file://local-dir/index.yaml:                              346 B/346 B
</code></pre>

<p>Helpful Links:
* Documentation on <a href="https://cloud.google.com/storage/docs/gsutil/commands/rsync#description">gsutil rsync</a>
* <a href="./#developing_charts">The Chart Repository Guide</a>
* Documentation on <a href="https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#overview">object versioning and concurrency control</a> in Google Cloud Storage</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="the-chart-template-developer-s-guide">The Chart Template Developer&rsquo;s Guide</h1>

<p>This guide provides an introduction to Helm&rsquo;s chart templates, with emphasis on
the template language.</p>

<p>Templates generate manifest files, which are YAML-formatted resource descriptions
that Kubernetes can understand. We&rsquo;ll look at how templates are structured,
how they can be used, how to write Go templates, and how to debug your work.</p>

<p>This guide focuses on the following concepts:</p>

<ul>
<li>The Helm template language</li>
<li>Using values</li>
<li>Techniques for working with templates</li>
</ul>

<p>This guide is oriented toward learning the ins and outs of the Helm template language. Other guides provide introductory material, examples, and best practices.</p>

<h1 id="getting-started-with-a-chart-template">Getting Started with a Chart Template</h1>

<p>In this section of the guide, we&rsquo;ll create a chart and then add a first template. The chart we created here will be used throughout the rest of the guide.</p>

<p>To get going, let&rsquo;s take a brief look at a Helm chart.</p>

<h2 id="charts">Charts</h2>

<p>As described in the <a href="./#../charts">Charts Guide</a>, Helm charts are structured like
this:</p>

<pre><code>mychart/
  Chart.yaml
  values.yaml
  charts/
  templates/
  ...
</code></pre>

<p>The <code>templates/</code> directory is for template files. When Tiller evaluates a chart,
it will send all of the files in the <code>templates/</code> directory through the
template rendering engine. Tiller then collects the results of those templates
and sends them on to Kubernetes.</p>

<p>The <code>values.yaml</code> file is also important to templates. This file contains the
<em>default values</em> for a chart. These values may be overridden by users during
<code>helm install</code> or <code>helm upgrade</code>.</p>

<p>The <code>Chart.yaml</code> file contains a description of the chart. You can access it
from within a template. The <code>charts/</code> directory <em>may</em> contain other charts (which
we call <em>subcharts</em>). Later in this guide we will see how those work when it
comes to template rendering.</p>

<h2 id="a-starter-chart">A Starter Chart</h2>

<p>For this guide, we&rsquo;ll create a simple chart called <code>mychart</code>, and then we&rsquo;ll
create some templates inside of the chart.</p>

<pre><code class="language-console">$ helm create mychart
Creating mychart
</code></pre>

<p>From here on, we&rsquo;ll be working in the <code>mychart</code> directory.</p>

<h3 id="a-quick-glimpse-of-mychart-templates">A Quick Glimpse of <code>mychart/templates/</code></h3>

<p>If you take a look at the <code>mychart/templates/</code> directory, you&rsquo;ll notice a few files
already there.</p>

<ul>
<li><code>NOTES.txt</code>: The &ldquo;help text&rdquo; for your chart. This will be displayed to your users
when they run <code>helm install</code>.</li>
<li><code>deployment.yaml</code>: A basic manifest for creating a Kubernetes <a href="http://kubernetes.io/docs/user-guide/deployments/">deployment</a></li>
<li><code>service.yaml</code>: A basic manifest for creating a <a href="http://kubernetes.io/docs/user-guide/services/">service endpoint</a> for your deployment</li>
<li><code>_helpers.tpl</code>: A place to put template helpers that you can re-use throughout the chart</li>
</ul>

<p>And what we&rsquo;re going to do is&hellip; <em>remove them all!</em> That way we can work through our tutorial from scratch. We&rsquo;ll actually create our own <code>NOTES.txt</code> and <code>_helpers.tpl</code> as we go.</p>

<pre><code class="language-console">$ rm -rf mychart/templates/*.*
</code></pre>

<p>When you&rsquo;re writing production grade charts, having basic versions of these charts can be really useful. So in your day-to-day chart authoring, you probably won&rsquo;t want to remove them.</p>

<h2 id="a-first-template">A First Template</h2>

<p>The first template we are going to create will be a <code>ConfigMap</code>. In Kubernetes,
a ConfigMap is simply a container for storing configuration data. Other things,
like pods, can access the data in a ConfigMap.</p>

<p>Because ConfigMaps are basic resources, they make a great starting point for us.</p>

<p>Let&rsquo;s begin by creating a file called <code>mychart/templates/configmap.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: &quot;Hello World&quot;
</code></pre>

<p><strong>TIP:</strong> Template names do not follow a rigid naming pattern. However, we recommend
using the suffix <code>.yaml</code> for YAML files and <code>.tpl</code> for helpers.</p>

<p>The YAML file above is a bare-bones ConfigMap, having the minimal necessary fields.
In virtue of the fact that this file is in the <code>templates/</code> directory, it will
be sent through the template engine.</p>

<p>It is just fine to put a plain YAML file like this in the <code>templates/</code> directory.
When Tiller reads this template, it will simply send it to Kubernetes as-is.</p>

<p>With this simple template, we now have an installable chart. And we can install
it like this:</p>

<pre><code class="language-console">$ helm install ./mychart
NAME: full-coral
LAST DEPLOYED: Tue Nov  1 17:36:01 2016
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/ConfigMap
NAME                DATA      AGE
mychart-configmap   1         1m
</code></pre>

<p>In the output above, we can see that our ConfigMap was created. Using Helm, we
can retrieve the release and see the actual template that was loaded.</p>

<pre><code class="language-console">$ helm get manifest full-coral

---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mychart-configmap
data:
  myvalue: &quot;Hello World&quot;
</code></pre>

<p>The <code>helm get manifest</code> command takes a release name (<code>full-coral</code>) and prints
out all of the Kubernetes resources that were uploaded to the server. Each file
begins with <code>---</code> to indicate the start of a YAML document, and then is followed
by an automatically generated comment line that tells us what template file
generated this YAML document.</p>

<p>From there on, we can see that the YAML data is exactly what we put in our
<code>configmap.yaml</code> file.</p>

<p>Now we can delete our release: <code>helm delete full-coral</code>.</p>

<h3 id="adding-a-simple-template-call">Adding a Simple Template Call</h3>

<p>Hard-coding the <code>name:</code> into a resource is usually considered to be bad practice.
Names should be unique to a release. So we might want to generate a name field
by inserting the release name.</p>

<p><strong>TIP:</strong> The <code>name:</code> field is limited to 63 characters because of limitations to
the DNS system. For that reason, release names are limited to 53 characters.
Kubernetes 1.3 and earlier limited to only 24 characters (thus 14 character names).</p>

<p>Let&rsquo;s alter <code>configmap.yaml</code> accordingly.</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
</code></pre>

<p>The big change comes in the value of the <code>name:</code> field, which is now
<code>{{ .Release.Name }}-configmap</code>.</p>

<blockquote>
<p>A template directive is enclosed in <code>{{</code> and <code>}}</code> blocks.</p>
</blockquote>

<p>The template directive <code>{{ .Release.Name }}</code> injects the release name into the template. The values that are passed into a template can be thought of as <em>namespaced objects</em>, where a dot (<code>.</code>) separates each namespaced element.</p>

<p>The leading dot before <code>Release</code> indicates that we start with the top-most namespace for this scope (we&rsquo;ll talk about scope in a bit). So we could read <code>.Release.Name</code> as &ldquo;start at the top namespace, find the <code>Release</code> object, then look inside of it for an object called <code>Name</code>&rdquo;.</p>

<p>The <code>Release</code> object is one of the built-in objects for Helm, and we&rsquo;ll cover it in more depth later. But for now, it is sufficient to say that this will display the release name that Tiller assigns to our release.</p>

<p>Now when we install our resource, we&rsquo;ll immediately see the result of using this template directive:</p>

<pre><code class="language-console">$ helm install ./mychart
NAME: clunky-serval
LAST DEPLOYED: Tue Nov  1 17:45:37 2016
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/ConfigMap
NAME                      DATA      AGE
clunky-serval-configmap   1         1m
</code></pre>

<p>Note that in the <code>RESOURCES</code> section, the name we see there is <code>clunky-serval-configmap</code>
instead of <code>mychart-configmap</code>.</p>

<p>You can run <code>helm get manifest clunky-serval</code> to see the entire generated YAML.</p>

<p>At this point, we&rsquo;ve seen templates at their most basic: YAML files that have template directives embedded in <code>{{</code> and <code>}}</code>. In the next part, we&rsquo;ll take a deeper look into templates. But before moving on, there&rsquo;s one quick trick that can make building templates faster: When you want to test the template rendering, but not actually install anything, you can use <code>helm install --debug --dry-run ./mychart</code>. This will send the chart to the Tiller server, which will render the templates. But instead of installing the chart, it will return the rendered template to you so you can see the output:</p>

<pre><code class="language-console">$ helm install --debug --dry-run ./mychart
SERVER: &quot;localhost:44134&quot;
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   goodly-guppy
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: goodly-guppy-configmap
data:
  myvalue: &quot;Hello World&quot;

</code></pre>

<p>Using <code>--dry-run</code> will make it easier to test your code, but it won&rsquo;t ensure that Kubernetes itself will accept the templates you generate. It&rsquo;s best not to assume that your chart will install just because <code>--dry-run</code> works.</p>

<p>In the next few sections, we&rsquo;ll take the basic chart we defined here and explore the Helm template language in detail. And we&rsquo;ll get started with built-in objects.</p>

<h1 id="built-in-objects">Built-in Objects</h1>

<p>Objects are passed into a template from the template engine. And your code can pass objects around (we&rsquo;ll see examples when we look at the <code>with</code> and <code>range</code> statements). There are even a few ways to create new objects within your templates, like with the <code>tuple</code> function we&rsquo;ll see later.</p>

<p>Objects can be simple, and have just one value. Or they can contain other objects or functions. For example. the <code>Release</code> object contains several objects (like <code>Release.Name</code>) and the <code>Files</code> object has a few functions.</p>

<p>In the previous section, we use <code>{{.Release.Name}}</code> to insert the name of a release into a template. <code>Release</code> is one of the top-level objects that you can access in your templates.</p>

<ul>
<li><code>Release</code>: This object describes the release itself. It has several objects inside of it:

<ul>
<li><code>Release.Name</code>: The release name</li>
<li><code>Release.Time</code>: The time of the release</li>
<li><code>Release.Namespace</code>: The namespace to be released into (if the manifest doesn&rsquo;t override)</li>
<li><code>Release.Service</code>: The name of the releasing service (always <code>Tiller</code>).</li>
<li><code>Release.Revision</code>: The revision number of this release. It begins at 1 and is incremented for each <code>helm upgrade</code>.</li>
<li><code>Release.IsUpgrade</code>: This is set to <code>true</code> if the current operation is an upgrade or rollback.</li>
<li><code>Release.IsInstall</code>: This is set to <code>true</code> if the current operation is an install.</li>
</ul></li>
<li><code>Values</code>: Values passed into the template from the <code>values.yaml</code> file and from user-supplied files. By default, <code>Values</code> is empty.</li>
<li><code>Chart</code>: The contents of the <code>Chart.yaml</code> file. Any data in <code>Chart.yaml</code> will be accessible here. For example <code>{{.Chart.Name}}-{{.Chart.Version}}</code> will print out the <code>mychart-0.1.0</code>.

<ul>
<li>The available fields are listed in the <a href="https://github.com/helm/helm/blob/master/docs/charts.md#the-chartyaml-file">Charts Guide</a></li>
</ul></li>
<li><code>Files</code>: This provides access to all non-special files in a chart. While you cannot use it to access templates, you can use it to access other files in the chart. See the section <em>Accessing Files</em> for more.

<ul>
<li><code>Files.Get</code> is a function for getting a file by name (<code>.Files.Get config.ini</code>)</li>
<li><code>Files.GetBytes</code> is a function for getting the contents of a file as an array of bytes instead of as a string. This is useful for things like images.</li>
</ul></li>
<li><code>Capabilities</code>: This provides information about what capabilities the Kubernetes cluster supports.

<ul>
<li><code>Capabilities.APIVersions</code> is a set of versions.</li>
<li><code>Capabilities.APIVersions.Has $version</code> indicates whether a version (<code>batch/v1</code>) is enabled on the cluster.</li>
<li><code>Capabilities.KubeVersion</code> provides a way to look up the Kubernetes version. It has the following values: <code>Major</code>, <code>Minor</code>, <code>GitVersion</code>, <code>GitCommit</code>, <code>GitTreeState</code>, <code>BuildDate</code>, <code>GoVersion</code>, <code>Compiler</code>, and <code>Platform</code>.</li>
<li><code>Capabilities.TillerVersion</code> provides a way to look up the Tiller version. It has the following values: <code>SemVer</code>, <code>GitCommit</code>, and <code>GitTreeState</code>.</li>
</ul></li>
<li><code>Template</code>: Contains information about the current template that is being executed

<ul>
<li><code>Name</code>: A namespaced filepath to the current template (e.g. <code>mychart/templates/mytemplate.yaml</code>)</li>
<li><code>BasePath</code>: The namespaced path to the templates directory of the current chart (e.g. <code>mychart/templates</code>).</li>
</ul></li>
</ul>

<p>The values are available to any top-level template. As we will see later, this does not necessarily mean that they will be available <em>everywhere</em>.</p>

<p>The built-in values always begin with a capital letter. This is in keeping with Go&rsquo;s naming convention. When you create your own names, you are free to use a convention that suits your team. Some teams, like the <a href="https://github.com/helm/charts">Helm Charts</a> team, choose to use only initial lower case letters in order to distinguish local names from those built-in. In this guide, we follow that convention.</p>

<h1 id="values-files">Values Files</h1>

<p>In the previous section we looked at the built-in objects that Helm templates offer. One of the four built-in objects is <code>Values</code>. This object provides access to values passed into the chart. Its contents come from four sources:</p>

<ul>
<li>The <code>values.yaml</code> file in the chart</li>
<li>If this is a subchart, the <code>values.yaml</code> file of a parent chart</li>
<li>A values file is passed into <code>helm install</code> or <code>helm upgrade</code> with the <code>-f</code> flag (<code>helm install -f myvals.yaml ./mychart</code>)</li>
<li>Individual parameters passed with <code>--set</code> (such as <code>helm install --set foo=bar ./mychart</code>)</li>
</ul>

<p>The list above is in order of specificity: <code>values.yaml</code> is the default, which can be overridden by a parent chart&rsquo;s <code>values.yaml</code>, which can in turn be overridden by a user-supplied values file, which can in turn be overridden by <code>--set</code> parameters.</p>

<p>Values files are plain YAML files. Let&rsquo;s edit <code>mychart/values.yaml</code> and then edit our ConfigMap template.</p>

<p>Removing the defaults in <code>values.yaml</code>, we&rsquo;ll set just one parameter:</p>

<pre><code class="language-yaml">favoriteDrink: coffee
</code></pre>

<p>Now we can use this inside of a template:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favoriteDrink }}
</code></pre>

<p>Notice on the last line we access <code>favoriteDrink</code> as an attribute of <code>Values</code>: <code>{{ .Values.favoriteDrink}}</code>.</p>

<p>Let&rsquo;s see how this renders.</p>

<pre><code class="language-console">$ helm install --dry-run --debug ./mychart
SERVER: &quot;localhost:44134&quot;
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   geared-marsupi
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: geared-marsupi-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: coffee
</code></pre>

<p>Because <code>favoriteDrink</code> is set in the default <code>values.yaml</code> file to <code>coffee</code>, that&rsquo;s the value displayed in the template. We can easily override that by adding a <code>--set</code> flag in our call to <code>helm install</code>:</p>

<pre><code>helm install --dry-run --debug --set favoriteDrink=slurm ./mychart
SERVER: &quot;localhost:44134&quot;
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
NAME:   solid-vulture
TARGET NAMESPACE:   default
CHART:  mychart 0.1.0
MANIFEST:
---
# Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: solid-vulture-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: slurm
</code></pre>

<p>Since <code>--set</code> has a higher precedence than the default <code>values.yaml</code> file, our template generates <code>drink: slurm</code>.</p>

<p>Values files can contain more structured content, too. For example, we could create a <code>favorite</code> section in our <code>values.yaml</code> file, and then add several keys there:</p>

<pre><code class="language-yaml">favorite:
  drink: coffee
  food: pizza
</code></pre>

<p>Now we would have to modify the template slightly:</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink }}
  food: {{ .Values.favorite.food }}
</code></pre>

<p>While structuring data this way is possible, the recommendation is that you keep your values trees shallow, favoring flatness. When we look at assigning values to subcharts, we&rsquo;ll see how values are named using a tree structure.</p>

<h2 id="deleting-a-default-key">Deleting a default key</h2>

<p>If you need to delete a key from the default values, you may override the value of the key to be <code>null</code>, in which case Helm will remove the key from the overridden values merge.</p>

<p>For example, the stable Drupal chart allows configuring the liveness probe, in case you configure a custom image. Here are the default values:</p>

<pre><code class="language-yaml">livenessProbe:
  httpGet:
    path: /user/login
    port: http
  initialDelaySeconds: 120
</code></pre>

<p>If you try to override the livenessProbe handler to <code>exec</code> instead of <code>httpGet</code> using <code>--set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt]</code>, Helm will coalesce the default and overridden keys together, resulting in the following YAML:</p>

<pre><code class="language-yaml">livenessProbe:
  httpGet:
    path: /user/login
    port: http
  exec:
    command:
    - cat
    - docroot/CHANGELOG.txt
  initialDelaySeconds: 120
</code></pre>

<p>However, Kubernetes would then fail because you can not declare more than one livenessProbe handler. To overcome this, you may instruct Helm to delete the <code>livenessProbe.httpGet</code> by setting it to null:</p>

<pre><code class="language-sh">helm install stable/drupal --set image=my-registry/drupal:0.1.0 --set livenessProbe.exec.command=[cat,docroot/CHANGELOG.txt] --set livenessProbe.httpGet=null
</code></pre>

<p>At this point, we&rsquo;ve seen several built-in objects, and used them to inject information into a template. Now we will take a look at another aspect of the template engine: functions and pipelines.</p>

<h1 id="template-functions-and-pipelines">Template Functions and Pipelines</h1>

<p>So far, we&rsquo;ve seen how to place information into a template. But that information is placed into the template unmodified. Sometimes we want to transform the supplied data in a way that makes it more usable to us.</p>

<p>Let&rsquo;s start with a best practice: When injecting strings from the <code>.Values</code> object into the template, we ought to quote these strings. We can do that by calling the <code>quote</code> function in the template directive:</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ quote .Values.favorite.drink }}
  food: {{ quote .Values.favorite.food }}
</code></pre>

<p>Template functions follow the syntax <code>functionName arg1 arg2...</code>. In the snippet above, <code>quote .Values.favorite.drink</code> calls the <code>quote</code> function and passes it a single argument.</p>

<p>Helm has over 60 available functions. Some of them are defined by the <a href="https://godoc.org/text/template">Go template language</a> itself. Most of the others are part of the <a href="https://godoc.org/github.com/Masterminds/sprig">Sprig template library</a>. We&rsquo;ll see many of them as we progress through the examples.</p>

<blockquote>
<p>While we talk about the &ldquo;Helm template language&rdquo; as if it is Helm-specific, it is actually a combination of the Go template language, some extra functions, and a variety of wrappers to expose certain objects to the templates. Many resources on Go templates may be helpful as you learn about templating.</p>
</blockquote>

<h2 id="pipelines">Pipelines</h2>

<p>One of the powerful features of the template language is its concept of <em>pipelines</em>. Drawing on a concept from UNIX, pipelines are a tool for chaining together a series of template commands to compactly express a series of transformations. In other words, pipelines are an efficient way of getting several things done in sequence. Let&rsquo;s rewrite the above example using a pipeline.</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | quote }}
</code></pre>

<p>In this example, instead of calling <code>quote ARGUMENT</code>, we inverted the order. We &ldquo;sent&rdquo; the argument to the function using a pipeline (<code>|</code>): <code>.Values.favorite.drink | quote</code>. Using pipelines, we can chain several functions together:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
</code></pre>

<blockquote>
<p>Inverting the order is a common practice in templates. You will see <code>.val | quote</code> more often than <code>quote .val</code>. Either practice is fine.</p>
</blockquote>

<p>When evaluated, that template will produce this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: trendsetting-p-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
</code></pre>

<p>Note that our original <code>pizza</code> has now been transformed to <code>&quot;PIZZA&quot;</code>.</p>

<p>When pipelining arguments like this, the result of the first evaluation (<code>.Values.favorite.drink</code>) is sent as the <em>last argument to the function</em>. We can modify the drink example above to illustrate with a function that takes two arguments: <code>repeat COUNT STRING</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | repeat 5 | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
</code></pre>

<p>The <code>repeat</code> function will echo the given string the given number of times, so we will get this for output:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: melting-porcup-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffeecoffeecoffeecoffeecoffee&quot;
  food: &quot;PIZZA&quot;
</code></pre>

<h2 id="using-the-default-function">Using the <code>default</code> function</h2>

<p>One function frequently used in templates is the <code>default</code> function: <code>default DEFAULT_VALUE GIVEN_VALUE</code>. This function allows you to specify a default value inside of the template, in case the value is omitted. Let&rsquo;s use it to modify the drink example above:</p>

<pre><code class="language-yaml">drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
</code></pre>

<p>If we run this as normal, we&rsquo;ll get our <code>coffee</code>:</p>

<pre><code># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: virtuous-mink-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
</code></pre>

<p>Now, we will remove the favorite drink setting from <code>values.yaml</code>:</p>

<pre><code class="language-yaml">favorite:
  #drink: coffee
  food: pizza
</code></pre>

<p>Now re-running <code>helm install --dry-run --debug ./mychart</code> will produce this YAML:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fair-worm-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;tea&quot;
  food: &quot;PIZZA&quot;
</code></pre>

<p>In an actual chart, all static default values should live in the values.yaml, and should not be repeated using the <code>default</code> command (otherwise they would be redundant). However, the <code>default</code> command is perfect for computed values, which can not be declared inside values.yaml. For example:</p>

<pre><code class="language-yaml">drink: {{ .Values.favorite.drink | default (printf &quot;%s-tea&quot; (include &quot;fullname&quot; .)) }}
</code></pre>

<p>In some places, an <code>if</code> conditional guard may be better suited than <code>default</code>. We&rsquo;ll see those in the next section.</p>

<p>Template functions and pipelines are a powerful way to transform information and then insert it into your YAML. But sometimes it&rsquo;s necessary to add some template logic that is a little more sophisticated than just inserting a string. In the next section we will look at the control structures provided by the template language.</p>

<h2 id="operators-are-functions">Operators are functions</h2>

<p>For templates, the operators (<code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>and</code>, <code>or</code> and so on) are all implemented as functions. In pipelines, operations can be grouped with parentheses (<code>(</code>, and <code>)</code>).</p>

<p>Now we can turn from functions and pipelines to flow control with conditions, loops, and scope modifiers.</p>

<h1 id="flow-control">Flow Control</h1>

<p>Control structures (called &ldquo;actions&rdquo; in template parlance) provide you, the template author, with the ability to control the flow of a template&rsquo;s generation. Helm&rsquo;s template language provides the following control structures:</p>

<ul>
<li><code>if</code>/<code>else</code> for creating conditional blocks</li>
<li><code>with</code> to specify a scope</li>
<li><code>range</code>, which provides a &ldquo;for each&rdquo;-style loop</li>
</ul>

<p>In addition to these, it provides a few actions for declaring and using named template segments:</p>

<ul>
<li><code>define</code> declares a new named template inside of your template</li>
<li><code>template</code> imports a named template</li>
<li><code>block</code> declares a special kind of fillable template area</li>
</ul>

<p>In this section, we&rsquo;ll talk about <code>if</code>, <code>with</code>, and <code>range</code>. The others are covered in the &ldquo;Named Templates&rdquo; section later in this guide.</p>

<h2 id="if-else">If/Else</h2>

<p>The first control structure we&rsquo;ll look at is for conditionally including blocks of text in a template. This is the <code>if</code>/<code>else</code> block.</p>

<p>The basic structure for a conditional looks like this:</p>

<pre><code>{{ if PIPELINE }}
  # Do something
{{ else if OTHER PIPELINE }}
  # Do something else
{{ else }}
  # Default case
{{ end }}
</code></pre>

<p>Notice that we&rsquo;re now talking about <em>pipelines</em> instead of values. The reason for this is to make it clear that control structures can execute an entire pipeline, not just evaluate a value.</p>

<p>A pipeline is evaluated as <em>false</em> if the value is:</p>

<ul>
<li>a boolean false</li>
<li>a numeric zero</li>
<li>an empty string</li>
<li>a <code>nil</code> (empty or null)</li>
<li>an empty collection (<code>map</code>, <code>slice</code>, <code>tuple</code>, <code>dict</code>, <code>array</code>)</li>
</ul>

<p>In any other case, the condition is evaluated to <em>true</em> and the pipeline is executed.</p>

<p>Let&rsquo;s add a simple conditional to our ConfigMap. We&rsquo;ll add another setting if the drink is set to coffee:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{ if and (.Values.favorite.drink) (eq .Values.favorite.drink &quot;coffee&quot;) }}mug: true{{ end }}
</code></pre>

<p>Note that <code>.Values.favorite.drink</code> must be defined or else it will throw an error when comparing it to &ldquo;coffee&rdquo;. Since we commented out <code>drink: coffee</code> in our last example, the output should not include a <code>mug: true</code> flag. But if we add that line back into our <code>values.yaml</code> file, the output should look like this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
  mug: true
</code></pre>

<h2 id="controlling-whitespace">Controlling Whitespace</h2>

<p>While we&rsquo;re looking at conditionals, we should take a quick look at the way whitespace is controlled in templates. Let&rsquo;s take the previous example and format it to be a little easier to read:</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{if eq .Values.favorite.drink &quot;coffee&quot;}}
    mug: true
  {{end}}
</code></pre>

<p>Initially, this looks good. But if we run it through the template engine, we&rsquo;ll get an unfortunate result:</p>

<pre><code class="language-console">$ helm install --dry-run --debug ./mychart
SERVER: &quot;localhost:44134&quot;
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart
Error: YAML parse error on mychart/templates/configmap.yaml: error converting YAML to JSON: yaml: line 9: did not find expected key
</code></pre>

<p>What happened? We generated incorrect YAML because of the whitespacing above.</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eyewitness-elk-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
    mug: true
</code></pre>

<p><code>mug</code> is incorrectly indented. Let&rsquo;s simply out-dent that one line, and re-run:</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{if eq .Values.favorite.drink &quot;coffee&quot;}}
  mug: true
  {{end}}
</code></pre>

<p>When we sent that, we&rsquo;ll get YAML that is valid, but still looks a little funny:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: telling-chimp-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;

  mug: true

</code></pre>

<p>Notice that we received a few empty lines in our YAML. Why? When the template engine runs, it <em>removes</em> the contents inside of <code>{{</code> and <code>}}</code>, but it leaves the remaining whitespace exactly as is.</p>

<p>YAML ascribes meaning to whitespace, so managing the whitespace becomes pretty important. Fortunately, Helm templates have a few tools to help.</p>

<p>First, the curly brace syntax of template declarations can be modified with special characters to tell the template engine to chomp whitespace. <code>{{-</code> (with the dash and space added) indicates that whitespace should be chomped left, while <code>-}}</code> means whitespace to the right should be consumed. <em>Be careful! Newlines are whitespace!</em></p>

<blockquote>
<p>Make sure there is a space between the <code>-</code> and the rest of your directive. <code>{{- 3 }}</code> means &ldquo;trim left whitespace and print 3&rdquo; while <code>{{-3}}</code> means &ldquo;print -3&rdquo;.</p>
</blockquote>

<p>Using this syntax, we can modify our template to get rid of those new lines:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink &quot;coffee&quot;}}
  mug: true
  {{- end}}
</code></pre>

<p>Just for the sake of making this point clear, let&rsquo;s adjust the above, and substitute an <code>*</code> for each whitespace that will be deleted following this rule. an <code>*</code> at the end of the line indicates a newline character that would be removed</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: {{ .Values.favorite.drink | default &quot;tea&quot; | quote }}
  food: {{ .Values.favorite.food | upper | quote }}*
**{{- if eq .Values.favorite.drink &quot;coffee&quot;}}
  mug: true*
**{{- end}}

</code></pre>

<p>Keeping that in mind, we can run our template through Helm and see the result:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: clunky-cat-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
  mug: true
</code></pre>

<p>Be careful with the chomping modifiers. It is easy to accidentally do things like this:</p>

<pre><code class="language-yaml">  food: {{ .Values.favorite.food | upper | quote }}
  {{- if eq .Values.favorite.drink &quot;coffee&quot; -}}
  mug: true
  {{- end -}}

</code></pre>

<p>That will produce <code>food: &quot;PIZZA&quot;mug:true</code> because it consumed newlines on both sides.</p>

<blockquote>
<p>For the details on whitespace control in templates, see the <a href="https://godoc.org/text/template">Official Go template documentation</a></p>
</blockquote>

<p>Finally, sometimes it&rsquo;s easier to tell the template system how to indent for you instead of trying to master the spacing of template directives. For that reason, you may sometimes find it useful to use the <code>indent</code> function (<code>{{indent 2 &quot;mug:true&quot;}}</code>).</p>

<h2 id="modifying-scope-using-with">Modifying scope using <code>with</code></h2>

<p>The next control structure to look at is the <code>with</code> action. This controls variable scoping. Recall that <code>.</code> is a reference to <em>the current scope</em>. So <code>.Values</code> tells the template to find the <code>Values</code> object in the current scope.</p>

<p>The syntax for <code>with</code> is similar to a simple <code>if</code> statement:</p>

<pre><code>{{ with PIPELINE }}
  # restricted scope
{{ end }}
</code></pre>

<p>Scopes can be changed. <code>with</code> can allow you to set the current scope (<code>.</code>) to a particular object. For example, we&rsquo;ve been working with <code>.Values.favorites</code>. Let&rsquo;s rewrite our ConfigMap to alter the <code>.</code> scope to point to <code>.Values.favorites</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
</code></pre>

<p>(Note that we removed the <code>if</code> conditional from the previous exercise)</p>

<p>Notice that now we can reference <code>.drink</code> and <code>.food</code> without qualifying them. That is because the <code>with</code> statement sets <code>.</code> to point to <code>.Values.favorite</code>. The <code>.</code> is reset to its previous scope after <code>{{ end }}</code>.</p>

<p>But here&rsquo;s a note of caution! Inside of the restricted scope, you will not be able to access the other objects from the parent scope. This, for example, will fail:</p>

<pre><code class="language-yaml">  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
</code></pre>

<p>It will produce an error because <code>Release.Name</code> is not inside of the restricted scope for <code>.</code>. However, if we swap the last two lines, all will work as expected because the scope is reset after <code>{{end}}</code>.</p>

<pre><code class="language-yaml">  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  release: {{ .Release.Name }}
</code></pre>

<p>After looking at <code>range</code>, we will take a look at template variables, which offers one solution to the scoping issue above.</p>

<h2 id="looping-with-the-range-action">Looping with the <code>range</code> action</h2>

<p>Many programming languages have support for looping using <code>for</code> loops, <code>foreach</code> loops, or similar functional mechanisms. In Helm&rsquo;s template language, the way to iterate through a collection is to use the <code>range</code> operator.</p>

<p>To start, let&rsquo;s add a list of pizza toppings to our <code>values.yaml</code> file:</p>

<pre><code class="language-yaml">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions
</code></pre>

<p>Now we have a list (called a <code>slice</code> in templates) of <code>pizzaToppings</code>. We can modify our template to print this list into our ConfigMap:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  {{- end }}
  toppings: |-
    {{- range .Values.pizzaToppings }}
    - {{ . | title | quote }}
    {{- end }}

</code></pre>

<p>Let&rsquo;s take a closer look at the <code>toppings:</code> list. The <code>range</code> function will &ldquo;range over&rdquo; (iterate through) the <code>pizzaToppings</code> list. But now something interesting happens. Just like <code>with</code> sets the scope of <code>.</code>, so does a <code>range</code> operator. Each time through the loop, <code>.</code> is set to the current pizza topping. That is, the first time, <code>.</code> is set to <code>mushrooms</code>. The second iteration it is set to <code>cheese</code>, and so on.</p>

<p>We can send the value of <code>.</code> directly down a pipeline, so when we do <code>{{ . | title | quote }}</code>, it sends <code>.</code> to <code>title</code> (title case function) and then to <code>quote</code>. If we run this template, the output will be:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-dragonfly-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
  toppings: |-
    - &quot;Mushrooms&quot;
    - &quot;Cheese&quot;
    - &quot;Peppers&quot;
    - &quot;Onions&quot;
</code></pre>

<p>Now, in this example we&rsquo;ve done something tricky. The <code>toppings: |-</code> line is declaring a multi-line string. So our list of toppings is actually not a YAML list. It&rsquo;s a big string. Why would we do this? Because the data in ConfigMaps <code>data</code> is composed of key/value pairs, where both the key and the value are simple strings. To understand why this is the case, take a look at the <a href="http://kubernetes.io/docs/user-guide/configmap/">Kubernetes ConfigMap docs</a>. For us, though, this detail doesn&rsquo;t matter much.</p>

<blockquote>
<p>The <code>|-</code> marker in YAML takes a multi-line string. This can be a useful technique for embedding big blocks of data inside of your manifests, as exemplified here.</p>
</blockquote>

<p>Sometimes it&rsquo;s useful to be able to quickly make a list inside of your template, and then iterate over that list. Helm templates have a function to make this easy: <code>tuple</code>. In computer science, a tuple is a list-like collection of fixed size, but with arbitrary data types. This roughly conveys the way a <code>tuple</code> is used.</p>

<pre><code class="language-yaml">  sizes: |-
    {{- range tuple &quot;small&quot; &quot;medium&quot; &quot;large&quot; }}
    - {{ . }}
    {{- end }}
</code></pre>

<p>The above will produce this:</p>

<pre><code class="language-yaml">  sizes: |-
    - small
    - medium
    - large
</code></pre>

<p>In addition to lists and tuples, <code>range</code> can be used to iterate over collections that have a key and a value (like a <code>map</code> or <code>dict</code>). We&rsquo;ll see how to do that in the next section when we introduce template variables.</p>

<h1 id="variables">Variables</h1>

<p>With functions, pipelines, objects, and control structures under our belts, we can turn to one of the more basic ideas in many programming languages: variables. In templates, they are less frequently used. But we will see how to use them to simplify code, and to make better use of <code>with</code> and <code>range</code>.</p>

<p>In an earlier example, we saw that this code will fail:</p>

<pre><code class="language-yaml">  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  release: {{ .Release.Name }}
  {{- end }}
</code></pre>

<p><code>Release.Name</code> is not inside of the scope that&rsquo;s restricted in the <code>with</code> block. One way to work around scoping issues is to assign objects to variables that can be accessed without respect to the present scope.</p>

<p>In Helm templates, a variable is a named reference to another object. It follows the form <code>$name</code>. Variables are assigned with a special assignment operator: <code>:=</code>. We can rewrite the above to use a variable for <code>Release.Name</code>.</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  {{- $relname := .Release.Name -}}
  {{- with .Values.favorite }}
  drink: {{ .drink | default &quot;tea&quot; | quote }}
  food: {{ .food | upper | quote }}
  release: {{ $relname }}
  {{- end }}
</code></pre>

<p>Notice that before we start the <code>with</code> block, we assign <code>$relname := .Release.Name</code>. Now inside of the <code>with</code> block, the <code>$relname</code> variable still points to the release name.</p>

<p>Running that will produce this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: viable-badger-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;PIZZA&quot;
  release: viable-badger
</code></pre>

<p>Variables are particularly useful in <code>range</code> loops. They can be used on list-like objects to capture both the index and the value:</p>

<pre><code class="language-yaml">  toppings: |-
    {{- range $index, $topping := .Values.pizzaToppings }}
      {{ $index }}: {{ $topping }}
    {{- end }}

</code></pre>

<p>Note that <code>range</code> comes first, then the variables, then the assignment operator, then the list. This will assign the integer index (starting from zero) to <code>$index</code> and the value to <code>$topping</code>. Running it will produce:</p>

<pre><code class="language-yaml">  toppings: |-
      0: mushrooms
      1: cheese
      2: peppers
      3: onions
</code></pre>

<p>For data structures that have both a key and a value, we can use <code>range</code> to get both. For example, we can loop through <code>.Values.favorite</code> like this:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  myvalue: &quot;Hello World&quot;
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end}}
</code></pre>

<p>Now on the first iteration, <code>$key</code> will be <code>drink</code> and <code>$val</code> will be <code>coffee</code>, and on the second, <code>$key</code> will be <code>food</code> and <code>$val</code> will be <code>pizza</code>. Running the above will generate this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: eager-rabbit-configmap
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
</code></pre>

<p>Variables are normally not &ldquo;global&rdquo;. They are scoped to the block in which they are declared. Earlier, we assigned <code>$relname</code> in the top level of the template. That variable will be in scope for the entire template. But in our last example, <code>$key</code> and <code>$val</code> will only be in scope inside of the <code>{{range...}}{{end}}</code> block.</p>

<p>However, there is one variable that is always global - <code>$</code> - this
variable will always point to the root context.  This can be very
useful when you are looping in a range need to know the chart&rsquo;s release
name.</p>

<p>An example illustrating this:</p>

<pre><code class="language-yaml">{{- range .Values.tlsSecrets }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ .name }}
  labels:
    # Many helm templates would use `.` below, but that will not work, 
    # however `$` will work here 
    app.kubernetes.io/name: {{ template &quot;fullname&quot; $ }}
    # I cannot reference .Chart.Name, but I can do $.Chart.Name
    helm.sh/chart: &quot;{{ $.Chart.Name }}-{{ $.Chart.Version }}&quot;
    app.kubernetes.io/instance: &quot;{{ $.Release.Name }}&quot;
    app.kubernetes.io/managed-by: &quot;{{ $.Release.Service }}&quot;
type: kubernetes.io/tls
data:
  tls.crt: {{ .certificate }}
  tls.key: {{ .key }}
---
{{- end }}
</code></pre>

<p>So far we have looked at just one template declared in just one file. But one of the powerful features of the Helm template language is its ability to declare multiple templates and use them together. We&rsquo;ll turn to that in the next section.</p>

<h1 id="named-templates">Named Templates</h1>

<p>It is time to move beyond one template, and begin to create others. In this section, we will see how to define <em>named templates</em> in one file, and then use them elsewhere. A <em>named template</em> (sometimes called a <em>partial</em> or a <em>subtemplate</em>) is simply a template defined inside of a file, and given a name. We&rsquo;ll see two ways to create them, and a few different ways to use them.</p>

<p>In the &ldquo;Flow Control&rdquo; section we introduced three actions for declaring and managing templates: <code>define</code>, <code>template</code>, and <code>block</code>. In this section, we&rsquo;ll cover those three actions, and also introduce a special-purpose <code>include</code> function that works similarly to the <code>template</code> action.</p>

<p>An important detail to keep in mind when naming templates: <strong>template names are global</strong>. If you declare two templates with the same name, whichever one is loaded last will be the one used. Because templates in subcharts are compiled together with top-level templates, you should be careful to name your templates with <em>chart-specific names</em>.</p>

<p>One popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define &quot;mychart.labels&quot; }}</code>. By using the specific chart name as a prefix we can avoid any conflicts that may arise due to two different charts that implement templates of the same name.</p>

<h2 id="partials-and-files">Partials and <code>_</code> files</h2>

<p>So far, we&rsquo;ve used one file, and that one file has contained a single template. But Helm&rsquo;s template language allows you to create named embedded templates, that can be accessed by name elsewhere.</p>

<p>Before we get to the nuts-and-bolts of writing those templates, there is file naming convention that deserves mention:</p>

<ul>
<li>Most files in <code>templates/</code> are treated as if they contain Kubernetes manifests</li>
<li>The <code>NOTES.txt</code> is one exception</li>
<li>But files whose name begins with an underscore (<code>_</code>) are assumed to <em>not</em> have a manifest inside. These files are not rendered to Kubernetes object definitions, but are available everywhere within other chart templates for use.</li>
</ul>

<p>These files are used to store partials and helpers. In fact, when we first created <code>mychart</code>, we saw a file called <code>_helpers.tpl</code>. That file is the default location for template partials.</p>

<h2 id="declaring-and-using-templates-with-define-and-template">Declaring and using templates with <code>define</code> and <code>template</code></h2>

<p>The <code>define</code> action allows us to create a named template inside of a template file. Its syntax goes like this:</p>

<pre><code class="language-yaml">{{ define &quot;MY.NAME&quot; }}
  # body of template here
{{ end }}
</code></pre>

<p>For example, we can define a template to encapsulate a Kubernetes block of labels:</p>

<pre><code class="language-yaml">{{- define &quot;mychart.labels&quot; }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
</code></pre>

<p>Now we can embed this template inside of our existing ConfigMap, and then include it with the <code>template</code> action:</p>

<pre><code class="language-yaml">{{- define &quot;mychart.labels&quot; }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template &quot;mychart.labels&quot; }}
data:
  myvalue: &quot;Hello World&quot;
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
</code></pre>

<p>When the template engine reads this file, it will store away the reference to <code>mychart.labels</code> until <code>template &quot;mychart.labels&quot;</code> is called. Then it will render that template inline. So the result will look like this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: running-panda-configmap
  labels:
    generator: helm
    date: 2016-11-02
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
</code></pre>

<p>Conventionally, Helm charts put these templates inside of a partials file, usually <code>_helpers.tpl</code>. Let&rsquo;s move this function there:</p>

<pre><code class="language-yaml">{{/* Generate basic labels */}}
{{- define &quot;mychart.labels&quot; }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
{{- end }}
</code></pre>

<p>By convention, <code>define</code> functions should have a simple documentation block (<code>{{/* ... */}}</code>) describing what they do.</p>

<p>Even though this definition is in <code>_helpers.tpl</code>, it can still be accessed in <code>configmap.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template &quot;mychart.labels&quot; }}
data:
  myvalue: &quot;Hello World&quot;
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
</code></pre>

<p>As mentioned above, <strong>template names are global</strong>. As a result of this, if two templates are declared with the same name the last occurrence will be the one that is used. Since templates in subcharts are compiled together with top-level templates, it is best to name your templates with <em>chart specific names</em>. A popular naming convention is to prefix each defined template with the name of the chart: <code>{{ define &quot;mychart.labels&quot; }}</code>.</p>

<h2 id="setting-the-scope-of-a-template">Setting the scope of a template</h2>

<p>In the template we defined above, we did not use any objects. We just used functions. Let&rsquo;s modify our defined template to include the chart name and chart version:</p>

<pre><code class="language-yaml">{{/* Generate basic labels */}}
{{- define &quot;mychart.labels&quot; }}
  labels:
    generator: helm
    date: {{ now | htmlDate }}
    chart: {{ .Chart.Name }}
    version: {{ .Chart.Version }}
{{- end }}
</code></pre>

<p>If we render this, the result will not be what we expect:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: moldy-jaguar-configmap
  labels:
    generator: helm
    date: 2016-11-02
    chart:
    version:
</code></pre>

<p>What happened to the name and version? They weren&rsquo;t in the scope for our defined template. When a named template (created with <code>define</code>) is rendered, it will receive the scope passed in by the <code>template</code> call. In our example, we included the template like this:</p>

<pre><code class="language-gotpl">{{- template &quot;mychart.labels&quot; }}
</code></pre>

<p>No scope was passed in, so within the template we cannot access anything in <code>.</code>. This is easy enough to fix, though. We simply pass a scope to the template:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  {{- template &quot;mychart.labels&quot; . }}
</code></pre>

<p>Note that we pass <code>.</code> at the end of the <code>template</code> call. We could just as easily pass <code>.Values</code> or <code>.Values.favorite</code> or whatever scope we want. But what we want is the top-level scope.</p>

<p>Now when we execute this template with <code>helm install --dry-run --debug ./mychart</code>, we get this:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: plinking-anaco-configmap
  labels:
    generator: helm
    date: 2016-11-02
    chart: mychart
    version: 0.1.0
</code></pre>

<p>Now <code>{{ .Chart.Name }}</code> resolves to <code>mychart</code>, and <code>{{ .Chart.Version }}</code> resolves to <code>0.1.0</code>.</p>

<h2 id="the-include-function">The <code>include</code> function</h2>

<p>Say we&rsquo;ve defined a simple template that looks like this:</p>

<pre><code class="language-yaml">{{- define &quot;mychart.app&quot; -}}
app_name: {{ .Chart.Name }}
app_version: &quot;{{ .Chart.Version }}+{{ .Release.Time.Seconds }}&quot;
{{- end -}}
</code></pre>

<p>Now say I want to insert this both into the <code>labels:</code> section of my template, and also the <code>data:</code> section:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
    {{ template &quot;mychart.app&quot; .}}
data:
  myvalue: &quot;Hello World&quot;
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
{{ template &quot;mychart.app&quot; . }}
</code></pre>

<p>The output will not be what we expect:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: measly-whippet-configmap
  labels:
    app_name: mychart
app_version: &quot;0.1.0+1478129847&quot;
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
  app_name: mychart
app_version: &quot;0.1.0+1478129847&quot;
</code></pre>

<p>Note that the indentation on <code>app_version</code> is wrong in both places. Why? Because the template that is substituted in has the text aligned to the right. Because <code>template</code> is an action, and not a function, there is no way to pass the output of a <code>template</code> call to other functions; the data is simply inserted inline.</p>

<p>To work around this case, Helm provides an alternative to <code>template</code> that will import the contents of a template into the present pipeline where it can be passed along to other functions in the pipeline.</p>

<p>Here&rsquo;s the example above, corrected to use <code>nindent</code> to indent the <code>mychart_app</code> template correctly:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  labels:
    {{- include &quot;mychart.app&quot; . | nindent 4 }}
data:
  myvalue: &quot;Hello World&quot;
  {{- range $key, $val := .Values.favorite }}
  {{ $key }}: {{ $val | quote }}
  {{- end }}
  {{- include &quot;mychart.app&quot; . | nindent 2 }}
</code></pre>

<p>Now the produced YAML is correctly indented for each section:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: edgy-mole-configmap
  labels:
    app_name: mychart
    app_version: &quot;0.1.0+1478129987&quot;
data:
  myvalue: &quot;Hello World&quot;
  drink: &quot;coffee&quot;
  food: &quot;pizza&quot;
  app_name: mychart
  app_version: &quot;0.1.0+1478129987&quot;
</code></pre>

<blockquote>
<p>It is considered preferable to use <code>include</code> over <code>template</code> in Helm templates simply so that the output formatting can be handled better for YAML documents.</p>
</blockquote>

<p>Sometimes we want to import content, but not as templates. That is, we want to import files verbatim. We can achieve this by accessing files through the <code>.Files</code> object described in the next section.</p>

<h1 id="accessing-files-inside-templates">Accessing Files Inside Templates</h1>

<p>In the previous section we looked at several ways to create and access named templates. This makes it easy to import one template from within another template. But sometimes it is desirable to import a <em>file that is not a template</em> and inject its contents without sending the contents through the template renderer.</p>

<p>Helm provides access to files through the <code>.Files</code> object. Before we get going with the template examples, though, there are a few things to note about how this works:</p>

<ul>
<li>It is okay to add extra files to your Helm chart. These files will be bundled and sent to Tiller. Be careful, though. Charts must be smaller than 1M because of the storage limitations of Kubernetes objects.</li>
<li>Some files cannot be accessed through the <code>.Files</code> object, usually for security reasons.

<ul>
<li>Files in <code>templates/</code> cannot be accessed.</li>
<li>Files excluded using <code>.helmignore</code> cannot be accessed.</li>
</ul></li>
<li>Charts do not preserve UNIX mode information, so file-level permissions will have no impact on the availability of a file when it comes to the <code>.Files</code> object.</li>
</ul>

<!-- (see https://github.com/jonschlinkert/markdown-toc) -->

<!-- toc -->

<ul>
<li><a href="#basic-example">Basic example</a></li>
<li><a href="#path-helpers">Path helpers</a></li>
<li><a href="#glob-patterns">Glob patterns</a></li>
<li><a href="#configmap-and-secrets-utility-functions">ConfigMap and Secrets utility functions</a></li>
<li><a href="#encoding">Encoding</a></li>
<li><a href="#lines">Lines</a></li>
</ul>

<!-- tocstop -->

<h2 id="basic-example">Basic example</h2>

<p>With those caveats behind, let&rsquo;s write a template that reads three files into our ConfigMap. To get started, we will add three files to the chart, putting all three directly inside of the <code>mychart/</code> directory.</p>

<p><code>config1.toml</code>:</p>

<pre><code class="language-toml">message = Hello from config 1
</code></pre>

<p><code>config2.toml</code>:</p>

<pre><code class="language-toml">message = This is config 2
</code></pre>

<p><code>config3.toml</code>:</p>

<pre><code class="language-toml">message = Goodbye from config 3
</code></pre>

<p>Each of these is a simple TOML file (think old-school Windows INI files). We know the names of these files, so we can use a <code>range</code> function to loop through them and inject their contents into our ConfigMap.</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  {{- $files := .Files }}
  {{- range tuple &quot;config1.toml&quot; &quot;config2.toml&quot; &quot;config3.toml&quot; }}
  {{ . }}: |-
    {{ $files.Get . }}
  {{- end }}
</code></pre>

<p>This config map uses several of the techniques discussed in previous sections. For example, we create a <code>$files</code> variable to hold a reference to the <code>.Files</code> object. We also use the <code>tuple</code> function to create a list of files that we loop through. Then we print each file name (<code>{{.}}: |-</code>) followed by the contents of the file <code>{{ $files.Get . }}</code>.</p>

<p>Running this template will produce a single ConfigMap with the contents of all three files:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: quieting-giraf-configmap
data:
  config1.toml: |-
    message = Hello from config 1

  config2.toml: |-
    message = This is config 2

  config3.toml: |-
    message = Goodbye from config 3
</code></pre>

<h2 id="path-helpers">Path helpers</h2>

<p>When working with files, it can be very useful to perform some standard
operations on the file paths themselves. To help with this, Helm imports many of
the functions from Go&rsquo;s <a href="https://golang.org/pkg/path/">path</a> package for your
use. They are all accessible with the same names as in the Go package, but
with a lowercase first letter. For example, <code>Base</code> becomes <code>base</code>, etc.</p>

<p>The imported functions are:</p>

<ul>
<li>Base</li>
<li>Dir</li>
<li>Ext</li>
<li>IsAbs</li>
<li>Clean</li>
</ul>

<h2 id="glob-patterns">Glob patterns</h2>

<p>As your chart grows, you may find you have a greater need to organize your
files more, and so we provide a <code>Files.Glob(pattern string)</code> method to assist
in extracting certain files with all the flexibility of <a href="https://godoc.org/github.com/gobwas/glob">glob patterns</a>.</p>

<p><code>.Glob</code> returns a <code>Files</code> type, so you may call any of the <code>Files</code> methods on
the returned object.</p>

<p>For example, imagine the directory structure:</p>

<pre><code class="language-txt">foo/:
  foo.txt foo.yaml

bar/:
  bar.go bar.conf baz.yaml
</code></pre>

<p>You have multiple options with Globs:</p>

<pre><code class="language-yaml">{{ $root := . }}
{{ range $path, $bytes := .Files.Glob &quot;**.yaml&quot; }}
{{ $path }}: |-
{{ $root.Files.Get $path }}
{{ end }}
</code></pre>

<p>Or</p>

<pre><code class="language-yaml">{{ range $path, $bytes := .Files.Glob &quot;foo/*&quot; }}
{{ base $path }}: '{{ $root.Files.Get $path | b64enc }}'
{{ end }}
</code></pre>

<h2 id="configmap-and-secrets-utility-functions">ConfigMap and Secrets utility functions</h2>

<p>(Not present in version 2.0.2 or prior)</p>

<p>It is very common to want to place file content into both configmaps and
secrets, for mounting into your pods at run time. To help with this, we provide a
couple utility methods on the <code>Files</code> type.</p>

<p>For further organization, it is especially useful to use these methods in
conjunction with the <code>Glob</code> method.</p>

<p>Given the directory structure from the <a href="#glob-patterns">Glob</a> example above:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: conf
data:
  {{- (.Files.Glob &quot;foo/*&quot;).AsConfig | nindent 2 }}
---
apiVersion: v1
kind: Secret
metadata:
  name: very-secret
type: Opaque
data:
  {{- (.Files.Glob &quot;bar/*&quot;).AsSecrets | nindent 2 }}
</code></pre>

<h2 id="encoding">Encoding</h2>

<p>You can import a file and have the template base-64 encode it to ensure successful transmission:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: {{ .Release.Name }}-secret
type: Opaque
data:
  token: |-
    {{ .Files.Get &quot;config1.toml&quot; | b64enc }}
</code></pre>

<p>The above will take the same <code>config1.toml</code> file we used before and encode it:</p>

<pre><code class="language-yaml"># Source: mychart/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: lucky-turkey-secret
type: Opaque
data:
  token: |-
    bWVzc2FnZSA9IEhlbGxvIGZyb20gY29uZmlnIDEK
</code></pre>

<h2 id="lines">Lines</h2>

<p>Sometimes it is desirable to access each line of a file in your template. We
provide a convenient <code>Lines</code> method for this.</p>

<pre><code class="language-yaml">data:
  some-file.txt: {{ range .Files.Lines &quot;foo/bar.txt&quot; }}
    {{ . }}{{ end }}
</code></pre>

<p>Currently, there is no way to pass files external to the chart during <code>helm install</code>. So if you are asking users to supply data, it must be loaded using <code>helm install -f</code> or <code>helm install --set</code>.</p>

<p>This discussion wraps up our dive into the tools and techniques for writing Helm templates. In the next section we will see how you can use one special file, <code>templates/NOTES.txt</code>, to send post-installation instructions to the users of your chart.</p>

<h1 id="creating-a-notes-txt-file">Creating a NOTES.txt File</h1>

<p>In this section we are going to look at Helm&rsquo;s tool for providing instructions to your chart users. At the end of a <code>chart install</code> or <code>chart upgrade</code>, Helm can print out a block of helpful information for users. This information is highly customizable using templates.</p>

<p>To add installation notes to your chart, simply create a <code>templates/NOTES.txt</code> file. This file is plain text, but it is processed like as a template, and has all the normal template functions and objects available.</p>

<p>Let&rsquo;s create a simple <code>NOTES.txt</code> file:</p>

<pre><code>Thank you for installing {{ .Chart.Name }}.

Your release is named {{ .Release.Name }}.

To learn more about the release, try:

  $ helm status {{ .Release.Name }}
  $ helm get {{ .Release.Name }}

</code></pre>

<p>Now if we run <code>helm install ./mychart</code> we will see this message at the bottom:</p>

<pre><code>RESOURCES:
==&gt; v1/Secret
NAME                   TYPE      DATA      AGE
rude-cardinal-secret   Opaque    1         0s

==&gt; v1/ConfigMap
NAME                      DATA      AGE
rude-cardinal-configmap   3         0s


NOTES:
Thank you for installing mychart.

Your release is named rude-cardinal.

To learn more about the release, try:

  $ helm status rude-cardinal
  $ helm get rude-cardinal
</code></pre>

<p>Using <code>NOTES.txt</code> this way is a great way to give your users detailed information about how to use their newly installed chart. Creating a <code>NOTES.txt</code> file is strongly recommended, though it is not required.</p>

<h1 id="subcharts-and-global-values">Subcharts and Global Values</h1>

<p>To this point we have been working only with one chart. But charts can have dependencies, called <em>subcharts</em>, that also have their own values and templates. In this section we will create a subchart and see the different ways we can access values from within templates.</p>

<p>Before we dive into the code, there are a few important details to learn about subcharts.</p>

<ol>
<li>A subchart is considered &ldquo;stand-alone&rdquo;, which means a subchart can never explicitly depend on its parent chart.</li>
<li>For that reason, a subchart cannot access the values of its parent.</li>
<li>A parent chart can override values for subcharts.</li>
<li>Helm has a concept of <em>global values</em> that can be accessed by all charts.</li>
</ol>

<p>As we walk through the examples in this section, many of these concepts will become clearer.</p>

<h2 id="creating-a-subchart">Creating a Subchart</h2>

<p>For these exercises, we&rsquo;ll start with the <code>mychart/</code> chart we created at the beginning of this guide, and we&rsquo;ll add a new chart inside of it.</p>

<pre><code class="language-console">$ cd mychart/charts
$ helm create mysubchart
Creating mysubchart
$ rm -rf mysubchart/templates/*.*
</code></pre>

<p>Notice that just as before, we deleted all of the base templates so that we can start from scratch. In this guide, we are focused on how templates work, not on managing dependencies. But the <a href="./#../charts">Charts Guide</a> has more information on how subcharts work.</p>

<h2 id="adding-values-and-a-template-to-the-subchart">Adding Values and a Template to the Subchart</h2>

<p>Next, let&rsquo;s create a simple template and values file for our <code>mysubchart</code> chart. There should already be a <code>values.yaml</code> in <code>mychart/charts/mysubchart</code>. We&rsquo;ll set it up like this:</p>

<pre><code class="language-yaml">dessert: cake
</code></pre>

<p>Next, we&rsquo;ll create a new ConfigMap template in <code>mychart/charts/mysubchart/templates/configmap.yaml</code>:</p>

<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
</code></pre>

<p>Because every subchart is a <em>stand-alone chart</em>, we can test <code>mysubchart</code> on its own:</p>

<pre><code class="language-console">$ helm install --dry-run --debug mychart/charts/mysubchart
SERVER: &quot;localhost:44134&quot;
CHART PATH: /Users/mattbutcher/Code/Go/src/k8s.io/helm/_scratch/mychart/charts/mysubchart
NAME:   newbie-elk
TARGET NAMESPACE:   default
CHART:  mysubchart 0.1.0
MANIFEST:
---
# Source: mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: newbie-elk-cfgmap2
data:
  dessert: cake
</code></pre>

<h2 id="overriding-values-from-a-parent-chart">Overriding Values from a Parent Chart</h2>

<p>Our original chart, <code>mychart</code> is now the <em>parent</em> chart of <code>mysubchart</code>. This relationship is based entirely on the fact that <code>mysubchart</code> is within <code>mychart/charts</code>.</p>

<p>Because <code>mychart</code> is a parent, we can specify configuration in <code>mychart</code> and have that configuration pushed into <code>mysubchart</code>. For example, we can modify <code>mychart/values.yaml</code> like this:</p>

<pre><code class="language-yaml">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream
</code></pre>

<p>Note the last two lines. Any directives inside of the <code>mysubchart</code> section will be sent to the <code>mysubchart</code> chart. So if we run <code>helm install --dry-run --debug mychart</code>, one of the things we will see is the <code>mysubchart</code> ConfigMap:</p>

<pre><code class="language-yaml"># Source: mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: unhinged-bee-cfgmap2
data:
  dessert: ice cream
</code></pre>

<p>The value at the top level has now overridden the value of the subchart.</p>

<p>There&rsquo;s an important detail to notice here. We didn&rsquo;t change the template of <code>mychart/charts/mysubchart/templates/configmap.yaml</code> to point to <code>.Values.mysubchart.dessert</code>. From that template&rsquo;s perspective, the value is still located at <code>.Values.dessert</code>. As the template engine passes values along, it sets the scope. So for the <code>mysubchart</code> templates, only values specifically for <code>mysubchart</code> will be available in <code>.Values</code>.</p>

<p>Sometimes, though, you do want certain values to be available to all of the templates. This is accomplished using global chart values.</p>

<h2 id="global-chart-values">Global Chart Values</h2>

<p>Global values are values that can be accessed from any chart or subchart by exactly the same name. Globals require explicit declaration. You can&rsquo;t use an existing non-global as if it were a global.</p>

<p>The Values data type has a reserved section called <code>Values.global</code> where global values can be set. Let&rsquo;s set one in our <code>mychart/values.yaml</code> file.</p>

<pre><code class="language-yaml">favorite:
  drink: coffee
  food: pizza
pizzaToppings:
  - mushrooms
  - cheese
  - peppers
  - onions

mysubchart:
  dessert: ice cream

global:
  salad: caesar
</code></pre>

<p>Because of the way globals work, both <code>mychart/templates/configmap.yaml</code> and <code>mychart/charts/mysubchart/templates/configmap.yaml</code> should be able to access that value as <code>{{ .Values.global.salad}}</code>.</p>

<p><code>mychart/templates/configmap.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
data:
  salad: {{ .Values.global.salad }}
</code></pre>

<p><code>mychart/charts/mysubchart/templates/configmap.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-cfgmap2
data:
  dessert: {{ .Values.dessert }}
  salad: {{ .Values.global.salad }}
</code></pre>

<p>Now if we run a dry run install, we&rsquo;ll see the same value in both outputs:</p>

<pre><code class="language-yaml"># Source: mychart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-configmap
data:
  salad: caesar

---
# Source: mychart/charts/mysubchart/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: silly-snake-cfgmap2
data:
  dessert: ice cream
  salad: caesar
</code></pre>

<p>Globals are useful for passing information like this, though it does take some planning to make sure the right templates are configured to use globals.</p>

<h2 id="sharing-templates-with-subcharts">Sharing Templates with Subcharts</h2>

<p>Parent charts and subcharts can share templates. Any defined block in any chart is
available to other charts.</p>

<p>For example, we can define a simple template like this:</p>

<pre><code class="language-yaml">{{- define &quot;labels&quot; }}from: mychart{{ end }}
</code></pre>

<p>Recall how the labels on templates are <em>globally shared</em>. Thus, the <code>labels</code> chart
can be included from any other chart.</p>

<p>While chart developers have a choice between <code>include</code> and <code>template</code>, one advantage
of using <code>include</code> is that <code>include</code> can dynamically reference templates:</p>

<pre><code class="language-yaml">{{ include $mytemplate }}
</code></pre>

<p>The above will dereference <code>$mytemplate</code>. The <code>template</code> function, in contrast,
will only accept a string literal.</p>

<h2 id="avoid-using-blocks">Avoid Using Blocks</h2>

<p>The Go template language provides a <code>block</code> keyword that allows developers to provide
a default implementation which is overridden later. In Helm charts, blocks are not
the best tool for overriding because if multiple implementations of the same block
are provided, the one selected is unpredictable.</p>

<p>The suggestion is to instead use <code>include</code>.</p>

<h1 id="debugging-templates">Debugging Templates</h1>

<p>Debugging templates can be tricky simply because the templates are rendered on the Tiller server, not the Helm client. And then the rendered templates are sent to the Kubernetes API server, which may reject the YAML files for reasons other than formatting.</p>

<p>There are a few commands that can help you debug.</p>

<ul>
<li><code>helm lint</code> is your go-to tool for verifying that your chart follows best practices</li>
<li><code>helm install --dry-run --debug</code>: We&rsquo;ve seen this trick already. It&rsquo;s a great way to have the server render your templates, then return the resulting manifest file.</li>
<li><code>helm get manifest</code>: This is a good way to see what templates are installed on the server.</li>
</ul>

<p>When your YAML is failing to parse, but you want to see what is generated, one
easy way to retrieve the YAML is to comment out the problem section in the template,
and then re-run <code>helm install --dry-run --debug</code>:</p>

<pre><code class="language-YAML">apiVersion: v1
# some: problem section
# {{ .Values.foo | quote }}
</code></pre>

<p>The above will be rendered and returned with the comments intact:</p>

<pre><code class="language-YAML">apiVersion: v1
# some: problem section
#  &quot;bar&quot;
</code></pre>

<p>This provides a quick way of viewing the generated content without YAML parse
errors blocking.</p>

<h1 id="wrapping-up">Wrapping Up</h1>

<p>This guide is intended to give you, the chart developer, a strong understanding of how to use Helm&rsquo;s template language. The guide focuses on the technical aspects of template development.</p>

<p>But there are many things this guide has not covered when it comes to the practical day-to-day development of charts. Here are some useful pointers to other documentation that will help you as you create new charts:</p>

<ul>
<li>The <a href="https://github.com/helm/charts">Helm Charts project</a> is an indispensable source of charts. That project is also sets the standard for best practices in chart development.</li>
<li>The Kubernetes <a href="http://kubernetes.io/docs/user-guide/">User&rsquo;s Guide</a> provides detailed examples of the various resource kinds that you can use, from ConfigMaps and Secrets to DaemonSets and Deployments.</li>
<li>The Helm <a href="./#../charts">Charts Guide</a> explains the workflow of using charts.</li>
<li>The Helm <a href="./#../charts_hooks">Chart Hooks Guide</a> explains how to create lifecycle hooks.</li>
<li>The Helm <a href="./#../chart-development-tips-and-tricks">Charts Tips and Tricks</a> article provides some useful tips for writing charts.</li>
<li>The <a href="https://github.com/Masterminds/sprig">Sprig documentation</a> documents more than sixty of the template functions.</li>
<li>The <a href="https://godoc.org/text/template">Go template docs</a> explain the template syntax in detail.</li>
<li>The <a href="https://github.com/databus23/schelm">Schelm tool</a> is a nice helper utility for debugging charts.</li>
</ul>

<p>Sometimes it&rsquo;s easier to ask a few questions and get answers from experienced developers. The best place to do this is in the <a href="https://kubernetes.slack.com">Kubernetes Slack</a> Helm channels:</p>

<ul>
<li><a href="https://kubernetes.slack.com/messages/helm-users">#helm-users</a></li>
<li><a href="https://kubernetes.slack.com/messages/helm-dev">#helm-dev</a></li>
<li><a href="https://kubernetes.slack.com/messages/charts">#charts</a></li>
</ul>

<p>Finally, if you find errors or omissions in this document, want to suggest some new content, or would like to contribute, visit <a href="https://github.com/helm/helm">The Helm Project</a>.</p>

<h1 id="yaml-techniques">YAML Techniques</h1>

<p>Most of this guide has been focused on writing the template language. Here,
we&rsquo;ll look at the YAML format. YAML has some useful features that we, as
template authors, can use to make our templates less error prone and easier
to read.</p>

<h2 id="scalars-and-collections">Scalars and Collections</h2>

<p>According to the <a href="http://yaml.org/spec/1.2/spec.html">YAML spec</a>, there are two
types of collections, and many scalar types.</p>

<p>The two types of collections are maps and sequences:</p>

<pre><code class="language-yaml">map:
  one: 1
  two: 2
  three: 3

sequence:
  - one
  - two
  - three
</code></pre>

<p>Scalar values are individual values (as opposed to collections)</p>

<h3 id="scalar-types-in-yaml">Scalar Types in YAML</h3>

<p>In Helm&rsquo;s dialect of YAML, the scalar data type of a value is determined by a
complex set of rules, including the Kubernetes schema for resource definitions.
But when inferring types, the following rules tend to hold true.</p>

<p>If an integer or float is an unquoted bare word, it is typically treated as
a numeric type:</p>

<pre><code class="language-yaml">count: 1
size: 2.34
</code></pre>

<p>But if they are quoted, they are treated as strings:</p>

<pre><code class="language-yaml">count: &quot;1&quot; # &lt;-- string, not int
size: '2.34' # &lt;-- string, not float
</code></pre>

<p>The same is true of booleans:</p>

<pre><code class="language-yaml">isGood: true   # bool
answer: &quot;true&quot; # string
</code></pre>

<p>The word for an empty value is <code>null</code> (not <code>nil</code>).</p>

<p>Note that <code>port: &quot;80&quot;</code> is valid YAML, and will pass through both the
template engine and the YAML parser, but will fail if Kubernetes expects
<code>port</code> to be an integer.</p>

<p>In some cases, you can force a particular type inference using YAML node tags:</p>

<pre><code class="language-yaml">coffee: &quot;yes, please&quot;
age: !!str 21
port: !!int &quot;80&quot;
</code></pre>

<p>In the above, <code>!!str</code> tells the parser that <code>age</code> is a string, even if it looks
like an int. And <code>port</code> is treated as an int, even though it is quoted.</p>

<h2 id="strings-in-yaml">Strings in YAML</h2>

<p>Much of the data that we place in YAML documents are strings. YAML has more than
one way to represent a string. This section explains the ways and demonstrates
how to use some of them.</p>

<p>There are three &ldquo;inline&rdquo; ways of declaring a string:</p>

<pre><code class="language-yaml">way1: bare words
way2: &quot;double-quoted strings&quot;
way3: 'single-quoted strings'
</code></pre>

<p>All inline styles must be on one line.</p>

<ul>
<li>Bare words are unquoted, and are not escaped. For this reason, you have to
be careful what characters you use.</li>
<li>Double-quoted strings can have specific characters escaped with <code>\</code>. For
example <code>&quot;\&quot;Hello\&quot;, she said&quot;</code>. You can escape line breaks with <code>\n</code>.</li>
<li>Single-quoted strings are &ldquo;literal&rdquo; strings, and do not use the <code>\</code> to
escape characters. The only escape sequence is <code>''</code>, which is decoded as
a single <code>'</code>.</li>
</ul>

<p>In addition to the one-line strings, you can declare multi-line strings:</p>

<pre><code class="language-yaml">coffee: |
  Latte
  Cappuccino
  Espresso
</code></pre>

<p>The above will treat the value of <code>coffee</code> as a single string equivalent to
<code>Latte\nCappuccino\nEspresso\n</code>.</p>

<p>Note that the first line after the <code>|</code> must be correctly indented. So we could
break the example above by doing this:</p>

<pre><code class="language-yaml">coffee: |
         Latte
  Cappuccino
  Espresso

</code></pre>

<p>Because <code>Latte</code> is incorrectly indented, we&rsquo;d get an error like this:</p>

<pre><code>Error parsing file: error converting YAML to JSON: yaml: line 7: did not find expected key
</code></pre>

<p>In templates, it is sometimes safer to put a fake &ldquo;first line&rdquo; of content in a
multi-line document just for protection from the above error:</p>

<pre><code class="language-yaml">coffee: |
  # Commented first line
         Latte
  Cappuccino
  Espresso

</code></pre>

<p>Note that whatever that first line is, it will be preserved in the output of the
string. So if you are, for example, using this technique to inject a file&rsquo;s contents
into a ConfigMap, the comment should be of the type expected by whatever is
reading that entry.</p>

<h3 id="controlling-spaces-in-multi-line-strings">Controlling Spaces in Multi-line Strings</h3>

<p>In the example above, we used <code>|</code> to indicate a multi-line string. But notice
that the content of our string was followed with a trailing <code>\n</code>. If we want
the YAML processor to strip off the trailing newline, we can add a <code>-</code> after the
<code>|</code>:</p>

<pre><code class="language-yaml">coffee: |-
  Latte
  Cappuccino
  Espresso
</code></pre>

<p>Now the <code>coffee</code> value will be: <code>Latte\nCappuccino\nEspresso</code> (with no trailing
<code>\n</code>).</p>

<p>Other times, we might want all trailing whitespace to be preserved. We can do
this with the <code>|+</code> notation:</p>

<pre><code class="language-yaml">coffee: |+
  Latte
  Cappuccino
  Espresso


another: value
</code></pre>

<p>Now the value of <code>coffee</code> will be <code>Latte\nCappuccino\nEspresso\n\n\n</code>.</p>

<p>Indentation inside of a text block is preserved, and results in the preservation
of line breaks, too:</p>

<pre><code>coffee: |-
  Latte
    12 oz
    16 oz
  Cappuccino
  Espresso
</code></pre>

<p>In the above case, <code>coffee</code> will be <code>Latte\n  12 oz\n  16 oz\nCappuccino\nEspresso</code>.</p>

<h3 id="indenting-and-templates">Indenting and Templates</h3>

<p>When writing templates, you may find yourself wanting to inject the contents of
a file into the template. As we saw in previous chapters, there are two ways
of doing this:</p>

<ul>
<li>Use <code>{{ .Files.Get &quot;FILENAME&quot; }}</code> to get the contents of a file in the chart.</li>
<li>Use <code>{{ include &quot;TEMPLATE&quot; . }}</code> to render a template and then place its
contents into the chart.</li>
</ul>

<p>When inserting files into YAML, it&rsquo;s good to understand the multi-line rules above.
Often times, the easiest way to insert a static file is to do something like
this:</p>

<pre><code class="language-yaml">myfile: |
{{ .Files.Get &quot;myfile.txt&quot; | indent 2 }}
</code></pre>

<p>Note how we do the indentation above: <code>indent 2</code> tells the template engine to
indent every line in &ldquo;myfile.txt&rdquo; with two spaces. Note that we do not indent
that template line. That&rsquo;s because if we did, the file content of the first line
would be indented twice.</p>

<h3 id="folded-multi-line-strings">Folded Multi-line Strings</h3>

<p>Sometimes you want to represent a string in your YAML with multiple lines, but
want it to be treated as one long line when it is interpreted. This is called
&ldquo;folding&rdquo;. To declare a folded block, use <code>&gt;</code> instead of <code>|</code>:</p>

<pre><code class="language-yaml">coffee: &gt;
  Latte
  Cappuccino
  Espresso


</code></pre>

<p>The value of <code>coffee</code> above will be <code>Latte Cappuccino Espresso\n</code>. Note that all
but the last line feed will be converted to spaces. You can combine the whitespace
controls with the folded text marker, so <code>&gt;-</code> will replace or trim all newlines.</p>

<p>Note that in the folded syntax, indenting text will cause lines to be preserved.</p>

<pre><code class="language-yaml">coffee: &gt;-
  Latte
    12 oz
    16 oz
  Cappuccino
  Espresso
</code></pre>

<p>The above will produce <code>Latte\n  12 oz\n  16 oz\nCappuccino Espresso</code>. Note that
both the spacing and the newlines are still there.</p>

<h2 id="embedding-multiple-documents-in-one-file">Embedding Multiple Documents in One File</h2>

<p>It is possible to place more than one YAML documents into a single file. This
is done by prefixing a new document with <code>---</code> and ending the document with
<code>...</code></p>

<pre><code class="language-yaml">
---
document:1
...
---
document: 2
...
</code></pre>

<p>In many cases, either the <code>---</code> or the <code>...</code> may be omitted.</p>

<p>Some files in Helm cannot contain more than one doc. If, for example, more
than one document is provided inside of a <code>values.yaml</code> file, only the first
will be used.</p>

<p>Template files, however, may have more than one document. When this happens,
the file (and all of its documents) is treated as one object during
template rendering. But then the resulting YAML is split into multiple
documents before it is fed to Kubernetes.</p>

<p>We recommend only using multiple documents per file when it is absolutely
necessary. Having multiple documents in a file can be difficult to debug.</p>

<h2 id="yaml-is-a-superset-of-json">YAML is a Superset of JSON</h2>

<p>Because YAML is a superset of JSON, any valid JSON document <em>should</em> be valid
YAML.</p>

<pre><code class="language-json">{
  &quot;coffee&quot;: &quot;yes, please&quot;,
  &quot;coffees&quot;: [
    &quot;Latte&quot;, &quot;Cappuccino&quot;, &quot;Espresso&quot;
  ]
}
</code></pre>

<p>The above is another way of representing this:</p>

<pre><code class="language-yaml">coffee: yes, please
coffees:
- Latte
- Cappuccino
- Espresso
</code></pre>

<p>And the two can be mixed (with care):</p>

<pre><code class="language-yaml">coffee: &quot;yes, please&quot;
coffees: [ &quot;Latte&quot;, &quot;Cappuccino&quot;, &quot;Espresso&quot;]
</code></pre>

<p>All three of these should parse into the same internal representation.</p>

<p>While this means that files such as <code>values.yaml</code> may contain JSON data, Helm
does not treat the file extension <code>.json</code> as a valid suffix.</p>

<h2 id="yaml-anchors">YAML Anchors</h2>

<p>The YAML spec provides a way to store a reference to a value, and later
refer to that value by reference. YAML refers to this as &ldquo;anchoring&rdquo;:</p>

<pre><code class="language-yaml">coffee: &quot;yes, please&quot;
favorite: &amp;favoriteCoffee &quot;Cappucino&quot;
coffees:
  - Latte
  - *favoriteCoffee
  - Espresso
</code></pre>

<p>In the above, <code>&amp;favoriteCoffee</code> sets a reference to <code>Cappuccino</code>. Later, that
reference is used as <code>*favoriteCoffee</code>. So <code>coffees</code> becomes
<code>Latte, Cappuccino, Espresso</code>.</p>

<p>While there are a few cases where anchors are useful, there is one aspect of
them that can cause subtle bugs: The first time the YAML is consumed, the
reference is expanded and then discarded.</p>

<p>So if we were to decode and then re-encode the example above, the resulting
YAML would be:</p>

<pre><code class="language-YAML">coffee: yes, please
favorite: Cappucino
coffees:
- Latte
- Cappucino
- Espresso
</code></pre>

<p>Because Helm and Kubernetes often read, modify, and then rewrite YAML files,
the anchors will be lost.</p>

<h1 id="appendix-go-data-types-and-templates">Appendix: Go Data Types and Templates</h1>

<p>The Helm template language is implemented in the strongly typed Go programming language. For that reason, variables in templates are <em>typed</em>. For the most part, variables will be exposed as one of the following types:</p>

<ul>
<li>string: A string of text</li>
<li>bool: a <code>true</code> or <code>false</code></li>
<li>int: An integer value (there are also 8, 16, 32, and 64 bit signed and unsigned variants of this)</li>
<li>float64: a 64-bit floating point value (there are also 8, 16, and 32 bit varieties of this)</li>
<li>a byte slice (<code>[]byte</code>), often used to hold (potentially) binary data</li>
<li>struct: an object with properties and methods</li>
<li>a slice (indexed list) of one of the previous types</li>
<li>a string-keyed map (<code>map[string]interface{}</code>) where the value is one of the previous types</li>
</ul>

<p>There are many other types in Go, and sometimes you will have to convert between them in your templates. The easiest way to debug an object&rsquo;s type is to pass it through <code>printf &quot;%t&quot;</code> in a template, which will print the type. Also see the <code>typeOf</code> and <code>kindOf</code> functions.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="chart-tests">Chart Tests</h1>

<p>A chart contains a number of Kubernetes resources and components that work together. As a chart author, you may want to write some tests that validate that your chart works as expected when it is installed. These tests also help the chart consumer understand what your chart is supposed to do.</p>

<p>A <strong>test</strong> in a helm chart lives under the <code>templates/</code> directory and is a pod definition that specifies a container with a given command to run. The container should exit successfully (exit 0) for a test to be considered a success. The pod definition must contain one of the helm test hook annotations: <code>helm.sh/hook: test-success</code> or <code>helm.sh/hook: test-failure</code>.</p>

<p>Example tests:
- Validate that your configuration from the values.yaml file was properly injected.
  - Make sure your username and password work correctly
  - Make sure an incorrect username and password does not work
- Assert that your services are up and correctly loadbalanced.
- etc.</p>

<p>You can run the pre-defined tests in Helm on a release using the command <code>helm test &lt;RELEASE_NAME&gt;</code>. For a chart consumer, this is a great way to sanity check that their release of a chart (or application) works as expected.</p>

<h2 id="a-breakdown-of-the-helm-test-hooks">A Breakdown of the Helm Test Hooks</h2>

<p>In Helm, there are two test hooks: <code>test-success</code> and <code>test-failure</code></p>

<p><code>test-success</code> indicates that test pod should complete successfully. In other words, the containers in the pod should exit 0.
<code>test-failure</code> is a way to assert that a test pod should not complete successfully. If the containers in the pod do not exit 0, that indicates success.</p>

<h2 id="example-test">Example Test</h2>

<p>Here is an example of a helm test pod definition in an example wordpress chart. The test verifies the access and login to the mariadb database:</p>

<pre><code>wordpress/
  Chart.yaml
  README.md
  values.yaml
  charts/
  templates/
  templates/tests/test-mariadb-connection.yaml
</code></pre>

<p>In <code>wordpress/templates/tests/test-mariadb-connection.yaml</code>:</p>

<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &quot;{{ .Release.Name }}-credentials-test&quot;
  annotations:
    &quot;helm.sh/hook&quot;: test-success
spec:
  containers:
  - name: {{ .Release.Name }}-credentials-test
    image: {{ .Values.image }}
    env:
      - name: MARIADB_HOST
        value: {{ template &quot;mariadb.fullname&quot; . }}
      - name: MARIADB_PORT
        value: &quot;3306&quot;
      - name: WORDPRESS_DATABASE_NAME
        value: {{ default &quot;&quot; .Values.mariadb.mariadbDatabase | quote }}
      - name: WORDPRESS_DATABASE_USER
        value: {{ default &quot;&quot; .Values.mariadb.mariadbUser | quote }}
      - name: WORDPRESS_DATABASE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: {{ template &quot;mariadb.fullname&quot; . }}
            key: mariadb-password
    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;mysql --host=$MARIADB_HOST --port=$MARIADB_PORT --user=$WORDPRESS_DATABASE_USER --password=$WORDPRESS_DATABASE_PASSWORD&quot;]
  restartPolicy: Never
</code></pre>

<h2 id="steps-to-run-a-test-suite-on-a-release">Steps to Run a Test Suite on a Release</h2>

<ol>
<li><p><code>$ helm install wordpress</code></p>

<pre><code>NAME:   quirky-walrus
LAST DEPLOYED: Mon Feb 13 13:50:43 2017
NAMESPACE: default
STATUS: DEPLOYED
</code></pre></li>

<li><p><code>$ helm test quirky-walrus</code></p>

<pre><code>RUNNING: quirky-walrus-credentials-test
SUCCESS: quirky-walrus-credentials-test
</code></pre></li>
</ol>

<h2 id="notes">Notes</h2>

<ul>
<li>You can define as many tests as you would like in a single yaml file or spread across several yaml files in the <code>templates/</code> directory</li>
<li>You are welcome to nest your test suite under a <code>tests/</code> directory like <code>&lt;chart-name&gt;/templates/tests/</code> for more isolation</li>
</ul>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="charts">Charts</h1>

<p>Helm uses a packaging format called <em>charts</em>. A chart is a collection of files
that describe a related set of Kubernetes resources. A single chart
might be used to deploy something simple, like a memcached pod, or
something complex, like a full web app stack with HTTP servers,
databases, caches, and so on.</p>

<p>Charts are created as files laid out in a particular directory tree,
then they can be packaged into versioned archives to be deployed.</p>

<p>This document explains the chart format, and provides basic guidance for
building charts with Helm.</p>

<h2 id="the-chart-file-structure">The Chart File Structure</h2>

<p>A chart is organized as a collection of files inside of a directory. The
directory name is the name of the chart (without versioning information). Thus,
a chart describing WordPress would be stored in the <code>wordpress/</code> directory.</p>

<p>Inside of this directory, Helm will expect a structure that matches this:</p>

<pre><code>wordpress/
  Chart.yaml          # A YAML file containing information about the chart
  LICENSE             # OPTIONAL: A plain text file containing the license for the chart
  README.md           # OPTIONAL: A human-readable README file
  requirements.yaml   # OPTIONAL: A YAML file listing dependencies for the chart
  values.yaml         # The default configuration values for this chart
  charts/             # A directory containing any charts upon which this chart depends.
  templates/          # A directory of templates that, when combined with values,
                      # will generate valid Kubernetes manifest files.
  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes
</code></pre>

<p>Helm reserves use of the <code>charts/</code> and <code>templates/</code> directories, and of
the listed file names. Other files will be left as they are.</p>

<h2 id="the-chart-yaml-file">The Chart.yaml File</h2>

<p>The <code>Chart.yaml</code> file is required for a chart. It contains the following fields:</p>

<pre><code class="language-yaml">apiVersion: The chart API version, always &quot;v1&quot; (required)
name: The name of the chart (required)
version: A SemVer 2 version (required)
kubeVersion: A SemVer range of compatible Kubernetes versions (optional)
description: A single-sentence description of this project (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this project's home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
maintainers: # (optional)
  - name: The maintainer's name (required for each maintainer)
    email: The maintainer's email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
engine: gotpl # The name of the template engine (optional, defaults to gotpl)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). This needn't be SemVer.
deprecated: Whether this chart is deprecated (optional, boolean)
tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range: &quot;&gt;2.0.0&quot; (optional)
</code></pre>

<p>If you are familiar with the <code>Chart.yaml</code> file format for Helm Classic, you will
notice that fields specifying dependencies have been removed. That is because
the new Chart format expresses dependencies using the <code>charts/</code> directory.</p>

<p>Other fields will be silently ignored.</p>

<h3 id="charts-and-versioning">Charts and Versioning</h3>

<p>Every chart must have a version number. A version must follow the
<a href="http://semver.org/">SemVer 2</a> standard. Unlike Helm Classic, Kubernetes
Helm uses version numbers as release markers. Packages in repositories
are identified by name plus version.</p>

<p>For example, an <code>nginx</code> chart whose version field is set to <code>version:
1.2.3</code> will be named:</p>

<pre><code>nginx-1.2.3.tgz
</code></pre>

<p>More complex SemVer 2 names are also supported, such as
<code>version: 1.2.3-alpha.1+ef365</code>. But non-SemVer names are explicitly
disallowed by the system.</p>

<p><strong>NOTE:</strong> Whereas Helm Classic and Deployment Manager were both
very GitHub oriented when it came to charts, Kubernetes Helm does not
rely upon or require GitHub or even Git. Consequently, it does not use
Git SHAs for versioning at all.</p>

<p>The <code>version</code> field inside of the <code>Chart.yaml</code> is used by many of the
Helm tools, including the CLI and the Tiller server. When generating a
package, the <code>helm package</code> command will use the version that it finds
in the <code>Chart.yaml</code> as a token in the package name. The system assumes
that the version number in the chart package name matches the version number in
the <code>Chart.yaml</code>. Failure to meet this assumption will cause an error.</p>

<h3 id="the-appversion-field">The appVersion field</h3>

<p>Note that the <code>appVersion</code> field is not related to the <code>version</code> field. It is
a way of specifying the version of the application. For example, the <code>drupal</code>
chart may have an <code>appVersion: 8.2.1</code>, indicating that the version of Drupal
included in the chart (by default) is <code>8.2.1</code>. This field is informational, and
has no impact on chart version calculations.</p>

<h3 id="deprecating-charts">Deprecating Charts</h3>

<p>When managing charts in a Chart Repository, it is sometimes necessary to
deprecate a chart. The optional <code>deprecated</code> field in <code>Chart.yaml</code> can be used
to mark a chart as deprecated. If the <strong>latest</strong> version of a chart in the
repository is marked as deprecated, then the chart as a whole is considered to
be deprecated. The chart name can later be reused by publishing a newer version
that is not marked as deprecated. The workflow for deprecating charts, as
followed by the <a href="https://github.com/helm/charts">helm/charts</a>
project is:</p>

<ul>
<li>Update chart&rsquo;s <code>Chart.yaml</code> to mark the chart as deprecated, bumping the version</li>
<li>Release the new chart version in the Chart Repository</li>
<li>Remove the chart from the source repository (e.g. git)</li>
</ul>

<h2 id="chart-license-readme-and-notes">Chart LICENSE, README and NOTES</h2>

<p>Charts can also contain files that describe the installation, configuration, usage and license of a
chart.</p>

<p>A LICENSE is a plain text file containing the <a href="https://en.wikipedia.org/wiki/Software_license">license</a>
for the chart. The chart can contain a license as it may have programming logic in the templates and
would therefore not be configuration only. There can also be separate license(s) for the application
installed by the chart, if required.</p>

<p>A README for a chart should be formatted in Markdown (README.md), and should generally
contain:</p>

<ul>
<li>A description of the application or service the chart provides</li>
<li>Any prerequisites or requirements to run the chart</li>
<li>Descriptions of options in <code>values.yaml</code> and default values</li>
<li>Any other information that may be relevant to the installation or configuration of the chart</li>
</ul>

<p>The chart can also contain a short plain text <code>templates/NOTES.txt</code> file that will be printed out
after installation, and when viewing the status of a release. This file is evaluated as a
<a href="#templates-and-values">template</a>, and can be used to display usage notes, next steps, or any other
information relevant to a release of the chart. For example, instructions could be provided for
connecting to a database, or accessing a web UI. Since this file is printed to STDOUT when running
<code>helm install</code> or <code>helm status</code>, it is recommended to keep the content brief and point to the README
for greater detail.</p>

<h2 id="chart-dependencies">Chart Dependencies</h2>

<p>In Helm, one chart may depend on any number of other charts.
These dependencies can be dynamically linked through the <code>requirements.yaml</code>
file or brought in to the <code>charts/</code> directory and managed manually.</p>

<p>Although manually managing your dependencies has a few advantages some teams need,
the preferred method of declaring dependencies is by using a
<code>requirements.yaml</code> file inside of your chart.</p>

<p><strong>Note:</strong> The <code>dependencies:</code> section of the <code>Chart.yaml</code> from Helm
Classic has been completely removed.</p>

<h3 id="managing-dependencies-with-requirements-yaml">Managing Dependencies with <code>requirements.yaml</code></h3>

<p>A <code>requirements.yaml</code> file is a simple file for listing your
dependencies.</p>

<pre><code class="language-yaml">dependencies:
  - name: apache
    version: 1.2.3
    repository: http://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: http://another.example.com/charts
</code></pre>

<ul>
<li>The <code>name</code> field is the name of the chart you want.</li>
<li>The <code>version</code> field is the version of the chart you want.</li>
<li>The <code>repository</code> field is the full URL to the chart repository. Note
that you must also use <code>helm repo add</code> to add that repo locally.</li>
</ul>

<p>Once you have a dependencies file, you can run <code>helm dependency update</code>
and it will use your dependency file to download all the specified
charts into your <code>charts/</code> directory for you.</p>

<pre><code class="language-console">$ helm dep up foochart
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &quot;local&quot; chart repository
...Successfully got an update from the &quot;stable&quot; chart repository
...Successfully got an update from the &quot;example&quot; chart repository
...Successfully got an update from the &quot;another&quot; chart repository
Update Complete. Happy Helming!
Saving 2 charts
Downloading apache from repo http://example.com/charts
Downloading mysql from repo http://another.example.com/charts
</code></pre>

<p>When <code>helm dependency update</code> retrieves charts, it will store them as
chart archives in the <code>charts/</code> directory. So for the example above, one
would expect to see the following files in the charts directory:</p>

<pre><code>charts/
  apache-1.2.3.tgz
  mysql-3.2.1.tgz
</code></pre>

<p>Managing charts with <code>requirements.yaml</code> is a good way to easily keep
charts updated, and also share requirements information throughout a
team.</p>

<h4 id="alias-field-in-requirements-yaml">Alias field in requirements.yaml</h4>

<p>In addition to the other fields above, each requirements entry may contain
the optional field <code>alias</code>.</p>

<p>Adding an alias for a dependency chart would put
a chart in dependencies using alias as name of new dependency.</p>

<p>One can use <code>alias</code> in cases where they need to access a chart
with other name(s).</p>

<pre><code class="language-yaml"># parentchart/requirements.yaml
dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-1
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-2
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
</code></pre>

<p>In the above example we will get 3 dependencies in all for <code>parentchart</code></p>

<pre><code>subchart
new-subchart-1
new-subchart-2
</code></pre>

<p>The manual way of achieving this is by copy/pasting the same chart in the
<code>charts/</code> directory multiple times with different names.</p>

<h4 id="tags-and-condition-fields-in-requirements-yaml">Tags and Condition fields in requirements.yaml</h4>

<p>In addition to the other fields above, each requirements entry may contain
the optional fields <code>tags</code> and <code>condition</code>.</p>

<p>All charts are loaded by default. If <code>tags</code> or <code>condition</code> fields are present,
they will be evaluated and used to control loading for the chart(s) they are applied to.</p>

<p>Condition - The condition field holds one or more YAML paths (delimited by commas).
If this path exists in the top parent&rsquo;s values and resolves to a boolean value,
the chart will be enabled or disabled based on that boolean value.  Only the first
valid path found in the list is evaluated and if no paths exist then the condition has no effect.</p>

<p>Tags - The tags field is a YAML list of labels to associate with this chart.
In the top parent&rsquo;s values, all charts with tags can be enabled or disabled by
specifying the tag and a boolean value.</p>

<pre><code class="language-yaml"># parentchart/requirements.yaml
dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart1.enabled,global.subchart1.enabled
    tags:
      - front-end
      - subchart1

  - name: subchart2
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart2.enabled,global.subchart2.enabled
    tags:
      - back-end
      - subchart2

</code></pre>

<pre><code class="language-yaml"># parentchart/values.yaml

subchart1:
  enabled: true
tags:
  front-end: false
  back-end: true
</code></pre>

<p>In the above example all charts with the tag <code>front-end</code> would be disabled but since the
<code>subchart1.enabled</code> path evaluates to &lsquo;true&rsquo; in the parent&rsquo;s values, the condition will override the
<code>front-end</code> tag and <code>subchart1</code> will be enabled.</p>

<p>Since <code>subchart2</code> is tagged with <code>back-end</code> and that tag evaluates to <code>true</code>, <code>subchart2</code> will be
enabled. Also notes that although <code>subchart2</code> has a condition specified in <code>requirements.yaml</code>, there
is no corresponding path and value in the parent&rsquo;s values so that condition has no effect.</p>

<h5 id="using-the-cli-with-tags-and-conditions">Using the CLI with Tags and Conditions</h5>

<p>The <code>--set</code> parameter can be used as usual to alter tag and condition values.</p>

<pre><code>helm install --set tags.front-end=true --set subchart2.enabled=false
</code></pre>

<h5 id="tags-and-condition-resolution">Tags and Condition Resolution</h5>

<ul>
<li><strong>Conditions (when set in values) always override tags.</strong></li>
<li>The first condition path that exists wins and subsequent ones for that chart are ignored.</li>
<li>Tags are evaluated as &lsquo;if any of the chart&rsquo;s tags are true then enable the chart&rsquo;.</li>
<li>Tags and conditions values must be set in the top parent&rsquo;s values.</li>
<li>The <code>tags:</code> key in values must be a top level key. Globals and nested <code>tags:</code> tables
are not currently supported.</li>
</ul>

<h4 id="importing-child-values-via-requirements-yaml">Importing Child Values via requirements.yaml</h4>

<p>In some cases it is desirable to allow a child chart&rsquo;s values to propagate to the parent chart and be
shared as common defaults. An additional benefit of using the <code>exports</code> format is that it will enable future
tooling to introspect user-settable values.</p>

<p>The keys containing the values to be imported can be specified in the parent chart&rsquo;s <code>requirements.yaml</code> file
using a YAML list. Each item in the list is a key which is imported from the child chart&rsquo;s <code>exports</code> field.</p>

<p>To import values not contained in the <code>exports</code> key, use the <a href="#using-the-child-parent-format">child-parent</a> format.
Examples of both formats are described below.</p>

<h5 id="using-the-exports-format">Using the exports format</h5>

<p>If a child chart&rsquo;s <code>values.yaml</code> file contains an <code>exports</code> field at the root, its contents may be imported
directly into the parent&rsquo;s values by specifying the keys to import as in the example below:</p>

<pre><code class="language-yaml"># parent's requirements.yaml file
    ...
    import-values:
      - data
</code></pre>

<pre><code class="language-yaml"># child's values.yaml file
...
exports:
  data:
    myint: 99
</code></pre>

<p>Since we are specifying the key <code>data</code> in our import list, Helm looks in the <code>exports</code> field of the child
chart for <code>data</code> key and imports its contents.</p>

<p>The final parent values would contain our exported field:</p>

<pre><code class="language-yaml"># parent's values file
...
myint: 99

</code></pre>

<p>Please note the parent key <code>data</code> is not contained in the parent&rsquo;s final values. If you need to specify the
parent key, use the &lsquo;child-parent&rsquo; format.</p>

<h5 id="using-the-child-parent-format">Using the child-parent format</h5>

<p>To access values that are not contained in the <code>exports</code> key of the child chart&rsquo;s values, you will need to
specify the source key of the values to be imported (<code>child</code>) and the destination path in the parent chart&rsquo;s
values (<code>parent</code>).</p>

<p>The <code>import-values</code> in the example below instructs Helm to take any values found at <code>child:</code> path and copy them
to the parent&rsquo;s values at the path specified in <code>parent:</code></p>

<pre><code class="language-yaml"># parent's requirements.yaml file
dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    ...
    import-values:
      - child: default.data
        parent: myimports
</code></pre>

<p>In the above example, values found at <code>default.data</code> in the subchart1&rsquo;s values will be imported
to the <code>myimports</code> key in the parent chart&rsquo;s values as detailed below:</p>

<pre><code class="language-yaml"># parent's values.yaml file

myimports:
  myint: 0
  mybool: false
  mystring: &quot;helm rocks!&quot;

</code></pre>

<pre><code class="language-yaml"># subchart1's values.yaml file

default:
  data:
    myint: 999
    mybool: true

</code></pre>

<p>The parent chart&rsquo;s resulting values would be:</p>

<pre><code class="language-yaml"># parent's final values

myimports:
  myint: 999
  mybool: true
  mystring: &quot;helm rocks!&quot;

</code></pre>

<p>The parent&rsquo;s final values now contains the <code>myint</code> and <code>mybool</code> fields imported from subchart1.</p>

<h3 id="managing-dependencies-manually-via-the-charts-directory">Managing Dependencies manually via the <code>charts/</code> directory</h3>

<p>If more control over dependencies is desired, these dependencies can
be expressed explicitly by copying the dependency charts into the
<code>charts/</code> directory.</p>

<p>A dependency can be either a chart archive (<code>foo-1.2.3.tgz</code>) or an
unpacked chart directory. But its name cannot start with <code>_</code> or <code>.</code>.
Such files are ignored by the chart loader.</p>

<p>For example, if the WordPress chart depends on the Apache chart, the
Apache chart (of the correct version) is supplied in the WordPress
chart&rsquo;s <code>charts/</code> directory:</p>

<pre><code>wordpress:
  Chart.yaml
  requirements.yaml
  # ...
  charts/
    apache/
      Chart.yaml
      # ...
    mysql/
      Chart.yaml
      # ...
</code></pre>

<p>The example above shows how the WordPress chart expresses its dependency
on Apache and MySQL by including those charts inside of its <code>charts/</code>
directory.</p>

<p><strong>TIP:</strong> <em>To drop a dependency into your <code>charts/</code> directory, use the
<code>helm fetch</code> command</em></p>

<h3 id="operational-aspects-of-using-dependencies">Operational aspects of using dependencies</h3>

<p>The above sections explain how to specify chart dependencies, but how does this affect
chart installation using <code>helm install</code> and <code>helm upgrade</code>?</p>

<p>Suppose that a chart named &ldquo;A&rdquo; creates the following Kubernetes objects</p>

<ul>
<li>namespace &ldquo;A-Namespace&rdquo;</li>
<li>statefulset &ldquo;A-StatefulSet&rdquo;</li>
<li>service &ldquo;A-Service&rdquo;</li>
</ul>

<p>Furthermore, A is dependent on chart B that creates objects</p>

<ul>
<li>namespace &ldquo;B-Namespace&rdquo;</li>
<li>replicaset &ldquo;B-ReplicaSet&rdquo;</li>
<li>service &ldquo;B-Service&rdquo;</li>
</ul>

<p>After installation/upgrade of chart A a single Helm release is created/modified. The release will
create/update all of the above Kubernetes objects in the following order:</p>

<ul>
<li>A-Namespace</li>
<li>B-Namespace</li>
<li>A-StatefulSet</li>
<li>B-ReplicaSet</li>
<li>A-Service</li>
<li>B-Service</li>
</ul>

<p>This is because when Helm installs/upgrades charts,
the Kubernetes objects from the charts and all its dependencies are</p>

<ul>
<li>aggregrated into a single set; then</li>
<li>sorted by type followed by name; and then</li>
<li>created/updated in that order.</li>
</ul>

<p>Hence a single release is created with all the objects for the chart and its dependencies.</p>

<p>The install order of Kubernetes types is given by the enumeration InstallOrder in kind_sorter.go
(see <a href="https://github.com/helm/helm/blob/master/pkg/tiller/kind_sorter.go#L26">the Helm source file</a>).</p>

<h2 id="templates-and-values">Templates and Values</h2>

<p>Helm Chart templates are written in the
<a href="https://golang.org/pkg/text/template/">Go template language</a>, with the
addition of 50 or so add-on template
functions <a href="https://github.com/Masterminds/sprig">from the Sprig library</a> and a
few other <a href="./#chart-development-tips-and-tricks">specialized functions</a>.</p>

<p>All template files are stored in a chart&rsquo;s <code>templates/</code> folder. When
Helm renders the charts, it will pass every file in that directory
through the template engine.</p>

<p>Values for the templates are supplied two ways:</p>

<ul>
<li>Chart developers may supply a file called <code>values.yaml</code> inside of a
chart. This file can contain default values.</li>
<li>Chart users may supply a YAML file that contains values. This can be
provided on the command line with <code>helm install</code>.</li>
</ul>

<p>When a user supplies custom values, these values will override the
values in the chart&rsquo;s <code>values.yaml</code> file.</p>

<h3 id="template-files">Template Files</h3>

<p>Template files follow the standard conventions for writing Go templates
(see <a href="https://golang.org/pkg/text/template/">the text/template Go package documentation</a>
for details).
An example template file might look something like this:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &quot;minio&quot; .Values.storage}}
</code></pre>

<p>The above example, based loosely on <a href="https://github.com/deis/charts">https://github.com/deis/charts</a>, is a template for a Kubernetes replication controller.
It can use the following four template values (usually defined in a
<code>values.yaml</code> file):</p>

<ul>
<li><code>imageRegistry</code>: The source registry for the Docker image.</li>
<li><code>dockerTag</code>: The tag for the docker image.</li>
<li><code>pullPolicy</code>: The Kubernetes pull policy.</li>
<li><code>storage</code>: The storage backend, whose default is set to <code>&quot;minio&quot;</code></li>
</ul>

<p>All of these values are defined by the template author. Helm does not
require or dictate parameters.</p>

<p>To see many working charts, check out the <a href="https://github.com/helm/charts">Helm Charts
project</a></p>

<h3 id="predefined-values">Predefined Values</h3>

<p>Values that are supplied via a <code>values.yaml</code> file (or via the <code>--set</code>
flag) are accessible from the <code>.Values</code> object in a template. But there
are other pre-defined pieces of data you can access in your templates.</p>

<p>The following values are pre-defined, are available to every template, and
cannot be overridden. As with all values, the names are <em>case
sensitive</em>.</p>

<ul>
<li><code>Release.Name</code>: The name of the release (not the chart)</li>
<li><code>Release.Time</code>: The time the chart release was last updated. This will
match the <code>Last Released</code> time on a Release object.</li>
<li><code>Release.Namespace</code>: The namespace the chart was released to.</li>
<li><code>Release.Service</code>: The service that conducted the release. Usually
this is <code>Tiller</code>.</li>
<li><code>Release.IsUpgrade</code>: This is set to true if the current operation is an upgrade or rollback.</li>
<li><code>Release.IsInstall</code>: This is set to true if the current operation is an
install.</li>
<li><code>Release.Revision</code>: The revision number. It begins at 1, and increments with
each <code>helm upgrade</code>.</li>
<li><code>Chart</code>: The contents of the <code>Chart.yaml</code>. Thus, the chart version is
obtainable as <code>Chart.Version</code> and the maintainers are in
<code>Chart.Maintainers</code>.</li>
<li><code>Files</code>: A map-like object containing all non-special files in the chart. This
will not give you access to templates, but will give you access to additional
files that are present (unless they are excluded using <code>.helmignore</code>). Files can be
accessed using <code>{{index .Files &quot;file.name&quot;}}</code> or using the <code>{{.Files.Get name}}</code> or
<code>{{.Files.GetString name}}</code> functions. You can also access the contents of the file
as <code>[]byte</code> using <code>{{.Files.GetBytes}}</code></li>
<li><code>Capabilities</code>: A map-like object that contains information about the versions
of Kubernetes (<code>{{.Capabilities.KubeVersion}}</code>, Tiller
(<code>{{.Capabilities.TillerVersion}}</code>, and the supported Kubernetes API versions
(<code>{{.Capabilities.APIVersions.Has &quot;batch/v1&quot;</code>)</li>
</ul>

<p><strong>NOTE:</strong> Any unknown Chart.yaml fields will be dropped. They will not
be accessible inside of the <code>Chart</code> object. Thus, Chart.yaml cannot be
used to pass arbitrarily structured data into the template. The values
file can be used for that, though.</p>

<h3 id="values-files">Values files</h3>

<p>Considering the template in the previous section, a <code>values.yaml</code> file
that supplies the necessary values would look like this:</p>

<pre><code class="language-yaml">imageRegistry: &quot;quay.io/deis&quot;
dockerTag: &quot;latest&quot;
pullPolicy: &quot;Always&quot;
storage: &quot;s3&quot;
</code></pre>

<p>A values file is formatted in YAML. A chart may include a default
<code>values.yaml</code> file. The Helm install command allows a user to override
values by supplying additional YAML values:</p>

<pre><code class="language-console">$ helm install --values=myvals.yaml wordpress
</code></pre>

<p>When values are passed in this way, they will be merged into the default
values file. For example, consider a <code>myvals.yaml</code> file that looks like
this:</p>

<pre><code class="language-yaml">storage: &quot;gcs&quot;
</code></pre>

<p>When this is merged with the <code>values.yaml</code> in the chart, the resulting
generated content will be:</p>

<pre><code class="language-yaml">imageRegistry: &quot;quay.io/deis&quot;
dockerTag: &quot;latest&quot;
pullPolicy: &quot;Always&quot;
storage: &quot;gcs&quot;
</code></pre>

<p>Note that only the last field was overridden.</p>

<p><strong>NOTE:</strong> The default values file included inside of a chart <em>must</em> be named
<code>values.yaml</code>. But files specified on the command line can be named
anything.</p>

<p><strong>NOTE:</strong> If the <code>--set</code> flag is used on <code>helm install</code> or <code>helm upgrade</code>, those
values are simply converted to YAML on the client side.</p>

<p><strong>NOTE:</strong> If any required entries in the values file exist, they can be declared
as required in the chart template by using the <a href="./#chart-development-tips-and-tricks">&lsquo;required&rsquo; function</a></p>

<p>Any of these values are then accessible inside of templates using the
<code>.Values</code> object:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &quot;minio&quot; .Values.storage}}

</code></pre>

<h3 id="scope-dependencies-and-values">Scope, Dependencies, and Values</h3>

<p>Values files can declare values for the top-level chart, as well as for
any of the charts that are included in that chart&rsquo;s <code>charts/</code> directory.
Or, to phrase it differently, a values file can supply values to the
chart as well as to any of its dependencies. For example, the
demonstration WordPress chart above has both <code>mysql</code> and <code>apache</code> as
dependencies. The values file could supply values to all of these
components:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

mysql:
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  port: 8080 # Passed to Apache
</code></pre>

<p>Charts at a higher level have access to all of the variables defined
beneath. So the WordPress chart can access the MySQL password as
<code>.Values.mysql.password</code>. But lower level charts cannot access things in
parent charts, so MySQL will not be able to access the <code>title</code> property. Nor,
for that matter, can it access <code>apache.port</code>.</p>

<p>Values are namespaced, but namespaces are pruned. So for the WordPress
chart, it can access the MySQL password field as <code>.Values.mysql.password</code>. But
for the MySQL chart, the scope of the values has been reduced and the
namespace prefix removed, so it will see the password field simply as
<code>.Values.password</code>.</p>

<h4 id="global-values">Global Values</h4>

<p>As of 2.0.0-Alpha.2, Helm supports special &ldquo;global&rdquo; value. Consider
this modified version of the previous example:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  port: 8080 # Passed to Apache
</code></pre>

<p>The above adds a <code>global</code> section with the value <code>app: MyWordPress</code>.
This value is available to <em>all</em> charts as <code>.Values.global.app</code>.</p>

<p>For example, the <code>mysql</code> templates may access <code>app</code> as <code>{{.Values.global.app}}</code>, and
so can the <code>apache</code> chart. Effectively, the values file above is
regenerated like this:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  global:
    app: MyWordPress
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  global:
    app: MyWordPress
  port: 8080 # Passed to Apache
</code></pre>

<p>This provides a way of sharing one top-level variable with all
subcharts, which is useful for things like setting <code>metadata</code> properties
like labels.</p>

<p>If a subchart declares a global variable, that global will be passed
<em>downward</em> (to the subchart&rsquo;s subcharts), but not <em>upward</em> to the parent
chart. There is no way for a subchart to influence the values of the
parent chart.</p>

<p>Also, global variables of parent charts take precedence over the global variables from subcharts.</p>

<h3 id="references">References</h3>

<p>When it comes to writing templates and values files, there are several
standard references that will help you out.</p>

<ul>
<li><a href="https://godoc.org/text/template">Go templates</a></li>
<li><a href="https://godoc.org/github.com/Masterminds/sprig">Extra template functions</a></li>
<li><a href="http://yaml.org/spec/">The YAML format</a></li>
</ul>

<h2 id="using-helm-to-manage-charts">Using Helm to Manage Charts</h2>

<p>The <code>helm</code> tool has several commands for working with charts.</p>

<p>It can create a new chart for you:</p>

<pre><code class="language-console">$ helm create mychart
Created mychart/
</code></pre>

<p>Once you have edited a chart, <code>helm</code> can package it into a chart archive
for you:</p>

<pre><code class="language-console">$ helm package mychart
Archived mychart-0.1.-.tgz
</code></pre>

<p>You can also use <code>helm</code> to help you find issues with your chart&rsquo;s
formatting or information:</p>

<pre><code class="language-console">$ helm lint mychart
No issues found
</code></pre>

<h2 id="chart-repositories">Chart Repositories</h2>

<p>A <em>chart repository</em> is an HTTP server that houses one or more packaged
charts. While <code>helm</code> can be used to manage local chart directories, when
it comes to sharing charts, the preferred mechanism is a chart
repository.</p>

<p>Any HTTP server that can serve YAML files and tar files and can answer
GET requests can be used as a repository server.</p>

<p>Helm comes with built-in package server for developer testing (<code>helm
serve</code>). The Helm team has tested other servers, including Google Cloud
Storage with website mode enabled, and S3 with website mode enabled.</p>

<p>A repository is characterized primarily by the presence of a special
file called <code>index.yaml</code> that has a list of all of the packages supplied
by the repository, together with metadata that allows retrieving and
verifying those packages.</p>

<p>On the client side, repositories are managed with the <code>helm repo</code>
commands. However, Helm does not provide tools for uploading charts to
remote repository servers. This is because doing so would add
substantial requirements to an implementing server, and thus raise the
barrier for setting up a repository.</p>

<h2 id="chart-starter-packs">Chart Starter Packs</h2>

<p>The <code>helm create</code> command takes an optional <code>--starter</code> option that lets you
specify a &ldquo;starter chart&rdquo;.</p>

<p>Starters are just regular charts, but are located in <code>$HELM_HOME/starters</code>.
As a chart developer, you may author charts that are specifically designed
to be used as starters. Such charts should be designed with the following
considerations in mind:</p>

<ul>
<li>The <code>Chart.yaml</code> will be overwritten by the generator.</li>
<li>Users will expect to modify such a chart&rsquo;s contents, so documentation
should indicate how users can do so.</li>
<li>All occurrences of <code>&lt;CHARTNAME&gt;</code> in files within the <code>templates</code> directory
will be replaced with the specified chart name so that starter charts can be
used as templates. Additionally, occurrences of <code>&lt;CHARTNAME&gt;</code> in
<code>values.yaml</code> will also be replaced.</li>
</ul>

<p>Currently the only way to add a chart to <code>$HELM_HOME/starters</code> is to manually
copy it there. In your chart&rsquo;s documentation, you may want to explain that
process.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="hooks">Hooks</h1>

<p>Helm provides a <em>hook</em> mechanism to allow chart developers to intervene
at certain points in a release&rsquo;s life cycle. For example, you can use
hooks to:</p>

<ul>
<li>Load a ConfigMap or Secret during install before any other charts are
loaded.</li>
<li>Execute a Job to back up a database before installing a new chart,
and then execute a second job after the upgrade in order to restore
data.</li>
<li>Run a Job before deleting a release to gracefully take a service out
of rotation before removing it.</li>
</ul>

<p>Hooks work like regular templates, but they have special annotations
that cause Helm to utilize them differently. In this section, we cover
the basic usage pattern for hooks.</p>

<p>Hooks are declared as an annotation in the metadata section of a manifest:</p>

<pre><code class="language-yaml">apiVersion: ...
kind: ....
metadata:
  annotations:
    &quot;helm.sh/hook&quot;: &quot;pre-install&quot;
# ...
</code></pre>

<h2 id="the-available-hooks">The Available Hooks</h2>

<p>The following hooks are defined:</p>

<ul>
<li>pre-install: Executes after templates are rendered, but before any
resources are created in Kubernetes.</li>
<li>post-install: Executes after all resources are loaded into Kubernetes</li>
<li>pre-delete: Executes on a deletion request before any resources are
deleted from Kubernetes.</li>
<li>post-delete: Executes on a deletion request after all of the release&rsquo;s
resources have been deleted.</li>
<li>pre-upgrade: Executes on an upgrade request after templates are
rendered, but before any resources are loaded into Kubernetes (e.g.
before a Kubernetes apply operation).</li>
<li>post-upgrade: Executes on an upgrade after all resources have been
upgraded.</li>
<li>pre-rollback: Executes on a rollback request after templates are
rendered, but before any resources have been rolled back.</li>
<li>post-rollback: Executes on a rollback request after all resources
have been modified.</li>
<li>crd-install: Adds CRD resources before any other checks are run. This is used
only on CRD definitions that are used by other manifests in the chart.</li>
</ul>

<h2 id="hooks-and-the-release-lifecycle">Hooks and the Release Lifecycle</h2>

<p>Hooks allow you, the chart developer, an opportunity to perform
operations at strategic points in a release lifecycle. For example,
consider the lifecycle for a <code>helm install</code>. By default, the lifecycle
looks like this:</p>

<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders the <code>foo</code> templates</li>
<li>Tiller loads the resulting resources into Kubernetes</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>

<p>Helm defines two hooks for the <code>install</code> lifecycle: <code>pre-install</code> and
<code>post-install</code>. If the developer of the <code>foo</code> chart implements both
hooks, the lifecycle is altered like this:</p>

<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders the <code>foo</code> templates</li>
<li>Tiller prepares to execute the <code>pre-install</code> hooks (loading hook resources into
Kubernetes)</li>
<li>Tiller sorts hooks by weight (assigning a weight of 0 by default) and by name for those hooks with the same weight in ascending order.</li>
<li>Tiller then loads the hook with the lowest weight first (negative to positive)</li>
<li>Tiller waits until the hook is &ldquo;Ready&rdquo; (except for CRDs)</li>
<li>Tiller loads the resulting resources into Kubernetes. Note that if the <code>--wait</code>
flag is set, Tiller will wait until all resources are in a ready state
and will not run the <code>post-install</code> hook until they are ready.</li>
<li>Tiller executes the <code>post-install</code> hook (loading hook resources)</li>
<li>Tiller waits until the hook is &ldquo;Ready&rdquo;</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>

<p>What does it mean to wait until a hook is ready? This depends on the
resource declared in the hook. If the resources is a <code>Job</code> kind, Tiller
will wait until the job successfully runs to completion. And if the job
fails, the release will fail. This is a <em>blocking operation</em>, so the
Helm client will pause while the Job is run.</p>

<p>For all other kinds, as soon as Kubernetes marks the resource as loaded
(added or updated), the resource is considered &ldquo;Ready&rdquo;. When many
resources are declared in a hook, the resources are executed serially. If they
have hook weights (see below), they are executed in weighted order. Otherwise,
ordering is not guaranteed. (In Helm 2.3.0 and after, they are sorted
alphabetically. That behavior, though, is not considered binding and could change
in the future.) It is considered good practice to add a hook weight, and set it
to <code>0</code> if weight is not important.</p>

<h3 id="hook-resources-are-not-managed-with-corresponding-releases">Hook resources are not managed with corresponding releases</h3>

<p>The resources that a hook creates are not tracked or managed as part of the
release. Once Tiller verifies that the hook has reached its ready state, it
will leave the hook resource alone.</p>

<p>Practically speaking, this means that if you create resources in a hook, you
cannot rely upon <code>helm delete</code> to remove the resources. To destroy such
resources, you need to either write code to perform this operation in a <code>pre-delete</code>
or <code>post-delete</code> hook or add <code>&quot;helm.sh/hook-delete-policy&quot;</code> annotation to the hook template file.</p>

<h2 id="writing-a-hook">Writing a Hook</h2>

<p>Hooks are just Kubernetes manifest files with special annotations in the
<code>metadata</code> section. Because they are template files, you can use all of
the normal template features, including reading <code>.Values</code>, <code>.Release</code>,
and <code>.Template</code>.</p>

<p>For example, this template, stored in <code>templates/post-install-job.yaml</code>,
declares a job to be run on <code>post-install</code>:</p>

<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: &quot;{{.Release.Name}}&quot;
  labels:
    app.kubernetes.io/managed-by: {{.Release.Service | quote }}
    app.kubernetes.io/instance: {{.Release.Name | quote }}
    helm.sh/chart: &quot;{{.Chart.Name}}-{{.Chart.Version}}&quot;
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    &quot;helm.sh/hook&quot;: post-install
    &quot;helm.sh/hook-weight&quot;: &quot;-5&quot;
    &quot;helm.sh/hook-delete-policy&quot;: hook-succeeded
spec:
  template:
    metadata:
      name: &quot;{{.Release.Name}}&quot;
      labels:
        app.kubernetes.io/managed-by: {{.Release.Service | quote }}
        app.kubernetes.io/instance: {{.Release.Name | quote }}
        helm.sh/chart: &quot;{{.Chart.Name}}-{{.Chart.Version}}&quot;
    spec:
      restartPolicy: Never
      containers:
      - name: post-install-job
        image: &quot;alpine:3.3&quot;
        command: [&quot;/bin/sleep&quot;,&quot;{{default &quot;10&quot; .Values.sleepyTime}}&quot;]

</code></pre>

<p>What makes this template a hook is the annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook&quot;: post-install
</code></pre>

<p>One resource can implement multiple hooks:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook&quot;: post-install,post-upgrade
</code></pre>

<p>Similarly, there is no limit to the number of different resources that
may implement a given hook. For example, one could declare both a secret
and a config map as a pre-install hook.</p>

<p>When subcharts declare hooks, those are also evaluated. There is no way
for a top-level chart to disable the hooks declared by subcharts.</p>

<p>It is possible to define a weight for a hook which will help build a
deterministic executing order. Weights are defined using the following annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook-weight&quot;: &quot;5&quot;
</code></pre>

<p>Hook weights can be positive or negative numbers but must be represented as
strings. When Tiller starts the execution cycle of hooks of a particular kind (ex. the <code>pre-install</code> hooks or <code>post-install</code> hooks, etc.) it will sort those hooks in ascending order.</p>

<p>It is also possible to define policies that determine when to delete corresponding hook resources. Hook deletion policies are defined using the following annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook-delete-policy&quot;: hook-succeeded
</code></pre>

<p>You can choose one or more defined annotation values:</p>

<ul>
<li><code>&quot;hook-succeeded&quot;</code> specifies Tiller should delete the hook after the hook is successfully executed.</li>
<li><code>&quot;hook-failed&quot;</code> specifies Tiller should delete the hook if the hook failed during execution.</li>
<li><code>&quot;before-hook-creation&quot;</code> specifies Tiller should delete the previous hook before the new hook is launched.</li>
</ul>

<h3 id="defining-a-crd-with-the-crd-install-hook">Defining a CRD with the <code>crd-install</code> Hook</h3>

<p>Custom Resource Definitions (CRDs) are a special kind in Kubernetes. They provide
a way to define other kinds.</p>

<p>On occasion, a chart needs to both define a kind and then use it. This is done
with the <code>crd-install</code> hook.</p>

<p>The <code>crd-install</code> hook is executed very early during an installation, before
the rest of the manifests are verified. CRDs can be annotated with this hook so
that they are installed before any instances of that CRD are referenced. In this
way, when verification happens later, the CRDs will be available.</p>

<p>Here is an example of defining a CRD with a hook, and an instance of the CRD:</p>

<pre><code class="language-yaml">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com
  annotations:
    &quot;helm.sh/hook&quot;: crd-install
spec:
  group: stable.example.com
  version: v1
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
    shortNames:
    - ct
</code></pre>

<p>And:</p>

<pre><code class="language-yaml">apiVersion: stable.example.com/v1
kind: CronTab
metadata:
  name: {{ .Release.Name }}-inst
</code></pre>

<p>Both of these can now be in the same chart, provided that the CRD is correctly
annotated.</p>

<h3 id="automatically-delete-hook-from-previous-release">Automatically delete hook from previous release</h3>

<p>When helm release being updated it is possible, that hook resource already exists in cluster. By default helm will try to create resource and fail with <code>&quot;... already exists&quot;</code> error.</p>

<p>One might choose <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;before-hook-creation&quot;</code> over <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;hook-succeeded,hook-failed&quot;</code> because:</p>

<ul>
<li>It is convenient to keep failed hook job resource in kubernetes for example for manual debug.</li>
<li>It may be necessary to keep succeeded hook resource in kubernetes for some reason.</li>
<li>At the same time it is not desirable to do manual resource deletion before helm release upgrade.</li>
</ul>

<p><code>&quot;helm.sh/hook-delete-policy&quot;: &quot;before-hook-creation&quot;</code> annotation on hook causes tiller to remove the hook from previous release if there is one before the new hook is launched and can be used with another policy.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="chart-development-tips-and-tricks">Chart Development Tips and Tricks</h1>

<p>This guide covers some of the tips and tricks Helm chart developers have
learned while building production-quality charts.</p>

<h2 id="know-your-template-functions">Know Your Template Functions</h2>

<p>Helm uses <a href="https://godoc.org/text/template">Go templates</a> for templating
your resource files. While Go ships several built-in functions, we have
added many others.</p>

<p>First, we added almost all of the functions in the
<a href="https://godoc.org/github.com/Masterminds/sprig">Sprig library</a>. We removed two
for security reasons: <code>env</code> and <code>expandenv</code> (which would have given chart authors
access to Tiller&rsquo;s environment).</p>

<p>We also added two special template functions: <code>include</code> and <code>required</code>. The <code>include</code>
function allows you to bring in another template, and then pass the results to other
template functions.</p>

<p>For example, this template snippet includes a template called <code>mytpl</code>, then
lowercases the result, then wraps that in double quotes.</p>

<pre><code class="language-yaml">value: {{ include &quot;mytpl&quot; . | lower | quote }}
</code></pre>

<p>The <code>required</code> function allows you to declare a particular
values entry as required for template rendering. If the value is empty, the template
rendering will fail with a user submitted error message.</p>

<p>The following example of the <code>required</code> function declares an entry for .Values.who
is required, and will print an error message when that entry is missing:</p>

<pre><code class="language-yaml">value: {{ required &quot;A valid .Values.who entry required!&quot; .Values.who }}
</code></pre>

<h2 id="quote-strings-don-t-quote-integers">Quote Strings, Don&rsquo;t Quote Integers</h2>

<p>When you are working with string data, you are always safer quoting the
strings than leaving them as bare words:</p>

<pre><code class="language-yaml">name: {{ .Values.MyName | quote }}
</code></pre>

<p>But when working with integers <em>do not quote the values.</em> That can, in
many cases, cause parsing errors inside of Kubernetes.</p>

<pre><code class="language-yaml">port: {{ .Values.Port }}
</code></pre>

<p>This remark does not apply to env variables values which are expected to be string, even if they represent integers:</p>

<pre><code class="language-yaml">env:
  -name: HOST
    value: &quot;http://host&quot;
  -name: PORT
    value: &quot;1234&quot;
</code></pre>

<h2 id="using-the-include-function">Using the &lsquo;include&rsquo; Function</h2>

<p>Go provides a way of including one template in another using a built-in
<code>template</code> directive. However, the built-in function cannot be used in
Go template pipelines.</p>

<p>To make it possible to include a template, and then perform an operation
on that template&rsquo;s output, Helm has a special <code>include</code> function:</p>

<pre><code class="language-gotpl">{{- include &quot;toYaml&quot; $value | nindent 2 }}
</code></pre>

<p>The above includes a template called <code>toYaml</code>, passes it <code>$value</code>, and
then passes the output of that template to the <code>nindent</code> function. Using
the <code>{{- ... | nindent _n_ }}</code> pattern makes it easier to read the <code>include</code>
in context, because it chomps the whitespace to the left (including the
previous newline), then the <code>nindent</code> re-adds the newline and indents
the included content by the requested amount.</p>

<p>Because YAML ascribes significance to indentation levels and whitespace,
this is one great way to include snippets of code, but handle
indentation in a relevant context.</p>

<h2 id="using-the-required-function">Using the &lsquo;required&rsquo; function</h2>

<p>Go provides a way for setting template options to control behavior
when a map is indexed with a key that&rsquo;s not present in the map. This
is typically set with template.Options(&ldquo;missingkey=option&rdquo;), where option
can be default, zero, or error. While setting this option to error will
stop execution with an error, this would apply to every missing key in the
map. There may be situations where a chart developer wants to enforce this
behavior for select values in the values.yml file.</p>

<p>The <code>required</code> function gives developers the ability to declare a value entry
as required for template rendering. If the entry is empty in values.yml, the
template will not render and will return an error message supplied by the
developer.</p>

<p>For example:</p>

<pre><code class="language-gotpl">{{ required &quot;A valid foo is required!&quot; .Values.foo }}
</code></pre>

<p>The above will render the template when .Values.foo is defined, but will fail
to render and exit when .Values.foo is undefined.</p>

<h2 id="using-the-tpl-function">Using the &lsquo;tpl&rsquo; Function</h2>

<p>The <code>tpl</code> function allows developers to evaluate strings as templates inside a template.
This is useful to pass a template string as a value to a chart or render external configuration files.
Syntax: <code>{{ tpl TEMPLATE_STRING VALUES }}</code></p>

<p>Examples:</p>

<pre><code class="language-yaml"># values
template: &quot;{{ .Values.name }}&quot;
name: &quot;Tom&quot;

# template
{{ tpl .Values.template . }}

# output
Tom
</code></pre>

<p>Rendering a external configuration file:</p>

<pre><code class="language-yaml"># external configuration file conf/app.conf
firstName={{ .Values.firstName }}
lastName={{ .Values.lastName }}

# values
firstName: Peter
lastName: Parker

# template
{{ tpl (.Files.Get &quot;conf/app.conf&quot;) . }}

# output
firstName=Peter
lastName=Parker
</code></pre>

<h2 id="creating-image-pull-secrets">Creating Image Pull Secrets</h2>

<p>Image pull secrets are essentially a combination of <em>registry</em>, <em>username</em>, and <em>password</em>. You may need them in an application you are deploying, but to create them requires running <em>base64</em> a couple of times. We can write a helper template to compose the Docker configuration file for use as the Secret&rsquo;s payload. Here is an example:</p>

<p>First, assume that the credentials are defined in the <code>values.yaml</code> file like so:</p>

<pre><code class="language-yaml">imageCredentials:
  registry: quay.io
  username: someone
  password: sillyness
</code></pre>

<p>We then define our helper template as follows:</p>

<pre><code class="language-gotpl">{{- define &quot;imagePullSecret&quot; }}
{{- printf &quot;{\&quot;auths\&quot;: {\&quot;%s\&quot;: {\&quot;auth\&quot;: \&quot;%s\&quot;}}}&quot; .Values.imageCredentials.registry (printf &quot;%s:%s&quot; .Values.imageCredentials.username .Values.imageCredentials.password | b64enc) | b64enc }}
{{- end }}
</code></pre>

<p>Finally, we use the helper template in a larger template to create the Secret manifest:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ template &quot;imagePullSecret&quot; . }}
</code></pre>

<h2 id="automatically-roll-deployments-when-configmaps-or-secrets-change">Automatically Roll Deployments When ConfigMaps or Secrets change</h2>

<p>Often times configmaps or secrets are injected as configuration
files in containers.
Depending on the application a restart may be required should those
be updated with a subsequent <code>helm upgrade</code>, but if the
deployment spec itself didn&rsquo;t change the application keeps running
with the old configuration resulting in an inconsistent deployment.</p>

<p>The <code>sha256sum</code> function can be used to ensure a deployment&rsquo;s
annotation section is updated if another file changes:</p>

<pre><code class="language-yaml">kind: Deployment
spec:
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath &quot;/configmap.yaml&quot;) . | sha256sum }}
[...]
</code></pre>

<p>See also the <code>helm upgrade --recreate-pods</code> flag for a slightly
different way of addressing this issue.</p>

<h2 id="tell-tiller-not-to-delete-a-resource">Tell Tiller Not To Delete a Resource</h2>

<p>Sometimes there are resources that should not be deleted when Helm runs a
<code>helm delete</code>. Chart developers can add an annotation to a resource to prevent
it from being deleted.</p>

<pre><code class="language-yaml">kind: Secret
metadata:
  annotations:
    &quot;helm.sh/resource-policy&quot;: keep
[...]
</code></pre>

<p>(Quotation marks are required)</p>

<p>The annotation <code>&quot;helm.sh/resource-policy&quot;: keep</code> instructs Tiller to skip this
resource during a <code>helm delete</code> operation. <em>However</em>, this resource becomes
orphaned. Helm will no longer manage it in any way. This can lead to problems
if using <code>helm install --replace</code> on a release that has already been deleted, but
has kept resources.</p>

<h2 id="using-partials-and-template-includes">Using &ldquo;Partials&rdquo; and Template Includes</h2>

<p>Sometimes you want to create some reusable parts in your chart, whether
they&rsquo;re blocks or template partials. And often, it&rsquo;s cleaner to keep
these in their own files.</p>

<p>In the <code>templates/</code> directory, any file that begins with an
underscore(<code>_</code>) is not expected to output a Kubernetes manifest file. So
by convention, helper templates and partials are placed in a
<code>_helpers.tpl</code> file.</p>

<h2 id="complex-charts-with-many-dependencies">Complex Charts with Many Dependencies</h2>

<p>Many of the charts in the <a href="https://github.com/helm/charts">official charts repository</a>
are &ldquo;building blocks&rdquo; for creating more advanced applications. But charts may be
used to create instances of large-scale applications. In such cases, a single
umbrella chart may have multiple subcharts, each of which functions as a piece
of the whole.</p>

<p>The current best practice for composing a complex application from discrete parts
is to create a top-level umbrella chart that
exposes the global configurations, and then use the <code>charts/</code> subdirectory to
embed each of the components.</p>

<p>Two strong design patterns are illustrated by these projects:</p>

<p><strong>SAP&rsquo;s <a href="https://github.com/sapcc/openstack-helm">OpenStack chart</a>:</strong> This chart
installs a full OpenStack IaaS on Kubernetes. All of the charts are collected
together in one GitHub repository.</p>

<p><strong>Deis&rsquo;s <a href="https://github.com/deis/workflow/tree/master/charts/workflow">Workflow</a>:</strong>
This chart exposes the entire Deis PaaS system with one chart. But it&rsquo;s different
from the SAP chart in that this umbrella chart is built from each component, and
each component is tracked in a different Git repository. Check out the
<code>requirements.yaml</code> file to see how this chart is composed by their CI/CD
pipeline.</p>

<p>Both of these charts illustrate proven techniques for standing up complex environments
using Helm.</p>

<h2 id="yaml-is-a-superset-of-json">YAML is a Superset of JSON</h2>

<p>According to the YAML specification, YAML is a superset of JSON. That
means that any valid JSON structure ought to be valid in YAML.</p>

<p>This has an advantage: Sometimes template developers may find it easier
to express a datastructure with a JSON-like syntax rather than deal with
YAML&rsquo;s whitespace sensitivity.</p>

<p>As a best practice, templates should follow a YAML-like syntax <em>unless</em>
the JSON syntax substantially reduces the risk of a formatting issue.</p>

<h2 id="be-careful-with-generating-random-values">Be Careful with Generating Random Values</h2>

<p>There are functions in Helm that allow you to generate random data,
cryptographic keys, and so on. These are fine to use. But be aware that
during upgrades, templates are re-executed. When a template run
generates data that differs from the last run, that will trigger an
update of that resource.</p>

<h2 id="upgrade-a-release-idempotently">Upgrade a release idempotently</h2>

<p>In order to use the same command when installing and upgrading a release, use the following command:</p>

<pre><code class="language-shell">helm upgrade --install &lt;release name&gt; --values &lt;values file&gt; &lt;chart directory&gt;
</code></pre>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="developers-guide">Developers Guide</h1>

<p>This guide explains how to set up your environment for developing on
Helm and Tiller.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>The latest version of Go</li>
<li>The latest version of Glide</li>
<li>A Kubernetes cluster w/ kubectl (optional)</li>
<li>The gRPC toolchain</li>
<li>Git</li>
</ul>

<h2 id="building-helm-tiller">Building Helm/Tiller</h2>

<p>We use Make to build our programs. The simplest way to get started is:</p>

<pre><code class="language-console">$ make bootstrap build
</code></pre>

<p>NOTE: This will fail if not running from the path <code>$GOPATH/src/k8s.io/helm</code>. The
directory <code>k8s.io</code> should not be a symlink or <code>build</code> will not find the relevant
packages.</p>

<p>This will build both Helm and Tiller. <code>make bootstrap</code> will attempt to
install certain tools if they are missing.</p>

<p>To run all the tests (without running the tests for <code>vendor/</code>), run
<code>make test</code>. To run all tests in a containerized environment, run <code>make
docker-test</code>.</p>

<p>To run Helm and Tiller locally, you can run <code>bin/helm</code> or <code>bin/tiller</code>.</p>

<ul>
<li>Helm and Tiller are known to run on macOS and most Linuxes, including
Alpine.</li>
<li>Tiller must have access to a Kubernetes cluster. It learns about the
cluster by examining the Kube config files that <code>kubectl</code> uses.</li>
</ul>

<h3 id="man-pages">Man pages</h3>

<p>Man pages and Markdown documentation are already pre-built in <code>docs/</code>. You may
regenerate documentation using <code>make docs</code>.</p>

<p>To expose the Helm man pages to your <code>man</code> client, you can put the files in your
<code>$MANPATH</code>:</p>

<pre><code>$ export MANPATH=$GOPATH/src/k8s.io/helm/docs/man:$MANPATH
$ man helm
</code></pre>

<h2 id="grpc-and-protobuf">gRPC and Protobuf</h2>

<p>Helm and Tiller communicate using gRPC. To get started with gRPC, you will need to&hellip;</p>

<ul>
<li>Install <code>protoc</code> for compiling protobuf files. Releases are
<a href="https://github.com/google/protobuf/releases">here</a></li>
<li>Run Helm&rsquo;s <code>make bootstrap</code> to generate the <code>protoc-gen-go</code> plugin and
place it in <code>bin/</code>.</li>
</ul>

<p>Note that you need to be on protobuf 3.2.0 (<code>protoc --version</code>). The
version of <code>protoc-gen-go</code> is tied to the version of gRPC used in
Kubernetes. So the plugin is maintained locally.</p>

<p>While the gRPC and ProtoBuf specs remain silent on indentation, we
require that the indentation style matches the Go format specification.
Namely, protocol buffers should use tab-based indentation and rpc
declarations should follow the style of Go function declarations.</p>

<h3 id="the-helm-api-hapi">The Helm API (HAPI)</h3>

<p>We use gRPC as an API layer. See <code>pkg/proto/hapi</code> for the generated Go code,
and <code>_proto</code> for the protocol buffer definitions.</p>

<p>To regenerate the Go files from the protobuf source, <code>make protoc</code>.</p>

<h2 id="docker-images">Docker Images</h2>

<p>To build Docker images, use <code>make docker-build</code>.</p>

<p>Pre-build images are already available in the official Kubernetes Helm
GCR registry.</p>

<h2 id="running-a-local-cluster">Running a Local Cluster</h2>

<p>For development, we highly recommend using the
<a href="https://github.com/kubernetes/minikube">Kubernetes Minikube</a>
developer-oriented distribution. Once this is installed, you can use
<code>helm init</code> to install into the cluster. Note that version of tiller you&rsquo;re using for
development may not be available in Google Cloud Container Registry. If you&rsquo;re getting
image pull errors, you can override the version of Tiller. Example:</p>

<pre><code class="language-console">helm init --tiller-image=gcr.io/kubernetes-helm/tiller:2.7.2
</code></pre>

<p>Or use the latest version:</p>

<pre><code class="language-console">helm init --canary-image
</code></pre>

<p>For developing on Tiller, it is sometimes more expedient to run Tiller locally
instead of packaging it into an image and running it in-cluster. You can do
this by telling the Helm client to us a local instance.</p>

<pre><code class="language-console">$ make build
$ bin/tiller
</code></pre>

<p>And to configure the Helm client, use the <code>--host</code> flag or export the <code>HELM_HOST</code>
environment variable:</p>

<pre><code class="language-console">$ export HELM_HOST=localhost:44134
$ helm install foo
</code></pre>

<p>(Note that you do not need to use <code>helm init</code> when you are running Tiller directly)</p>

<p>Tiller should run on any &gt;= 1.3 Kubernetes cluster.</p>

<h2 id="contribution-guidelines">Contribution Guidelines</h2>

<p>We welcome contributions. This project has set up some guidelines in
order to ensure that (a) code quality remains high, (b) the project
remains consistent, and &copy; contributions follow the open source legal
requirements. Our intent is not to burden contributors, but to build
elegant and high-quality open source code so that our users will benefit.</p>

<p>Make sure you have read and understood the main CONTRIBUTING guide:</p>

<p><a href="https://github.com/helm/helm/blob/master/CONTRIBUTING.md">https://github.com/helm/helm/blob/master/CONTRIBUTING.md</a></p>

<h3 id="structure-of-the-code">Structure of the Code</h3>

<p>The code for the Helm project is organized as follows:</p>

<ul>
<li>The individual programs are located in <code>cmd/</code>. Code inside of <code>cmd/</code>
is not designed for library re-use.</li>
<li>Shared libraries are stored in <code>pkg/</code>.</li>
<li>The raw ProtoBuf files are stored in <code>_proto/hapi</code> (where <code>hapi</code> stands for
the Helm Application Programming Interface).</li>
<li>The Go files generated from the <code>proto</code> definitions are stored in <code>pkg/proto</code>.</li>
<li>The <code>scripts/</code> directory contains a number of utility scripts. Most of these
are used by the CI/CD pipeline.</li>
<li>The <code>rootfs/</code> folder is used for Docker-specific files.</li>
<li>The <code>docs/</code> folder is used for documentation and examples.</li>
</ul>

<p>Go dependencies are managed with
<a href="https://github.com/Masterminds/glide">Glide</a> and stored in the
<code>vendor/</code> directory.</p>

<h3 id="git-conventions">Git Conventions</h3>

<p>We use Git for our version control system. The <code>master</code> branch is the
home of the current development candidate. Releases are tagged.</p>

<p>We accept changes to the code via GitHub Pull Requests (PRs). One
workflow for doing this is as follows:</p>

<ol>
<li>Go to your <code>$GOPATH/src/k8s.io</code> directory and <code>git clone</code> the
<code>github.com/helm/helm</code> repository.</li>
<li>Fork that repository into your GitHub account</li>
<li>Add your repository as a remote for <code>$GOPATH/src/k8s.io/helm</code></li>
<li>Create a new working branch (<code>git checkout -b feat/my-feature</code>) and
do your work on that branch.</li>
<li>When you are ready for us to review, sign your commit, push your branch to GitHub, and
then open a new pull request with us.</li>
</ol>

<p>For Git commit messages, we follow the <a href="http://karma-runner.github.io/0.13/dev/git-commit-msg.html">Semantic Commit Messages</a>:</p>

<pre><code>fix(helm): add --foo flag to 'helm install'

When 'helm install --foo bar' is run, this will print &quot;foo&quot; in the
output regardless of the outcome of the installation.

Closes #1234
</code></pre>

<p>Common commit types:</p>

<ul>
<li>fix: Fix a bug or error</li>
<li>feat: Add a new feature</li>
<li>docs: Change documentation</li>
<li>test: Improve testing</li>
<li>ref: refactor existing code</li>
</ul>

<p>Common scopes:</p>

<ul>
<li>helm: The Helm CLI</li>
<li>tiller: The Tiller server</li>
<li>proto: Protobuf definitions</li>
<li>pkg/lint: The lint package. Follow a similar convention for any
package</li>
<li><code>*</code>: two or more scopes</li>
</ul>

<p>Read more:
- The <a href="./#https://github.com/deis/workflow/blob/master/src/contributing/submitting-a-pull-request">Deis Guidelines</a>
  were the inspiration for this section.
- Karma Runner <a href="http://karma-runner.github.io/0.13/dev/git-commit-msg.html">defines</a> the semantic commit message idea.</p>

<h3 id="go-conventions">Go Conventions</h3>

<p>We follow the Go coding style standards very closely. Typically, running
<code>go fmt</code> will make your code beautiful for you.</p>

<p>We also typically follow the conventions recommended by <code>go lint</code> and
<code>gometalinter</code>. Run <code>make test-style</code> to test the style conformance.
If you do not want to install all the linters from <code>gometalinter</code> into your
global Go environment, you can run <code>make docker-test-style</code> which will
run the same tests, but isolated within a docker container.</p>

<p>Read more:</p>

<ul>
<li>Effective Go <a href="https://golang.org/doc/effective_go.html#formatting">introduces formatting</a>.</li>
<li>The Go Wiki has a great article on <a href="https://github.com/golang/go/wiki/CodeReviewComments">formatting</a>.</li>
</ul>

<h3 id="protobuf-conventions">Protobuf Conventions</h3>

<p>Because this project is largely Go code, we format our Protobuf files as
closely to Go as possible. There are currently no real formatting rules
or guidelines for Protobuf, but as they emerge, we may opt to follow
those instead.</p>

<p>Standards:
- Tabs for indentation, not spaces.
- Spacing rules follow Go conventions (curly braces at line end, spaces
  around operators).</p>

<p>Conventions:
- Files should specify their package with <code>option go_package = &quot;...&quot;;</code>
- Comments should translate into good Go code comments (since <code>protoc</code>
  copies comments into the destination source code file).
- RPC functions are defined in the same file as their request/response
  messages.
- Deprecated RPCs, messages, and fields are marked deprecated in the comments (<code>// UpdateFoo
  DEPRECATED updates a foo.</code>).</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="charts">Charts</h1>

<p>Helm uses a packaging format called <em>charts</em>. A chart is a collection of files
that describe a related set of Kubernetes resources. A single chart
might be used to deploy something simple, like a memcached pod, or
something complex, like a full web app stack with HTTP servers,
databases, caches, and so on.</p>

<p>Charts are created as files laid out in a particular directory tree,
then they can be packaged into versioned archives to be deployed.</p>

<p>This document explains the chart format, and provides basic guidance for
building charts with Helm.</p>

<h2 id="the-chart-file-structure">The Chart File Structure</h2>

<p>A chart is organized as a collection of files inside of a directory. The
directory name is the name of the chart (without versioning information). Thus,
a chart describing WordPress would be stored in the <code>wordpress/</code> directory.</p>

<p>Inside of this directory, Helm will expect a structure that matches this:</p>

<pre><code>wordpress/
  Chart.yaml          # A YAML file containing information about the chart
  LICENSE             # OPTIONAL: A plain text file containing the license for the chart
  README.md           # OPTIONAL: A human-readable README file
  requirements.yaml   # OPTIONAL: A YAML file listing dependencies for the chart
  values.yaml         # The default configuration values for this chart
  charts/             # A directory containing any charts upon which this chart depends.
  templates/          # A directory of templates that, when combined with values,
                      # will generate valid Kubernetes manifest files.
  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes
</code></pre>

<p>Helm reserves use of the <code>charts/</code> and <code>templates/</code> directories, and of
the listed file names. Other files will be left as they are.</p>

<h2 id="the-chart-yaml-file">The Chart.yaml File</h2>

<p>The <code>Chart.yaml</code> file is required for a chart. It contains the following fields:</p>

<pre><code class="language-yaml">apiVersion: The chart API version, always &quot;v1&quot; (required)
name: The name of the chart (required)
version: A SemVer 2 version (required)
kubeVersion: A SemVer range of compatible Kubernetes versions (optional)
description: A single-sentence description of this project (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this project's home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
maintainers: # (optional)
  - name: The maintainer's name (required for each maintainer)
    email: The maintainer's email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
engine: gotpl # The name of the template engine (optional, defaults to gotpl)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). This needn't be SemVer.
deprecated: Whether this chart is deprecated (optional, boolean)
tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range: &quot;&gt;2.0.0&quot; (optional)
</code></pre>

<p>If you are familiar with the <code>Chart.yaml</code> file format for Helm Classic, you will
notice that fields specifying dependencies have been removed. That is because
the new Chart format expresses dependencies using the <code>charts/</code> directory.</p>

<p>Other fields will be silently ignored.</p>

<h3 id="charts-and-versioning">Charts and Versioning</h3>

<p>Every chart must have a version number. A version must follow the
<a href="http://semver.org/">SemVer 2</a> standard. Unlike Helm Classic, Kubernetes
Helm uses version numbers as release markers. Packages in repositories
are identified by name plus version.</p>

<p>For example, an <code>nginx</code> chart whose version field is set to <code>version:
1.2.3</code> will be named:</p>

<pre><code>nginx-1.2.3.tgz
</code></pre>

<p>More complex SemVer 2 names are also supported, such as
<code>version: 1.2.3-alpha.1+ef365</code>. But non-SemVer names are explicitly
disallowed by the system.</p>

<p><strong>NOTE:</strong> Whereas Helm Classic and Deployment Manager were both
very GitHub oriented when it came to charts, Kubernetes Helm does not
rely upon or require GitHub or even Git. Consequently, it does not use
Git SHAs for versioning at all.</p>

<p>The <code>version</code> field inside of the <code>Chart.yaml</code> is used by many of the
Helm tools, including the CLI and the Tiller server. When generating a
package, the <code>helm package</code> command will use the version that it finds
in the <code>Chart.yaml</code> as a token in the package name. The system assumes
that the version number in the chart package name matches the version number in
the <code>Chart.yaml</code>. Failure to meet this assumption will cause an error.</p>

<h3 id="the-appversion-field">The appVersion field</h3>

<p>Note that the <code>appVersion</code> field is not related to the <code>version</code> field. It is
a way of specifying the version of the application. For example, the <code>drupal</code>
chart may have an <code>appVersion: 8.2.1</code>, indicating that the version of Drupal
included in the chart (by default) is <code>8.2.1</code>. This field is informational, and
has no impact on chart version calculations.</p>

<h3 id="deprecating-charts">Deprecating Charts</h3>

<p>When managing charts in a Chart Repository, it is sometimes necessary to
deprecate a chart. The optional <code>deprecated</code> field in <code>Chart.yaml</code> can be used
to mark a chart as deprecated. If the <strong>latest</strong> version of a chart in the
repository is marked as deprecated, then the chart as a whole is considered to
be deprecated. The chart name can later be reused by publishing a newer version
that is not marked as deprecated. The workflow for deprecating charts, as
followed by the <a href="https://github.com/helm/charts">helm/charts</a>
project is:</p>

<ul>
<li>Update chart&rsquo;s <code>Chart.yaml</code> to mark the chart as deprecated, bumping the version</li>
<li>Release the new chart version in the Chart Repository</li>
<li>Remove the chart from the source repository (e.g. git)</li>
</ul>

<h2 id="chart-license-readme-and-notes">Chart LICENSE, README and NOTES</h2>

<p>Charts can also contain files that describe the installation, configuration, usage and license of a
chart.</p>

<p>A LICENSE is a plain text file containing the <a href="https://en.wikipedia.org/wiki/Software_license">license</a>
for the chart. The chart can contain a license as it may have programming logic in the templates and
would therefore not be configuration only. There can also be separate license(s) for the application
installed by the chart, if required.</p>

<p>A README for a chart should be formatted in Markdown (README.md), and should generally
contain:</p>

<ul>
<li>A description of the application or service the chart provides</li>
<li>Any prerequisites or requirements to run the chart</li>
<li>Descriptions of options in <code>values.yaml</code> and default values</li>
<li>Any other information that may be relevant to the installation or configuration of the chart</li>
</ul>

<p>The chart can also contain a short plain text <code>templates/NOTES.txt</code> file that will be printed out
after installation, and when viewing the status of a release. This file is evaluated as a
<a href="#templates-and-values">template</a>, and can be used to display usage notes, next steps, or any other
information relevant to a release of the chart. For example, instructions could be provided for
connecting to a database, or accessing a web UI. Since this file is printed to STDOUT when running
<code>helm install</code> or <code>helm status</code>, it is recommended to keep the content brief and point to the README
for greater detail.</p>

<h2 id="chart-dependencies">Chart Dependencies</h2>

<p>In Helm, one chart may depend on any number of other charts.
These dependencies can be dynamically linked through the <code>requirements.yaml</code>
file or brought in to the <code>charts/</code> directory and managed manually.</p>

<p>Although manually managing your dependencies has a few advantages some teams need,
the preferred method of declaring dependencies is by using a
<code>requirements.yaml</code> file inside of your chart.</p>

<p><strong>Note:</strong> The <code>dependencies:</code> section of the <code>Chart.yaml</code> from Helm
Classic has been completely removed.</p>

<h3 id="managing-dependencies-with-requirements-yaml">Managing Dependencies with <code>requirements.yaml</code></h3>

<p>A <code>requirements.yaml</code> file is a simple file for listing your
dependencies.</p>

<pre><code class="language-yaml">dependencies:
  - name: apache
    version: 1.2.3
    repository: http://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: http://another.example.com/charts
</code></pre>

<ul>
<li>The <code>name</code> field is the name of the chart you want.</li>
<li>The <code>version</code> field is the version of the chart you want.</li>
<li>The <code>repository</code> field is the full URL to the chart repository. Note
that you must also use <code>helm repo add</code> to add that repo locally.</li>
</ul>

<p>Once you have a dependencies file, you can run <code>helm dependency update</code>
and it will use your dependency file to download all the specified
charts into your <code>charts/</code> directory for you.</p>

<pre><code class="language-console">$ helm dep up foochart
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &quot;local&quot; chart repository
...Successfully got an update from the &quot;stable&quot; chart repository
...Successfully got an update from the &quot;example&quot; chart repository
...Successfully got an update from the &quot;another&quot; chart repository
Update Complete. Happy Helming!
Saving 2 charts
Downloading apache from repo http://example.com/charts
Downloading mysql from repo http://another.example.com/charts
</code></pre>

<p>When <code>helm dependency update</code> retrieves charts, it will store them as
chart archives in the <code>charts/</code> directory. So for the example above, one
would expect to see the following files in the charts directory:</p>

<pre><code>charts/
  apache-1.2.3.tgz
  mysql-3.2.1.tgz
</code></pre>

<p>Managing charts with <code>requirements.yaml</code> is a good way to easily keep
charts updated, and also share requirements information throughout a
team.</p>

<h4 id="alias-field-in-requirements-yaml">Alias field in requirements.yaml</h4>

<p>In addition to the other fields above, each requirements entry may contain
the optional field <code>alias</code>.</p>

<p>Adding an alias for a dependency chart would put
a chart in dependencies using alias as name of new dependency.</p>

<p>One can use <code>alias</code> in cases where they need to access a chart
with other name(s).</p>

<pre><code class="language-yaml"># parentchart/requirements.yaml
dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-1
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-2
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
</code></pre>

<p>In the above example we will get 3 dependencies in all for <code>parentchart</code></p>

<pre><code>subchart
new-subchart-1
new-subchart-2
</code></pre>

<p>The manual way of achieving this is by copy/pasting the same chart in the
<code>charts/</code> directory multiple times with different names.</p>

<h4 id="tags-and-condition-fields-in-requirements-yaml">Tags and Condition fields in requirements.yaml</h4>

<p>In addition to the other fields above, each requirements entry may contain
the optional fields <code>tags</code> and <code>condition</code>.</p>

<p>All charts are loaded by default. If <code>tags</code> or <code>condition</code> fields are present,
they will be evaluated and used to control loading for the chart(s) they are applied to.</p>

<p>Condition - The condition field holds one or more YAML paths (delimited by commas).
If this path exists in the top parent&rsquo;s values and resolves to a boolean value,
the chart will be enabled or disabled based on that boolean value.  Only the first
valid path found in the list is evaluated and if no paths exist then the condition has no effect.</p>

<p>Tags - The tags field is a YAML list of labels to associate with this chart.
In the top parent&rsquo;s values, all charts with tags can be enabled or disabled by
specifying the tag and a boolean value.</p>

<pre><code class="language-yaml"># parentchart/requirements.yaml
dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart1.enabled,global.subchart1.enabled
    tags:
      - front-end
      - subchart1

  - name: subchart2
    repository: http://localhost:10191
    version: 0.1.0
    condition: subchart2.enabled,global.subchart2.enabled
    tags:
      - back-end
      - subchart2

</code></pre>

<pre><code class="language-yaml"># parentchart/values.yaml

subchart1:
  enabled: true
tags:
  front-end: false
  back-end: true
</code></pre>

<p>In the above example all charts with the tag <code>front-end</code> would be disabled but since the
<code>subchart1.enabled</code> path evaluates to &lsquo;true&rsquo; in the parent&rsquo;s values, the condition will override the
<code>front-end</code> tag and <code>subchart1</code> will be enabled.</p>

<p>Since <code>subchart2</code> is tagged with <code>back-end</code> and that tag evaluates to <code>true</code>, <code>subchart2</code> will be
enabled. Also notes that although <code>subchart2</code> has a condition specified in <code>requirements.yaml</code>, there
is no corresponding path and value in the parent&rsquo;s values so that condition has no effect.</p>

<h5 id="using-the-cli-with-tags-and-conditions">Using the CLI with Tags and Conditions</h5>

<p>The <code>--set</code> parameter can be used as usual to alter tag and condition values.</p>

<pre><code>helm install --set tags.front-end=true --set subchart2.enabled=false
</code></pre>

<h5 id="tags-and-condition-resolution">Tags and Condition Resolution</h5>

<ul>
<li><strong>Conditions (when set in values) always override tags.</strong></li>
<li>The first condition path that exists wins and subsequent ones for that chart are ignored.</li>
<li>Tags are evaluated as &lsquo;if any of the chart&rsquo;s tags are true then enable the chart&rsquo;.</li>
<li>Tags and conditions values must be set in the top parent&rsquo;s values.</li>
<li>The <code>tags:</code> key in values must be a top level key. Globals and nested <code>tags:</code> tables
are not currently supported.</li>
</ul>

<h4 id="importing-child-values-via-requirements-yaml">Importing Child Values via requirements.yaml</h4>

<p>In some cases it is desirable to allow a child chart&rsquo;s values to propagate to the parent chart and be
shared as common defaults. An additional benefit of using the <code>exports</code> format is that it will enable future
tooling to introspect user-settable values.</p>

<p>The keys containing the values to be imported can be specified in the parent chart&rsquo;s <code>requirements.yaml</code> file
using a YAML list. Each item in the list is a key which is imported from the child chart&rsquo;s <code>exports</code> field.</p>

<p>To import values not contained in the <code>exports</code> key, use the <a href="#using-the-child-parent-format">child-parent</a> format.
Examples of both formats are described below.</p>

<h5 id="using-the-exports-format">Using the exports format</h5>

<p>If a child chart&rsquo;s <code>values.yaml</code> file contains an <code>exports</code> field at the root, its contents may be imported
directly into the parent&rsquo;s values by specifying the keys to import as in the example below:</p>

<pre><code class="language-yaml"># parent's requirements.yaml file
    ...
    import-values:
      - data
</code></pre>

<pre><code class="language-yaml"># child's values.yaml file
...
exports:
  data:
    myint: 99
</code></pre>

<p>Since we are specifying the key <code>data</code> in our import list, Helm looks in the <code>exports</code> field of the child
chart for <code>data</code> key and imports its contents.</p>

<p>The final parent values would contain our exported field:</p>

<pre><code class="language-yaml"># parent's values file
...
myint: 99

</code></pre>

<p>Please note the parent key <code>data</code> is not contained in the parent&rsquo;s final values. If you need to specify the
parent key, use the &lsquo;child-parent&rsquo; format.</p>

<h5 id="using-the-child-parent-format">Using the child-parent format</h5>

<p>To access values that are not contained in the <code>exports</code> key of the child chart&rsquo;s values, you will need to
specify the source key of the values to be imported (<code>child</code>) and the destination path in the parent chart&rsquo;s
values (<code>parent</code>).</p>

<p>The <code>import-values</code> in the example below instructs Helm to take any values found at <code>child:</code> path and copy them
to the parent&rsquo;s values at the path specified in <code>parent:</code></p>

<pre><code class="language-yaml"># parent's requirements.yaml file
dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    ...
    import-values:
      - child: default.data
        parent: myimports
</code></pre>

<p>In the above example, values found at <code>default.data</code> in the subchart1&rsquo;s values will be imported
to the <code>myimports</code> key in the parent chart&rsquo;s values as detailed below:</p>

<pre><code class="language-yaml"># parent's values.yaml file

myimports:
  myint: 0
  mybool: false
  mystring: &quot;helm rocks!&quot;

</code></pre>

<pre><code class="language-yaml"># subchart1's values.yaml file

default:
  data:
    myint: 999
    mybool: true

</code></pre>

<p>The parent chart&rsquo;s resulting values would be:</p>

<pre><code class="language-yaml"># parent's final values

myimports:
  myint: 999
  mybool: true
  mystring: &quot;helm rocks!&quot;

</code></pre>

<p>The parent&rsquo;s final values now contains the <code>myint</code> and <code>mybool</code> fields imported from subchart1.</p>

<h3 id="managing-dependencies-manually-via-the-charts-directory">Managing Dependencies manually via the <code>charts/</code> directory</h3>

<p>If more control over dependencies is desired, these dependencies can
be expressed explicitly by copying the dependency charts into the
<code>charts/</code> directory.</p>

<p>A dependency can be either a chart archive (<code>foo-1.2.3.tgz</code>) or an
unpacked chart directory. But its name cannot start with <code>_</code> or <code>.</code>.
Such files are ignored by the chart loader.</p>

<p>For example, if the WordPress chart depends on the Apache chart, the
Apache chart (of the correct version) is supplied in the WordPress
chart&rsquo;s <code>charts/</code> directory:</p>

<pre><code>wordpress:
  Chart.yaml
  requirements.yaml
  # ...
  charts/
    apache/
      Chart.yaml
      # ...
    mysql/
      Chart.yaml
      # ...
</code></pre>

<p>The example above shows how the WordPress chart expresses its dependency
on Apache and MySQL by including those charts inside of its <code>charts/</code>
directory.</p>

<p><strong>TIP:</strong> <em>To drop a dependency into your <code>charts/</code> directory, use the
<code>helm fetch</code> command</em></p>

<h3 id="operational-aspects-of-using-dependencies">Operational aspects of using dependencies</h3>

<p>The above sections explain how to specify chart dependencies, but how does this affect
chart installation using <code>helm install</code> and <code>helm upgrade</code>?</p>

<p>Suppose that a chart named &ldquo;A&rdquo; creates the following Kubernetes objects</p>

<ul>
<li>namespace &ldquo;A-Namespace&rdquo;</li>
<li>statefulset &ldquo;A-StatefulSet&rdquo;</li>
<li>service &ldquo;A-Service&rdquo;</li>
</ul>

<p>Furthermore, A is dependent on chart B that creates objects</p>

<ul>
<li>namespace &ldquo;B-Namespace&rdquo;</li>
<li>replicaset &ldquo;B-ReplicaSet&rdquo;</li>
<li>service &ldquo;B-Service&rdquo;</li>
</ul>

<p>After installation/upgrade of chart A a single Helm release is created/modified. The release will
create/update all of the above Kubernetes objects in the following order:</p>

<ul>
<li>A-Namespace</li>
<li>B-Namespace</li>
<li>A-StatefulSet</li>
<li>B-ReplicaSet</li>
<li>A-Service</li>
<li>B-Service</li>
</ul>

<p>This is because when Helm installs/upgrades charts,
the Kubernetes objects from the charts and all its dependencies are</p>

<ul>
<li>aggregrated into a single set; then</li>
<li>sorted by type followed by name; and then</li>
<li>created/updated in that order.</li>
</ul>

<p>Hence a single release is created with all the objects for the chart and its dependencies.</p>

<p>The install order of Kubernetes types is given by the enumeration InstallOrder in kind_sorter.go
(see <a href="https://github.com/helm/helm/blob/master/pkg/tiller/kind_sorter.go#L26">the Helm source file</a>).</p>

<h2 id="templates-and-values">Templates and Values</h2>

<p>Helm Chart templates are written in the
<a href="https://golang.org/pkg/text/template/">Go template language</a>, with the
addition of 50 or so add-on template
functions <a href="https://github.com/Masterminds/sprig">from the Sprig library</a> and a
few other <a href="./#chart-development-tips-and-tricks">specialized functions</a>.</p>

<p>All template files are stored in a chart&rsquo;s <code>templates/</code> folder. When
Helm renders the charts, it will pass every file in that directory
through the template engine.</p>

<p>Values for the templates are supplied two ways:</p>

<ul>
<li>Chart developers may supply a file called <code>values.yaml</code> inside of a
chart. This file can contain default values.</li>
<li>Chart users may supply a YAML file that contains values. This can be
provided on the command line with <code>helm install</code>.</li>
</ul>

<p>When a user supplies custom values, these values will override the
values in the chart&rsquo;s <code>values.yaml</code> file.</p>

<h3 id="template-files">Template Files</h3>

<p>Template files follow the standard conventions for writing Go templates
(see <a href="https://golang.org/pkg/text/template/">the text/template Go package documentation</a>
for details).
An example template file might look something like this:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &quot;minio&quot; .Values.storage}}
</code></pre>

<p>The above example, based loosely on <a href="https://github.com/deis/charts">https://github.com/deis/charts</a>, is a template for a Kubernetes replication controller.
It can use the following four template values (usually defined in a
<code>values.yaml</code> file):</p>

<ul>
<li><code>imageRegistry</code>: The source registry for the Docker image.</li>
<li><code>dockerTag</code>: The tag for the docker image.</li>
<li><code>pullPolicy</code>: The Kubernetes pull policy.</li>
<li><code>storage</code>: The storage backend, whose default is set to <code>&quot;minio&quot;</code></li>
</ul>

<p>All of these values are defined by the template author. Helm does not
require or dictate parameters.</p>

<p>To see many working charts, check out the <a href="https://github.com/helm/charts">Helm Charts
project</a></p>

<h3 id="predefined-values">Predefined Values</h3>

<p>Values that are supplied via a <code>values.yaml</code> file (or via the <code>--set</code>
flag) are accessible from the <code>.Values</code> object in a template. But there
are other pre-defined pieces of data you can access in your templates.</p>

<p>The following values are pre-defined, are available to every template, and
cannot be overridden. As with all values, the names are <em>case
sensitive</em>.</p>

<ul>
<li><code>Release.Name</code>: The name of the release (not the chart)</li>
<li><code>Release.Time</code>: The time the chart release was last updated. This will
match the <code>Last Released</code> time on a Release object.</li>
<li><code>Release.Namespace</code>: The namespace the chart was released to.</li>
<li><code>Release.Service</code>: The service that conducted the release. Usually
this is <code>Tiller</code>.</li>
<li><code>Release.IsUpgrade</code>: This is set to true if the current operation is an upgrade or rollback.</li>
<li><code>Release.IsInstall</code>: This is set to true if the current operation is an
install.</li>
<li><code>Release.Revision</code>: The revision number. It begins at 1, and increments with
each <code>helm upgrade</code>.</li>
<li><code>Chart</code>: The contents of the <code>Chart.yaml</code>. Thus, the chart version is
obtainable as <code>Chart.Version</code> and the maintainers are in
<code>Chart.Maintainers</code>.</li>
<li><code>Files</code>: A map-like object containing all non-special files in the chart. This
will not give you access to templates, but will give you access to additional
files that are present (unless they are excluded using <code>.helmignore</code>). Files can be
accessed using <code>{{index .Files &quot;file.name&quot;}}</code> or using the <code>{{.Files.Get name}}</code> or
<code>{{.Files.GetString name}}</code> functions. You can also access the contents of the file
as <code>[]byte</code> using <code>{{.Files.GetBytes}}</code></li>
<li><code>Capabilities</code>: A map-like object that contains information about the versions
of Kubernetes (<code>{{.Capabilities.KubeVersion}}</code>, Tiller
(<code>{{.Capabilities.TillerVersion}}</code>, and the supported Kubernetes API versions
(<code>{{.Capabilities.APIVersions.Has &quot;batch/v1&quot;</code>)</li>
</ul>

<p><strong>NOTE:</strong> Any unknown Chart.yaml fields will be dropped. They will not
be accessible inside of the <code>Chart</code> object. Thus, Chart.yaml cannot be
used to pass arbitrarily structured data into the template. The values
file can be used for that, though.</p>

<h3 id="values-files">Values files</h3>

<p>Considering the template in the previous section, a <code>values.yaml</code> file
that supplies the necessary values would look like this:</p>

<pre><code class="language-yaml">imageRegistry: &quot;quay.io/deis&quot;
dockerTag: &quot;latest&quot;
pullPolicy: &quot;Always&quot;
storage: &quot;s3&quot;
</code></pre>

<p>A values file is formatted in YAML. A chart may include a default
<code>values.yaml</code> file. The Helm install command allows a user to override
values by supplying additional YAML values:</p>

<pre><code class="language-console">$ helm install --values=myvals.yaml wordpress
</code></pre>

<p>When values are passed in this way, they will be merged into the default
values file. For example, consider a <code>myvals.yaml</code> file that looks like
this:</p>

<pre><code class="language-yaml">storage: &quot;gcs&quot;
</code></pre>

<p>When this is merged with the <code>values.yaml</code> in the chart, the resulting
generated content will be:</p>

<pre><code class="language-yaml">imageRegistry: &quot;quay.io/deis&quot;
dockerTag: &quot;latest&quot;
pullPolicy: &quot;Always&quot;
storage: &quot;gcs&quot;
</code></pre>

<p>Note that only the last field was overridden.</p>

<p><strong>NOTE:</strong> The default values file included inside of a chart <em>must</em> be named
<code>values.yaml</code>. But files specified on the command line can be named
anything.</p>

<p><strong>NOTE:</strong> If the <code>--set</code> flag is used on <code>helm install</code> or <code>helm upgrade</code>, those
values are simply converted to YAML on the client side.</p>

<p><strong>NOTE:</strong> If any required entries in the values file exist, they can be declared
as required in the chart template by using the <a href="./#chart-development-tips-and-tricks">&lsquo;required&rsquo; function</a></p>

<p>Any of these values are then accessible inside of templates using the
<code>.Values</code> object:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    app.kubernetes.io/managed-by: deis
spec:
  replicas: 1
  selector:
    app.kubernetes.io/name: deis-database
  template:
    metadata:
      labels:
        app.kubernetes.io/name: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &quot;minio&quot; .Values.storage}}

</code></pre>

<h3 id="scope-dependencies-and-values">Scope, Dependencies, and Values</h3>

<p>Values files can declare values for the top-level chart, as well as for
any of the charts that are included in that chart&rsquo;s <code>charts/</code> directory.
Or, to phrase it differently, a values file can supply values to the
chart as well as to any of its dependencies. For example, the
demonstration WordPress chart above has both <code>mysql</code> and <code>apache</code> as
dependencies. The values file could supply values to all of these
components:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

mysql:
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  port: 8080 # Passed to Apache
</code></pre>

<p>Charts at a higher level have access to all of the variables defined
beneath. So the WordPress chart can access the MySQL password as
<code>.Values.mysql.password</code>. But lower level charts cannot access things in
parent charts, so MySQL will not be able to access the <code>title</code> property. Nor,
for that matter, can it access <code>apache.port</code>.</p>

<p>Values are namespaced, but namespaces are pruned. So for the WordPress
chart, it can access the MySQL password field as <code>.Values.mysql.password</code>. But
for the MySQL chart, the scope of the values has been reduced and the
namespace prefix removed, so it will see the password field simply as
<code>.Values.password</code>.</p>

<h4 id="global-values">Global Values</h4>

<p>As of 2.0.0-Alpha.2, Helm supports special &ldquo;global&rdquo; value. Consider
this modified version of the previous example:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  port: 8080 # Passed to Apache
</code></pre>

<p>The above adds a <code>global</code> section with the value <code>app: MyWordPress</code>.
This value is available to <em>all</em> charts as <code>.Values.global.app</code>.</p>

<p>For example, the <code>mysql</code> templates may access <code>app</code> as <code>{{.Values.global.app}}</code>, and
so can the <code>apache</code> chart. Effectively, the values file above is
regenerated like this:</p>

<pre><code class="language-yaml">title: &quot;My WordPress Site&quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  global:
    app: MyWordPress
  max_connections: 100 # Sent to MySQL
  password: &quot;secret&quot;

apache:
  global:
    app: MyWordPress
  port: 8080 # Passed to Apache
</code></pre>

<p>This provides a way of sharing one top-level variable with all
subcharts, which is useful for things like setting <code>metadata</code> properties
like labels.</p>

<p>If a subchart declares a global variable, that global will be passed
<em>downward</em> (to the subchart&rsquo;s subcharts), but not <em>upward</em> to the parent
chart. There is no way for a subchart to influence the values of the
parent chart.</p>

<p>Also, global variables of parent charts take precedence over the global variables from subcharts.</p>

<h3 id="references">References</h3>

<p>When it comes to writing templates and values files, there are several
standard references that will help you out.</p>

<ul>
<li><a href="https://godoc.org/text/template">Go templates</a></li>
<li><a href="https://godoc.org/github.com/Masterminds/sprig">Extra template functions</a></li>
<li><a href="http://yaml.org/spec/">The YAML format</a></li>
</ul>

<h2 id="using-helm-to-manage-charts">Using Helm to Manage Charts</h2>

<p>The <code>helm</code> tool has several commands for working with charts.</p>

<p>It can create a new chart for you:</p>

<pre><code class="language-console">$ helm create mychart
Created mychart/
</code></pre>

<p>Once you have edited a chart, <code>helm</code> can package it into a chart archive
for you:</p>

<pre><code class="language-console">$ helm package mychart
Archived mychart-0.1.-.tgz
</code></pre>

<p>You can also use <code>helm</code> to help you find issues with your chart&rsquo;s
formatting or information:</p>

<pre><code class="language-console">$ helm lint mychart
No issues found
</code></pre>

<h2 id="chart-repositories">Chart Repositories</h2>

<p>A <em>chart repository</em> is an HTTP server that houses one or more packaged
charts. While <code>helm</code> can be used to manage local chart directories, when
it comes to sharing charts, the preferred mechanism is a chart
repository.</p>

<p>Any HTTP server that can serve YAML files and tar files and can answer
GET requests can be used as a repository server.</p>

<p>Helm comes with built-in package server for developer testing (<code>helm
serve</code>). The Helm team has tested other servers, including Google Cloud
Storage with website mode enabled, and S3 with website mode enabled.</p>

<p>A repository is characterized primarily by the presence of a special
file called <code>index.yaml</code> that has a list of all of the packages supplied
by the repository, together with metadata that allows retrieving and
verifying those packages.</p>

<p>On the client side, repositories are managed with the <code>helm repo</code>
commands. However, Helm does not provide tools for uploading charts to
remote repository servers. This is because doing so would add
substantial requirements to an implementing server, and thus raise the
barrier for setting up a repository.</p>

<h2 id="chart-starter-packs">Chart Starter Packs</h2>

<p>The <code>helm create</code> command takes an optional <code>--starter</code> option that lets you
specify a &ldquo;starter chart&rdquo;.</p>

<p>Starters are just regular charts, but are located in <code>$HELM_HOME/starters</code>.
As a chart developer, you may author charts that are specifically designed
to be used as starters. Such charts should be designed with the following
considerations in mind:</p>

<ul>
<li>The <code>Chart.yaml</code> will be overwritten by the generator.</li>
<li>Users will expect to modify such a chart&rsquo;s contents, so documentation
should indicate how users can do so.</li>
<li>All occurrences of <code>&lt;CHARTNAME&gt;</code> in files within the <code>templates</code> directory
will be replaced with the specified chart name so that starter charts can be
used as templates. Additionally, occurrences of <code>&lt;CHARTNAME&gt;</code> in
<code>values.yaml</code> will also be replaced.</li>
</ul>

<p>Currently the only way to add a chart to <code>$HELM_HOME/starters</code> is to manually
copy it there. In your chart&rsquo;s documentation, you may want to explain that
process.</p>

<h1 id="hooks">Hooks</h1>

<p>Helm provides a <em>hook</em> mechanism to allow chart developers to intervene
at certain points in a release&rsquo;s life cycle. For example, you can use
hooks to:</p>

<ul>
<li>Load a ConfigMap or Secret during install before any other charts are
loaded.</li>
<li>Execute a Job to back up a database before installing a new chart,
and then execute a second job after the upgrade in order to restore
data.</li>
<li>Run a Job before deleting a release to gracefully take a service out
of rotation before removing it.</li>
</ul>

<p>Hooks work like regular templates, but they have special annotations
that cause Helm to utilize them differently. In this section, we cover
the basic usage pattern for hooks.</p>

<p>Hooks are declared as an annotation in the metadata section of a manifest:</p>

<pre><code class="language-yaml">apiVersion: ...
kind: ....
metadata:
  annotations:
    &quot;helm.sh/hook&quot;: &quot;pre-install&quot;
# ...
</code></pre>

<h2 id="the-available-hooks">The Available Hooks</h2>

<p>The following hooks are defined:</p>

<ul>
<li>pre-install: Executes after templates are rendered, but before any
resources are created in Kubernetes.</li>
<li>post-install: Executes after all resources are loaded into Kubernetes</li>
<li>pre-delete: Executes on a deletion request before any resources are
deleted from Kubernetes.</li>
<li>post-delete: Executes on a deletion request after all of the release&rsquo;s
resources have been deleted.</li>
<li>pre-upgrade: Executes on an upgrade request after templates are
rendered, but before any resources are loaded into Kubernetes (e.g.
before a Kubernetes apply operation).</li>
<li>post-upgrade: Executes on an upgrade after all resources have been
upgraded.</li>
<li>pre-rollback: Executes on a rollback request after templates are
rendered, but before any resources have been rolled back.</li>
<li>post-rollback: Executes on a rollback request after all resources
have been modified.</li>
<li>crd-install: Adds CRD resources before any other checks are run. This is used
only on CRD definitions that are used by other manifests in the chart.</li>
</ul>

<h2 id="hooks-and-the-release-lifecycle">Hooks and the Release Lifecycle</h2>

<p>Hooks allow you, the chart developer, an opportunity to perform
operations at strategic points in a release lifecycle. For example,
consider the lifecycle for a <code>helm install</code>. By default, the lifecycle
looks like this:</p>

<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders the <code>foo</code> templates</li>
<li>Tiller loads the resulting resources into Kubernetes</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>

<p>Helm defines two hooks for the <code>install</code> lifecycle: <code>pre-install</code> and
<code>post-install</code>. If the developer of the <code>foo</code> chart implements both
hooks, the lifecycle is altered like this:</p>

<ol>
<li>User runs <code>helm install foo</code></li>
<li>Chart is loaded into Tiller</li>
<li>After some verification, Tiller renders the <code>foo</code> templates</li>
<li>Tiller prepares to execute the <code>pre-install</code> hooks (loading hook resources into
Kubernetes)</li>
<li>Tiller sorts hooks by weight (assigning a weight of 0 by default) and by name for those hooks with the same weight in ascending order.</li>
<li>Tiller then loads the hook with the lowest weight first (negative to positive)</li>
<li>Tiller waits until the hook is &ldquo;Ready&rdquo; (except for CRDs)</li>
<li>Tiller loads the resulting resources into Kubernetes. Note that if the <code>--wait</code>
flag is set, Tiller will wait until all resources are in a ready state
and will not run the <code>post-install</code> hook until they are ready.</li>
<li>Tiller executes the <code>post-install</code> hook (loading hook resources)</li>
<li>Tiller waits until the hook is &ldquo;Ready&rdquo;</li>
<li>Tiller returns the release name (and other data) to the client</li>
<li>The client exits</li>
</ol>

<p>What does it mean to wait until a hook is ready? This depends on the
resource declared in the hook. If the resources is a <code>Job</code> kind, Tiller
will wait until the job successfully runs to completion. And if the job
fails, the release will fail. This is a <em>blocking operation</em>, so the
Helm client will pause while the Job is run.</p>

<p>For all other kinds, as soon as Kubernetes marks the resource as loaded
(added or updated), the resource is considered &ldquo;Ready&rdquo;. When many
resources are declared in a hook, the resources are executed serially. If they
have hook weights (see below), they are executed in weighted order. Otherwise,
ordering is not guaranteed. (In Helm 2.3.0 and after, they are sorted
alphabetically. That behavior, though, is not considered binding and could change
in the future.) It is considered good practice to add a hook weight, and set it
to <code>0</code> if weight is not important.</p>

<h3 id="hook-resources-are-not-managed-with-corresponding-releases">Hook resources are not managed with corresponding releases</h3>

<p>The resources that a hook creates are not tracked or managed as part of the
release. Once Tiller verifies that the hook has reached its ready state, it
will leave the hook resource alone.</p>

<p>Practically speaking, this means that if you create resources in a hook, you
cannot rely upon <code>helm delete</code> to remove the resources. To destroy such
resources, you need to either write code to perform this operation in a <code>pre-delete</code>
or <code>post-delete</code> hook or add <code>&quot;helm.sh/hook-delete-policy&quot;</code> annotation to the hook template file.</p>

<h2 id="writing-a-hook">Writing a Hook</h2>

<p>Hooks are just Kubernetes manifest files with special annotations in the
<code>metadata</code> section. Because they are template files, you can use all of
the normal template features, including reading <code>.Values</code>, <code>.Release</code>,
and <code>.Template</code>.</p>

<p>For example, this template, stored in <code>templates/post-install-job.yaml</code>,
declares a job to be run on <code>post-install</code>:</p>

<pre><code class="language-yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: &quot;{{.Release.Name}}&quot;
  labels:
    app.kubernetes.io/managed-by: {{.Release.Service | quote }}
    app.kubernetes.io/instance: {{.Release.Name | quote }}
    helm.sh/chart: &quot;{{.Chart.Name}}-{{.Chart.Version}}&quot;
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    &quot;helm.sh/hook&quot;: post-install
    &quot;helm.sh/hook-weight&quot;: &quot;-5&quot;
    &quot;helm.sh/hook-delete-policy&quot;: hook-succeeded
spec:
  template:
    metadata:
      name: &quot;{{.Release.Name}}&quot;
      labels:
        app.kubernetes.io/managed-by: {{.Release.Service | quote }}
        app.kubernetes.io/instance: {{.Release.Name | quote }}
        helm.sh/chart: &quot;{{.Chart.Name}}-{{.Chart.Version}}&quot;
    spec:
      restartPolicy: Never
      containers:
      - name: post-install-job
        image: &quot;alpine:3.3&quot;
        command: [&quot;/bin/sleep&quot;,&quot;{{default &quot;10&quot; .Values.sleepyTime}}&quot;]

</code></pre>

<p>What makes this template a hook is the annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook&quot;: post-install
</code></pre>

<p>One resource can implement multiple hooks:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook&quot;: post-install,post-upgrade
</code></pre>

<p>Similarly, there is no limit to the number of different resources that
may implement a given hook. For example, one could declare both a secret
and a config map as a pre-install hook.</p>

<p>When subcharts declare hooks, those are also evaluated. There is no way
for a top-level chart to disable the hooks declared by subcharts.</p>

<p>It is possible to define a weight for a hook which will help build a
deterministic executing order. Weights are defined using the following annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook-weight&quot;: &quot;5&quot;
</code></pre>

<p>Hook weights can be positive or negative numbers but must be represented as
strings. When Tiller starts the execution cycle of hooks of a particular kind (ex. the <code>pre-install</code> hooks or <code>post-install</code> hooks, etc.) it will sort those hooks in ascending order.</p>

<p>It is also possible to define policies that determine when to delete corresponding hook resources. Hook deletion policies are defined using the following annotation:</p>

<pre><code>  annotations:
    &quot;helm.sh/hook-delete-policy&quot;: hook-succeeded
</code></pre>

<p>You can choose one or more defined annotation values:</p>

<ul>
<li><code>&quot;hook-succeeded&quot;</code> specifies Tiller should delete the hook after the hook is successfully executed.</li>
<li><code>&quot;hook-failed&quot;</code> specifies Tiller should delete the hook if the hook failed during execution.</li>
<li><code>&quot;before-hook-creation&quot;</code> specifies Tiller should delete the previous hook before the new hook is launched.</li>
</ul>

<h3 id="defining-a-crd-with-the-crd-install-hook">Defining a CRD with the <code>crd-install</code> Hook</h3>

<p>Custom Resource Definitions (CRDs) are a special kind in Kubernetes. They provide
a way to define other kinds.</p>

<p>On occasion, a chart needs to both define a kind and then use it. This is done
with the <code>crd-install</code> hook.</p>

<p>The <code>crd-install</code> hook is executed very early during an installation, before
the rest of the manifests are verified. CRDs can be annotated with this hook so
that they are installed before any instances of that CRD are referenced. In this
way, when verification happens later, the CRDs will be available.</p>

<p>Here is an example of defining a CRD with a hook, and an instance of the CRD:</p>

<pre><code class="language-yaml">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com
  annotations:
    &quot;helm.sh/hook&quot;: crd-install
spec:
  group: stable.example.com
  version: v1
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
    shortNames:
    - ct
</code></pre>

<p>And:</p>

<pre><code class="language-yaml">apiVersion: stable.example.com/v1
kind: CronTab
metadata:
  name: {{ .Release.Name }}-inst
</code></pre>

<p>Both of these can now be in the same chart, provided that the CRD is correctly
annotated.</p>

<h3 id="automatically-delete-hook-from-previous-release">Automatically delete hook from previous release</h3>

<p>When helm release being updated it is possible, that hook resource already exists in cluster. By default helm will try to create resource and fail with <code>&quot;... already exists&quot;</code> error.</p>

<p>One might choose <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;before-hook-creation&quot;</code> over <code>&quot;helm.sh/hook-delete-policy&quot;: &quot;hook-succeeded,hook-failed&quot;</code> because:</p>

<ul>
<li>It is convenient to keep failed hook job resource in kubernetes for example for manual debug.</li>
<li>It may be necessary to keep succeeded hook resource in kubernetes for some reason.</li>
<li>At the same time it is not desirable to do manual resource deletion before helm release upgrade.</li>
</ul>

<p><code>&quot;helm.sh/hook-delete-policy&quot;: &quot;before-hook-creation&quot;</code> annotation on hook causes tiller to remove the hook from previous release if there is one before the new hook is launched and can be used with another policy.</p>

<h1 id="chart-development-tips-and-tricks">Chart Development Tips and Tricks</h1>

<p>This guide covers some of the tips and tricks Helm chart developers have
learned while building production-quality charts.</p>

<h2 id="know-your-template-functions">Know Your Template Functions</h2>

<p>Helm uses <a href="https://godoc.org/text/template">Go templates</a> for templating
your resource files. While Go ships several built-in functions, we have
added many others.</p>

<p>First, we added almost all of the functions in the
<a href="https://godoc.org/github.com/Masterminds/sprig">Sprig library</a>. We removed two
for security reasons: <code>env</code> and <code>expandenv</code> (which would have given chart authors
access to Tiller&rsquo;s environment).</p>

<p>We also added two special template functions: <code>include</code> and <code>required</code>. The <code>include</code>
function allows you to bring in another template, and then pass the results to other
template functions.</p>

<p>For example, this template snippet includes a template called <code>mytpl</code>, then
lowercases the result, then wraps that in double quotes.</p>

<pre><code class="language-yaml">value: {{ include &quot;mytpl&quot; . | lower | quote }}
</code></pre>

<p>The <code>required</code> function allows you to declare a particular
values entry as required for template rendering. If the value is empty, the template
rendering will fail with a user submitted error message.</p>

<p>The following example of the <code>required</code> function declares an entry for .Values.who
is required, and will print an error message when that entry is missing:</p>

<pre><code class="language-yaml">value: {{ required &quot;A valid .Values.who entry required!&quot; .Values.who }}
</code></pre>

<h2 id="quote-strings-don-t-quote-integers">Quote Strings, Don&rsquo;t Quote Integers</h2>

<p>When you are working with string data, you are always safer quoting the
strings than leaving them as bare words:</p>

<pre><code class="language-yaml">name: {{ .Values.MyName | quote }}
</code></pre>

<p>But when working with integers <em>do not quote the values.</em> That can, in
many cases, cause parsing errors inside of Kubernetes.</p>

<pre><code class="language-yaml">port: {{ .Values.Port }}
</code></pre>

<p>This remark does not apply to env variables values which are expected to be string, even if they represent integers:</p>

<pre><code class="language-yaml">env:
  -name: HOST
    value: &quot;http://host&quot;
  -name: PORT
    value: &quot;1234&quot;
</code></pre>

<h2 id="using-the-include-function">Using the &lsquo;include&rsquo; Function</h2>

<p>Go provides a way of including one template in another using a built-in
<code>template</code> directive. However, the built-in function cannot be used in
Go template pipelines.</p>

<p>To make it possible to include a template, and then perform an operation
on that template&rsquo;s output, Helm has a special <code>include</code> function:</p>

<pre><code class="language-gotpl">{{- include &quot;toYaml&quot; $value | nindent 2 }}
</code></pre>

<p>The above includes a template called <code>toYaml</code>, passes it <code>$value</code>, and
then passes the output of that template to the <code>nindent</code> function. Using
the <code>{{- ... | nindent _n_ }}</code> pattern makes it easier to read the <code>include</code>
in context, because it chomps the whitespace to the left (including the
previous newline), then the <code>nindent</code> re-adds the newline and indents
the included content by the requested amount.</p>

<p>Because YAML ascribes significance to indentation levels and whitespace,
this is one great way to include snippets of code, but handle
indentation in a relevant context.</p>

<h2 id="using-the-required-function">Using the &lsquo;required&rsquo; function</h2>

<p>Go provides a way for setting template options to control behavior
when a map is indexed with a key that&rsquo;s not present in the map. This
is typically set with template.Options(&ldquo;missingkey=option&rdquo;), where option
can be default, zero, or error. While setting this option to error will
stop execution with an error, this would apply to every missing key in the
map. There may be situations where a chart developer wants to enforce this
behavior for select values in the values.yml file.</p>

<p>The <code>required</code> function gives developers the ability to declare a value entry
as required for template rendering. If the entry is empty in values.yml, the
template will not render and will return an error message supplied by the
developer.</p>

<p>For example:</p>

<pre><code class="language-gotpl">{{ required &quot;A valid foo is required!&quot; .Values.foo }}
</code></pre>

<p>The above will render the template when .Values.foo is defined, but will fail
to render and exit when .Values.foo is undefined.</p>

<h2 id="using-the-tpl-function">Using the &lsquo;tpl&rsquo; Function</h2>

<p>The <code>tpl</code> function allows developers to evaluate strings as templates inside a template.
This is useful to pass a template string as a value to a chart or render external configuration files.
Syntax: <code>{{ tpl TEMPLATE_STRING VALUES }}</code></p>

<p>Examples:</p>

<pre><code class="language-yaml"># values
template: &quot;{{ .Values.name }}&quot;
name: &quot;Tom&quot;

# template
{{ tpl .Values.template . }}

# output
Tom
</code></pre>

<p>Rendering a external configuration file:</p>

<pre><code class="language-yaml"># external configuration file conf/app.conf
firstName={{ .Values.firstName }}
lastName={{ .Values.lastName }}

# values
firstName: Peter
lastName: Parker

# template
{{ tpl (.Files.Get &quot;conf/app.conf&quot;) . }}

# output
firstName=Peter
lastName=Parker
</code></pre>

<h2 id="creating-image-pull-secrets">Creating Image Pull Secrets</h2>

<p>Image pull secrets are essentially a combination of <em>registry</em>, <em>username</em>, and <em>password</em>. You may need them in an application you are deploying, but to create them requires running <em>base64</em> a couple of times. We can write a helper template to compose the Docker configuration file for use as the Secret&rsquo;s payload. Here is an example:</p>

<p>First, assume that the credentials are defined in the <code>values.yaml</code> file like so:</p>

<pre><code class="language-yaml">imageCredentials:
  registry: quay.io
  username: someone
  password: sillyness
</code></pre>

<p>We then define our helper template as follows:</p>

<pre><code class="language-gotpl">{{- define &quot;imagePullSecret&quot; }}
{{- printf &quot;{\&quot;auths\&quot;: {\&quot;%s\&quot;: {\&quot;auth\&quot;: \&quot;%s\&quot;}}}&quot; .Values.imageCredentials.registry (printf &quot;%s:%s&quot; .Values.imageCredentials.username .Values.imageCredentials.password | b64enc) | b64enc }}
{{- end }}
</code></pre>

<p>Finally, we use the helper template in a larger template to create the Secret manifest:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ template &quot;imagePullSecret&quot; . }}
</code></pre>

<h2 id="automatically-roll-deployments-when-configmaps-or-secrets-change">Automatically Roll Deployments When ConfigMaps or Secrets change</h2>

<p>Often times configmaps or secrets are injected as configuration
files in containers.
Depending on the application a restart may be required should those
be updated with a subsequent <code>helm upgrade</code>, but if the
deployment spec itself didn&rsquo;t change the application keeps running
with the old configuration resulting in an inconsistent deployment.</p>

<p>The <code>sha256sum</code> function can be used to ensure a deployment&rsquo;s
annotation section is updated if another file changes:</p>

<pre><code class="language-yaml">kind: Deployment
spec:
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath &quot;/configmap.yaml&quot;) . | sha256sum }}
[...]
</code></pre>

<p>See also the <code>helm upgrade --recreate-pods</code> flag for a slightly
different way of addressing this issue.</p>

<h2 id="tell-tiller-not-to-delete-a-resource">Tell Tiller Not To Delete a Resource</h2>

<p>Sometimes there are resources that should not be deleted when Helm runs a
<code>helm delete</code>. Chart developers can add an annotation to a resource to prevent
it from being deleted.</p>

<pre><code class="language-yaml">kind: Secret
metadata:
  annotations:
    &quot;helm.sh/resource-policy&quot;: keep
[...]
</code></pre>

<p>(Quotation marks are required)</p>

<p>The annotation <code>&quot;helm.sh/resource-policy&quot;: keep</code> instructs Tiller to skip this
resource during a <code>helm delete</code> operation. <em>However</em>, this resource becomes
orphaned. Helm will no longer manage it in any way. This can lead to problems
if using <code>helm install --replace</code> on a release that has already been deleted, but
has kept resources.</p>

<h2 id="using-partials-and-template-includes">Using &ldquo;Partials&rdquo; and Template Includes</h2>

<p>Sometimes you want to create some reusable parts in your chart, whether
they&rsquo;re blocks or template partials. And often, it&rsquo;s cleaner to keep
these in their own files.</p>

<p>In the <code>templates/</code> directory, any file that begins with an
underscore(<code>_</code>) is not expected to output a Kubernetes manifest file. So
by convention, helper templates and partials are placed in a
<code>_helpers.tpl</code> file.</p>

<h2 id="complex-charts-with-many-dependencies">Complex Charts with Many Dependencies</h2>

<p>Many of the charts in the <a href="https://github.com/helm/charts">official charts repository</a>
are &ldquo;building blocks&rdquo; for creating more advanced applications. But charts may be
used to create instances of large-scale applications. In such cases, a single
umbrella chart may have multiple subcharts, each of which functions as a piece
of the whole.</p>

<p>The current best practice for composing a complex application from discrete parts
is to create a top-level umbrella chart that
exposes the global configurations, and then use the <code>charts/</code> subdirectory to
embed each of the components.</p>

<p>Two strong design patterns are illustrated by these projects:</p>

<p><strong>SAP&rsquo;s <a href="https://github.com/sapcc/openstack-helm">OpenStack chart</a>:</strong> This chart
installs a full OpenStack IaaS on Kubernetes. All of the charts are collected
together in one GitHub repository.</p>

<p><strong>Deis&rsquo;s <a href="https://github.com/deis/workflow/tree/master/charts/workflow">Workflow</a>:</strong>
This chart exposes the entire Deis PaaS system with one chart. But it&rsquo;s different
from the SAP chart in that this umbrella chart is built from each component, and
each component is tracked in a different Git repository. Check out the
<code>requirements.yaml</code> file to see how this chart is composed by their CI/CD
pipeline.</p>

<p>Both of these charts illustrate proven techniques for standing up complex environments
using Helm.</p>

<h2 id="yaml-is-a-superset-of-json">YAML is a Superset of JSON</h2>

<p>According to the YAML specification, YAML is a superset of JSON. That
means that any valid JSON structure ought to be valid in YAML.</p>

<p>This has an advantage: Sometimes template developers may find it easier
to express a datastructure with a JSON-like syntax rather than deal with
YAML&rsquo;s whitespace sensitivity.</p>

<p>As a best practice, templates should follow a YAML-like syntax <em>unless</em>
the JSON syntax substantially reduces the risk of a formatting issue.</p>

<h2 id="be-careful-with-generating-random-values">Be Careful with Generating Random Values</h2>

<p>There are functions in Helm that allow you to generate random data,
cryptographic keys, and so on. These are fine to use. But be aware that
during upgrades, templates are re-executed. When a template run
generates data that differs from the last run, that will trigger an
update of that resource.</p>

<h2 id="upgrade-a-release-idempotently">Upgrade a release idempotently</h2>

<p>In order to use the same command when installing and upgrading a release, use the following command:</p>

<pre><code class="language-shell">helm upgrade --install &lt;release name&gt; --values &lt;values file&gt; &lt;chart directory&gt;
</code></pre>

<h1 id="the-chart-repository-guide">The Chart Repository Guide</h1>

<p>This section explains how to create and work with Helm chart repositories. At a
high level, a chart repository is a location where packaged charts can be
stored and shared.</p>

<p>The official chart repository is maintained by the
<a href="https://github.com/helm/charts">Helm Charts</a>, and we welcome
participation. But Helm also makes it easy to create and run your own chart
repository. This guide explains how to do so.</p>

<h2 id="prerequisites">Prerequisites</h2>

<ul>
<li>Go through the <a href="./#quickstart">Quickstart</a> Guide</li>
<li>Read through the <a href="./#charts">Charts</a> document</li>
</ul>

<h2 id="create-a-chart-repository">Create a chart repository</h2>

<p>A <em>chart repository</em> is an HTTP server that houses an <code>index.yaml</code> file and
optionally some packaged charts.  When you&rsquo;re ready to share your charts, the
preferred way to do so is by uploading them to a chart repository.</p>

<p><strong>Note:</strong> For Helm 2.0.0, chart repositories do not have any intrinsic
authentication. There is an <a href="https://github.com/helm/helm/issues/1038">issue tracking progress</a>
in GitHub.</p>

<p>Because a chart repository can be any HTTP server that can serve YAML and tar
files and can answer GET requests, you have a plethora of options when it comes
down to hosting your own chart repository. For example, you can use a Google
Cloud Storage (GCS) bucket, Amazon S3 bucket, Github Pages, or even create your
own web server.</p>

<h3 id="the-chart-repository-structure">The chart repository structure</h3>

<p>A chart repository consists of packaged charts and a special file called
<code>index.yaml</code> which contains an index of all of the charts in the repository.
Frequently, the charts that <code>index.yaml</code> describes are also hosted on the same
server, as are the <a href="./#helm-provenance-and-integrity">provenance files</a>.</p>

<p>For example, the layout of the repository <code>https://example.com/charts</code> might
look like this:</p>

<pre><code>charts/
  |
  |- index.yaml
  |
  |- alpine-0.1.2.tgz
  |
  |- alpine-0.1.2.tgz.prov
</code></pre>

<p>In this case, the index file would contain information about one chart, the Alpine
chart, and provide the download URL <code>https://example.com/charts/alpine-0.1.2.tgz</code>
for that chart.</p>

<p>It is not required that a chart package be located on the same server as the
<code>index.yaml</code> file. However, doing so is often the easiest.</p>

<h3 id="the-index-file">The index file</h3>

<p>The index file is a yaml file called <code>index.yaml</code>. It
contains some metadata about the package, including the contents of a
chart&rsquo;s <code>Chart.yaml</code> file. A valid chart repository must have an index file. The
index file contains information about each chart in the chart repository. The
<code>helm repo index</code> command will generate an index file based on a given local
directory that contains packaged charts.</p>

<p>This is an example of an index file:</p>

<pre><code>apiVersion: v1
entries:
  alpine:
    - created: 2016-10-06T16:23:20.499814565-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz
      version: 0.2.0
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/helm/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz
      version: 0.1.0
  nginx:
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Create a basic nginx HTTP server
      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff
      home: https://k8s.io/helm
      name: nginx
      sources:
      - https://github.com/helm/charts
      urls:
      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz
      version: 1.1.0
generated: 2016-10-06T16:23:20.499029981-06:00
</code></pre>

<p>A generated index and packages can be served from a basic webserver. You can test
things out locally with the <code>helm serve</code> command, which starts a local server.</p>

<pre><code class="language-console">$ helm serve --repo-path ./charts
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
</code></pre>

<p>The above starts a local webserver, serving the charts it finds in <code>./charts</code>. The
serve command will automatically generate an <code>index.yaml</code> file for you during
startup.</p>

<h2 id="hosting-chart-repositories">Hosting Chart Repositories</h2>

<p>This part shows several ways to serve a chart repository.</p>

<h3 id="google-cloud-storage">Google Cloud Storage</h3>

<p>The first step is to <strong>create your GCS bucket</strong>. We&rsquo;ll call ours
<code>fantastic-charts</code>.</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-bucket.png" alt="Create a GCS Bucket" /></p>

<p>Next, make your bucket public by <strong>editing the bucket permissions</strong>.</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/edit-permissions.png" alt="Edit Permissions" /></p>

<p>Insert this line item to <strong>make your bucket public</strong>:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/make-bucket-public.png" alt="Make Bucket Public" /></p>

<p>Congratulations, now you have an empty GCS bucket ready to serve charts!</p>

<p>You may upload your chart repository using the Google Cloud Storage command line
tool, or using the GCS web UI. This is the technique the official Kubernetes
Charts repository hosts its charts, so you may want to take a
<a href="https://github.com/helm/charts">peek at that project</a> if you get stuck.</p>

<p><strong>Note:</strong> A public GCS bucket can be accessed via simple HTTPS at this address
<code>https://bucket-name.storage.googleapis.com/</code>.</p>

<h3 id="jfrog-artifactory">JFrog Artifactory</h3>

<p>You can also set up chart repositories using JFrog Artifactory.
Read more about chart repositories with JFrog Artifactory <a href="https://www.jfrog.com/confluence/display/RTF/Helm+Chart+Repositories">here</a></p>

<h3 id="github-pages-example">Github Pages example</h3>

<p>In a similar way you can create charts repository using GitHub Pages.</p>

<p>GitHub allows you to serve static web pages in two different ways:</p>

<ul>
<li>By configuring a project to serve the contents of its <code>docs/</code> directory</li>
<li>By configuring a project to serve a particular branch</li>
</ul>

<p>We&rsquo;ll take the second approach, though the first is just as easy.</p>

<p>The first step will be to <strong>create your gh-pages branch</strong>.  You can do that
locally as.</p>

<pre><code class="language-console">$ git checkout -b gh-pages
</code></pre>

<p>Or via web browser using <strong>Branch</strong> button on your Github repository:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-gh-page-button.png" alt="Create Github Pages branch" /></p>

<p>Next, you&rsquo;ll want to make sure your <strong>gh-pages branch</strong> is set as Github Pages,
click on your repo <strong>Settings</strong> and scroll down to <strong>Github pages</strong> section and
set as per below:</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/set-a-gh-page.png" alt="Create Github Pages branch" /></p>

<p>By default <strong>Source</strong> usually gets set to <strong>gh-pages branch</strong>. If this is not set by default, then select it.</p>

<p>You can use a <strong>custom domain</strong> there if you wish so.</p>

<p>And check that <strong>Enforce HTTPS</strong> is ticked, so the <strong>HTTPS</strong> will be used when
charts are served.</p>

<p>In such setup you can use <strong>master branch</strong> to store your charts code, and
<strong>gh-pages branch</strong> as charts repository, e.g.:
<code>https://USERNAME.github.io/REPONAME</code>. The demonstration <a href="https://github.com/technosophos/tscharts">TS Charts</a>
repository is accessible at <code>https://technosophos.github.io/tscharts/</code>.</p>

<h3 id="ordinary-web-servers">Ordinary web servers</h3>

<p>To configure an ordinary web server to serve Helm charts, you merely need to do
the following:</p>

<ul>
<li>Put your index and charts in a directory that the server can serve</li>
<li>Make sure the <code>index.yaml</code> file can be accessed with no authentication requirement</li>
<li>Make sure <code>yaml</code> files are served with the correct content type (<code>text/yaml</code> or
<code>text/x-yaml</code>)</li>
</ul>

<p>For example, if you want to serve your charts out of <code>$WEBROOT/charts</code>, make sure
there is a <code>charts/</code> directory in your web root, and put the index file and
charts inside of that folder.</p>

<h2 id="managing-chart-repositories">Managing Chart Repositories</h2>

<p>Now that you have a chart repository, the last part of this guide explains how
to maintain charts in that repository.</p>

<h3 id="store-charts-in-your-chart-repository">Store charts in your chart repository</h3>

<p>Now that you have a chart repository, let&rsquo;s upload a chart and an index file to
the repository.  Charts in a chart repository must be packaged
(<code>helm package chart-name/</code>) and versioned correctly (following
<a href="https://semver.org/">SemVer 2</a> guidelines).</p>

<p>These next steps compose an example workflow, but you are welcome to use
whatever workflow you fancy for storing and updating charts in your chart
repository.</p>

<p>Once you have a packaged chart ready, create a new directory, and move your
packaged chart to that directory.</p>

<pre><code class="language-console">$ helm package docs/examples/alpine/
$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
$ helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>The last command takes the path of the local directory that you just created and
the URL of your remote chart repository and composes an <code>index.yaml</code> file inside the
given directory path.</p>

<p>Now you can upload the chart and the index file to your chart repository using
a sync tool or manually. If you&rsquo;re using Google Cloud Storage, check out this
<a href="./#developing_charts_sync_example">example workflow</a> using the gsutil client. For
GitHub, you can simply put the charts in the appropriate destination branch.</p>

<h3 id="add-new-charts-to-an-existing-repository">Add new charts to an existing repository</h3>

<p>Each time you want to add a new chart to your repository, you must regenerate
the index. The <code>helm repo index</code> command will completely rebuild the <code>index.yaml</code>
file from scratch, including only the charts that it finds locally.</p>

<p>However, you can use the <code>--merge</code> flag to incrementally add new charts to an
existing <code>index.yaml</code> file (a great option when working with a remote repository
like GCS). Run <code>helm repo index --help</code> to learn more,</p>

<p>Make sure that you upload both the revised <code>index.yaml</code> file and the chart. And
if you generated a provenance file, upload that too.</p>

<h3 id="share-your-charts-with-others">Share your charts with others</h3>

<p>When you&rsquo;re ready to share your charts, simply let someone know what the URL of
your repository is.</p>

<p>From there, they will add the repository to their helm client via the <code>helm
repo add [NAME] [URL]</code> command with any name they would like to use to
reference the repository.</p>

<pre><code class="language-console">$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>If the charts are backed by HTTP basic authentication, you can also supply the
username and password here:</p>

<pre><code class="language-console">$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com --username my-username --password my-password
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
</code></pre>

<p><strong>Note:</strong> A repository will not be added if it does not contain a valid
<code>index.yaml</code>.</p>

<p>After that, your users will be able to search through your charts. After you&rsquo;ve updated
the repository, they can use the <code>helm repo update</code> command to get the latest
chart information.</p>

<p><em>Under the hood, the <code>helm repo add</code> and <code>helm repo update</code> commands are
fetching the index.yaml file and storing them in the
<code>$HELM_HOME/repository/cache/</code> directory. This is where the <code>helm search</code>
function finds information about charts.</em></p>

<h1 id="syncing-your-chart-repository">Syncing Your Chart Repository</h1>

<p><em>Note: This example is specifically for a Google Cloud Storage (GCS) bucket which serves a chart repository.</em></p>

<h2 id="prerequisites-1">Prerequisites</h2>

<ul>
<li>Install the <a href="https://cloud.google.com/storage/docs/gsutil">gsutil</a> tool. <em>We rely heavily on the gsutil rsync functionality</em></li>
<li>Be sure to have access to the Helm binary</li>
<li>_Optional: We recommend you set <a href="https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#top_of_page">object versioning</a> on your GCS bucket in case you accidentally delete something._</li>
</ul>

<h2 id="set-up-a-local-chart-repository-directory">Set up a local chart repository directory</h2>

<p>Create a local directory like we did in <a href="./#developing_charts">the chart repository guide</a>, and place your packaged charts in that directory.</p>

<p>For example:</p>

<pre><code class="language-console">$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
</code></pre>

<h2 id="generate-an-updated-index-yaml">Generate an updated index.yaml</h2>

<p>Use Helm to generate an updated index.yaml file by passing in the directory path and the url of the remote repository to the <code>helm repo index</code> command like this:</p>

<pre><code class="language-console">$ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com
</code></pre>

<p>This will generate an updated index.yaml file and place in the <code>fantastic-charts/</code> directory.</p>

<h2 id="sync-your-local-and-remote-chart-repositories">Sync your local and remote chart repositories</h2>

<p>Upload the contents of the directory to your GCS bucket by running <code>scripts/sync-repo.sh</code> and pass in the local directory name and the GCS bucket name.</p>

<p>For example:</p>

<pre><code class="language-console">$ pwd
/Users/funuser/go/src/github.com/helm/helm
$ scripts/sync-repo.sh fantastic-charts/ fantastic-charts
Getting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts
Verifying Prerequisites....
Thumbs up! Looks like you have gsutil. Let's continue.
Building synchronization state...
Starting synchronization
Would copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz
Would copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml
Are you sure you would like to continue with these changes?? [y/N]} y
Building synchronization state...
Starting synchronization
Copying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]...
Uploading   gs://fantastic-charts/alpine-0.1.0.tgz:              740 B/740 B
Copying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]...
Uploading   gs://fantastic-charts/index.yaml:                    347 B/347 B
Congratulations your remote chart repository now matches the contents of fantastic-charts/
</code></pre>

<h2 id="updating-your-chart-repository">Updating your chart repository</h2>

<p>You&rsquo;ll want to keep a local copy of the contents of your chart repository or use <code>gsutil rsync</code> to copy the contents of your remote chart repository to a local directory.</p>

<p>For example:</p>

<pre><code class="language-console">$ gsutil rsync -d -n gs://bucket-name local-dir/    # the -n flag does a dry run
Building synchronization state...
Starting synchronization
Would copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz
Would copy gs://bucket-name/index.yaml to file://local-dir/index.yaml

$ gsutil rsync -d gs://bucket-name local-dir/       # performs the copy actions
Building synchronization state...
Starting synchronization
Copying gs://bucket-name/alpine-0.1.0.tgz...
Downloading file://local-dir/alpine-0.1.0.tgz:                        740 B/740 B
Copying gs://bucket-name/index.yaml...
Downloading file://local-dir/index.yaml:                              346 B/346 B
</code></pre>

<p>Helpful Links:
* Documentation on <a href="https://cloud.google.com/storage/docs/gsutil/commands/rsync#description">gsutil rsync</a>
* <a href="./#developing_charts">The Chart Repository Guide</a>
* Documentation on <a href="https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#overview">object versioning and concurrency control</a> in Google Cloud Storage</p>

<h1 id="helm-provenance-and-integrity">Helm Provenance and Integrity</h1>

<p>Helm has provenance tools which help chart users verify the integrity and origin
of a package. Using industry-standard tools based on PKI, GnuPG, and well-respected
package managers, Helm can generate and verify signature files.</p>

<h2 id="overview">Overview</h2>

<p>Integrity is established by comparing a chart to a provenance record. Provenance
records are stored in <em>provenance files</em>, which are stored alongside a packaged
chart. For example, if a chart is named <code>myapp-1.2.3.tgz</code>, its provenance file
will be <code>myapp-1.2.3.tgz.prov</code>.</p>

<p>Provenance files are generated at packaging time (<code>helm package --sign ...</code>), and
can be checked by multiple commands, notable <code>helm install --verify</code>.</p>

<h2 id="the-workflow">The Workflow</h2>

<p>This section describes a potential workflow for using provenance data effectively.</p>

<p>Prerequisites:</p>

<ul>
<li>A valid PGP keypair in a binary (not ASCII-armored) format</li>
<li>The <code>helm</code> command line tool</li>
<li>GnuPG &gt;=2.1 command line tools (optional)</li>
<li>Keybase command line tools (optional)</li>
</ul>

<p><strong>NOTE:</strong> If your PGP private key has a passphrase, you will be prompted to enter
that passphrase for any commands that support the <code>--sign</code> option. You can set the
HELM_KEY_PASSPHRASE environment variable to that passphrase in case you don&rsquo;t want
to be prompted to enter the passphrase.</p>

<p><strong>NOTE:</strong> The keyfile format for GnuPG changed in version 2.1. Prior to that release
it was unnecessary to export keys out of GnuPG, and you could instead point Helm
at your <code>*.gpg</code> files. With 2.1, the new <code>.kbx</code> format was introduced, and this
format is not supported by Helm.</p>

<p>Creating a new chart is the same as before:</p>

<pre><code>$ helm create mychart
Creating mychart
</code></pre>

<p>Once ready to package, add the <code>--sign</code> flag to <code>helm package</code>. Also, specify
the name under which the signing key is known and the keyring containing the corresponding private key:</p>

<pre><code>$ helm package --sign --key 'helm signing key' --keyring path/to/keyring.secret mychart
</code></pre>

<p><strong>TIP:</strong> for GnuPG users, your secret keyring is in <code>~/.gnupg/secring.kbx</code>. You can
use <code>gpg --list-secret-keys</code> to list the keys you have.</p>

<p><strong>Warning:</strong>  the GnuPG v2.1 store your secret keyring using a new format &lsquo;kbx&rsquo; on the default location  &lsquo;~/.gnupg/pubring.kbx&rsquo;. Please use the following command to convert your keyring to the legacy gpg format:</p>

<pre><code>$ gpg --export-secret-keys &gt;~/.gnupg/secring.gpg
</code></pre>

<p>At this point, you should see both <code>mychart-0.1.0.tgz</code> and <code>mychart-0.1.0.tgz.prov</code>.
Both files should eventually be uploaded to your desired chart repository.</p>

<p>You can verify a chart using <code>helm verify</code>:</p>

<pre><code>$ helm verify mychart-0.1.0.tgz
</code></pre>

<p>A failed verification looks like this:</p>

<pre><code>$ helm verify topchart-0.1.0.tgz
Error: sha256 sum does not match for topchart-0.1.0.tgz: &quot;sha256:1939fbf7c1023d2f6b865d137bbb600e0c42061c3235528b1e8c82f4450c12a7&quot; != &quot;sha256:5a391a90de56778dd3274e47d789a2c84e0e106e1a37ef8cfa51fd60ac9e623a&quot;
</code></pre>

<p>To verify during an install, use the <code>--verify</code> flag.</p>

<pre><code>$ helm install --verify mychart-0.1.0.tgz
</code></pre>

<p>If the keyring (containing the public key associated with the signed chart) is not in the default location, you may need to point to the
keyring with <code>--keyring PATH</code> as in the <code>helm package</code> example.</p>

<p>If verification fails, the install will be aborted before the chart is even pushed
up to Tiller.</p>

<h3 id="using-keybase-io-credentials">Using Keybase.io credentials</h3>

<p>The <a href="https://keybase.io">Keybase.io</a> service makes it easy to establish a chain of
trust for a cryptographic identity. Keybase credentials can be used to sign charts.</p>

<p>Prerequisites:</p>

<ul>
<li>A configured Keybase.io account</li>
<li>GnuPG installed locally</li>
<li>The <code>keybase</code> CLI installed locally</li>
</ul>

<h4 id="signing-packages">Signing packages</h4>

<p>The first step is to import your keybase keys into your local GnuPG keyring:</p>

<pre><code>$ keybase pgp export -s &gt; secring.gpg
</code></pre>

<p>This will convert your Keybase key into the OpenPGP format, and then place it
locally into your <code>secring.gpg</code> file.</p>

<blockquote>
<p>Tip: If you need to add a Keybase key to an existing keyring, you will need to
do <code>keybase pgp export -s | gpg --import &amp;&amp; gpg --export-secret-keys --outfile secring.gpg</code></p>
</blockquote>

<p>Your secret key will have an identifier string:</p>

<pre><code>technosophos (keybase.io/technosophos) &lt;technosophos@keybase.io&gt;
</code></pre>

<p>That is the full name of your key.</p>

<p>Next, you can package and sign a chart with <code>helm package</code>. Make sure you use at
least part of that name string in <code>--key</code>.</p>

<pre><code>$ helm package --sign --key technosophos --keyring ~/.gnupg/secring.gpg mychart
</code></pre>

<p>As a result, the <code>package</code> command should produce both a <code>.tgz</code> file and a <code>.tgz.prov</code>
file.</p>

<h4 id="verifying-packages">Verifying packages</h4>

<p>You can also use a similar technique to verify a chart signed by someone else&rsquo;s
Keybase key. Say you want to verify a package signed by <code>keybase.io/technosophos</code>.
To do this, use the <code>keybase</code> tool:</p>

<pre><code>$ keybase follow technosophos
$ keybase pgp pull
</code></pre>

<p>The first command above tracks the user <code>technosophos</code>. Next <code>keybase pgp pull</code>
downloads the OpenPGP keys of all of the accounts you follow, placing them in
your GnuPG keyring (<code>~/.gnupg/pubring.gpg</code>).</p>

<p>At this point, you can now use <code>helm verify</code> or any of the commands with a <code>--verify</code>
flag:</p>

<pre><code>$ helm verify somechart-1.2.3.tgz
</code></pre>

<h3 id="reasons-a-chart-may-not-verify">Reasons a chart may not verify</h3>

<p>These are common reasons for failure.</p>

<ul>
<li>The prov file is missing or corrupt. This indicates that something is misconfigured
or that the original maintainer did not create a provenance file.</li>
<li>The key used to sign the file is not in your keyring. This indicate that the
entity who signed the chart is not someone you&rsquo;ve already signaled that you trust.</li>
<li>The verification of the prov file failed. This indicates that something is wrong
with either the chart or the provenance data.</li>
<li>The file hashes in the provenance file do not match the hash of the archive file. This
indicates that the archive has been tampered with.</li>
</ul>

<p>If a verification fails, there is reason to distrust the package.</p>

<h2 id="the-provenance-file">The Provenance File</h2>

<p>The provenance file contains a chart’s YAML file plus several pieces of
verification information. Provenance files are designed to be automatically
generated.</p>

<p>The following pieces of provenance data are added:</p>

<ul>
<li>The chart file (Chart.yaml) is included to give both humans and tools an easy
view into the contents of the chart.</li>
<li>The signature (SHA256, just like Docker) of the chart package (the .tgz file)
is included, and may be used to verify the integrity of the chart package.</li>
<li>The entire body is signed using the algorithm used by PGP (see
[<a href="http://keybase.io">http://keybase.io</a>] for an emerging way of making crypto signing and
verification easy).</li>
</ul>

<p>The combination of this gives users the following assurances:</p>

<ul>
<li>The package itself has not been tampered with (checksum package tgz).</li>
<li>The entity who released this package is known (via the GnuPG/PGP signature).</li>
</ul>

<p>The format of the file looks something like this:</p>

<pre><code>-----BEGIN PGP SIGNED MESSAGE-----
name: nginx
description: The nginx web server as a replication controller and service pair.
version: 0.5.1
keywords:
  - https
  - http
  - web server
  - proxy
source:
- https://github.com/foo/bar
home: http://nginx.com

...
files:
        nginx-0.5.1.tgz: “sha256:9f5270f50fc842cfcb717f817e95178f”
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEARECAAYFAkjilUEACgQkB01zfu119ZnHuQCdGCcg2YxF3XFscJLS4lzHlvte
WkQAmQGHuuoLEJuKhRNo+Wy7mhE7u1YG
=eifq
-----END PGP SIGNATURE-----
</code></pre>

<p>Note that the YAML section contains two documents (separated by <code>...\n</code>). The
first is the Chart.yaml. The second is the checksums, a map of filenames to
SHA-256 digests (value shown is fake/truncated)</p>

<p>The signature block is a standard PGP signature, which provides <a href="http://www.rossde.com/PGP/pgp_signatures.html">tamper
resistance</a>.</p>

<h2 id="chart-repositories-1">Chart Repositories</h2>

<p>Chart repositories serve as a centralized collection of Helm charts.</p>

<p>Chart repositories must make it possible to serve provenance files over HTTP via
a specific request, and must make them available at the same URI path as the chart.</p>

<p>For example, if the base URL for a package is <code>https://example.com/charts/mychart-1.2.3.tgz</code>,
the provenance file, if it exists, MUST be accessible at <code>https://example.com/charts/mychart-1.2.3.tgz.prov</code>.</p>

<p>From the end user&rsquo;s perspective, <code>helm install --verify myrepo/mychart-1.2.3</code>
should result in the download of both the chart and the provenance file with no
additional user configuration or action.</p>

<h2 id="establishing-authority-and-authenticity">Establishing Authority and Authenticity</h2>

<p>When dealing with chain-of-trust systems, it is important to be able to
establish the authority of a signer. Or, to put this plainly, the system
above hinges on the fact that you trust the person who signed the chart.
That, in turn, means you need to trust the public key of the signer.</p>

<p>One of the design decisions with Kubernetes Helm has been that the Helm
project would not insert itself into the chain of trust as a necessary
party. We don&rsquo;t want to be &ldquo;the certificate authority&rdquo; for all chart
signers. Instead, we strongly favor a decentralized model, which is part
of the reason we chose OpenPGP as our foundational technology.
So when it comes to establishing authority, we have left this
step more-or-less undefined in Helm 2.0.0.</p>

<p>However, we have some pointers and recommendations for those interested
in using the provenance system:</p>

<ul>
<li>The <a href="https://keybase.io">Keybase</a> platform provides a public
centralized repository for trust information.

<ul>
<li>You can use Keybase to store your keys or to get the public keys of others.</li>
<li>Keybase also has fabulous documentation available</li>
<li>While we haven&rsquo;t tested it, Keybase&rsquo;s &ldquo;secure website&rdquo; feature could
be used to serve Helm charts.</li>
</ul></li>
<li>The <a href="https://github.com/helm/charts">official Helm Charts project</a>
is trying to solve this problem for the official chart repository.

<ul>
<li>There is a long issue there <a href="https://github.com/helm/charts/issues/23">detailing the current thoughts</a>.</li>
<li>The basic idea is that an official &ldquo;chart reviewer&rdquo; signs charts with
her or his key, and the resulting provenance file is then uploaded
to the chart repository.</li>
<li>There has been some work on the idea that a list of valid signing
keys may be included in the <code>index.yaml</code> file of a repository.</li>
</ul></li>
</ul>

<p>Finally, chain-of-trust is an evolving feature of Helm, and some
community members have proposed adapting part of the OSI model for
signatures. This is an open line of inquiry in the Helm team. If you&rsquo;re
interested, jump on in.</p>

<h1 id="chart-tests">Chart Tests</h1>

<p>A chart contains a number of Kubernetes resources and components that work together. As a chart author, you may want to write some tests that validate that your chart works as expected when it is installed. These tests also help the chart consumer understand what your chart is supposed to do.</p>

<p>A <strong>test</strong> in a helm chart lives under the <code>templates/</code> directory and is a pod definition that specifies a container with a given command to run. The container should exit successfully (exit 0) for a test to be considered a success. The pod definition must contain one of the helm test hook annotations: <code>helm.sh/hook: test-success</code> or <code>helm.sh/hook: test-failure</code>.</p>

<p>Example tests:
- Validate that your configuration from the values.yaml file was properly injected.
  - Make sure your username and password work correctly
  - Make sure an incorrect username and password does not work
- Assert that your services are up and correctly loadbalanced.
- etc.</p>

<p>You can run the pre-defined tests in Helm on a release using the command <code>helm test &lt;RELEASE_NAME&gt;</code>. For a chart consumer, this is a great way to sanity check that their release of a chart (or application) works as expected.</p>

<h2 id="a-breakdown-of-the-helm-test-hooks">A Breakdown of the Helm Test Hooks</h2>

<p>In Helm, there are two test hooks: <code>test-success</code> and <code>test-failure</code></p>

<p><code>test-success</code> indicates that test pod should complete successfully. In other words, the containers in the pod should exit 0.
<code>test-failure</code> is a way to assert that a test pod should not complete successfully. If the containers in the pod do not exit 0, that indicates success.</p>

<h2 id="example-test">Example Test</h2>

<p>Here is an example of a helm test pod definition in an example wordpress chart. The test verifies the access and login to the mariadb database:</p>

<pre><code>wordpress/
  Chart.yaml
  README.md
  values.yaml
  charts/
  templates/
  templates/tests/test-mariadb-connection.yaml
</code></pre>

<p>In <code>wordpress/templates/tests/test-mariadb-connection.yaml</code>:</p>

<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: &quot;{{ .Release.Name }}-credentials-test&quot;
  annotations:
    &quot;helm.sh/hook&quot;: test-success
spec:
  containers:
  - name: {{ .Release.Name }}-credentials-test
    image: {{ .Values.image }}
    env:
      - name: MARIADB_HOST
        value: {{ template &quot;mariadb.fullname&quot; . }}
      - name: MARIADB_PORT
        value: &quot;3306&quot;
      - name: WORDPRESS_DATABASE_NAME
        value: {{ default &quot;&quot; .Values.mariadb.mariadbDatabase | quote }}
      - name: WORDPRESS_DATABASE_USER
        value: {{ default &quot;&quot; .Values.mariadb.mariadbUser | quote }}
      - name: WORDPRESS_DATABASE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: {{ template &quot;mariadb.fullname&quot; . }}
            key: mariadb-password
    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;mysql --host=$MARIADB_HOST --port=$MARIADB_PORT --user=$WORDPRESS_DATABASE_USER --password=$WORDPRESS_DATABASE_PASSWORD&quot;]
  restartPolicy: Never
</code></pre>

<h2 id="steps-to-run-a-test-suite-on-a-release">Steps to Run a Test Suite on a Release</h2>

<ol>
<li><p><code>$ helm install wordpress</code></p>

<pre><code>NAME:   quirky-walrus
LAST DEPLOYED: Mon Feb 13 13:50:43 2017
NAMESPACE: default
STATUS: DEPLOYED
</code></pre></li>

<li><p><code>$ helm test quirky-walrus</code></p>

<pre><code>RUNNING: quirky-walrus-credentials-test
SUCCESS: quirky-walrus-credentials-test
</code></pre></li>
</ol>

<h2 id="notes">Notes</h2>

<ul>
<li>You can define as many tests as you would like in a single yaml file or spread across several yaml files in the <code>templates/</code> directory</li>
<li>You are welcome to nest your test suite under a <code>tests/</code> directory like <code>&lt;chart-name&gt;/templates/tests/</code> for more isolation</li>
</ul>

<h1 id="chart-repositories-frequently-asked-questions">Chart Repositories: Frequently Asked Questions</h1>

<p>This section tracks some of the more frequently encountered issues with using chart repositories.</p>

<p><strong>We&rsquo;d love your help</strong> making this document better. To add, correct, or remove
information, <a href="https://github.com/helm/helm/issues">file an issue</a> or
send us a pull request.</p>

<h2 id="fetching">Fetching</h2>

<p><strong>Q: Why do I get a <code>unsupported protocol scheme &quot;&quot;</code> error when trying to fetch a chart from my custom repo?</strong></p>

<p>A: (Helm &lt; 2.5.0) This is likely caused by you creating your chart repo index without specifying the <code>--url</code> flag.
Try recreating your <code>index.yaml</code> file with a command like <code>helm repo index --url http://my-repo/charts .</code>,
and then re-uploading it to your custom charts repo.</p>

<p>This behavior was changed in Helm 2.5.0.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="helm-examples">Helm Examples</h1>

<p>This directory contains example charts to help you get started with
chart development.</p>

<h2 id="alpine">Alpine</h2>

<p>The <code>alpine</code> chart is very simple, and is a good starting point.</p>

<p>It simply deploys a single pod running Alpine Linux.</p>

<h2 id="nginx">Nginx</h2>

<p>The <code>nginx</code> chart shows how to compose several resources into one chart,
and it illustrates more complex template usage.</p>

<p>It deploys a <code>Deployment</code> (which creates a <code>ReplicaSet</code>), a <code>ConfigMap</code>, and a <code>Service</code>. The replica set starts an nginx pod. The config
map stores the files that the nginx server can serve.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="alpine-a-simple-helm-chart">Alpine: A simple Helm chart</h1>

<p>Run a single pod of Alpine Linux.</p>

<p>The <code>templates/</code> directory contains a very simple pod resource with a
couple of parameters.</p>

<p>The <code>values.yaml</code> file contains the default values for the
<code>alpine-pod.yaml</code> template.</p>

<p>You can install this example using <code>helm install docs/examples/alpine</code>.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="nginx-an-advanced-example-chart">nginx: An advanced example chart</h1>

<p>This Helm chart provides examples of some of Helm&rsquo;s more powerful
features.</p>

<p><strong>This is not a production-grade chart. It is an example.</strong></p>

<p>The chart installs a simple nginx server according to the following
pattern:</p>

<ul>
<li>A <code>ConfigMap</code> is used to store the files the server will serve.
(<a href="templates/configmap.yaml">templates/configmap.yaml</a>)</li>
<li>A <code>Deployment</code> is used to create a Replica Set of nginx pods.
(<a href="templates/deployment.yaml">templates/deployment.yaml</a>)</li>
<li>A <code>Service</code> is used to create a gateway to the pods running in the
replica set (<a href="templates/service.yaml">templates/service.yaml</a>)</li>
</ul>

<p>The <a href="values.yaml">values.yaml</a> exposes a few of the configuration options in the
charts, though there are some that are not exposed there (like
<code>.image</code>).</p>

<p>The <a href="templates/_helpers.tpl">templates/_helpers.tpl</a> file contains helper templates. The leading
underscore (<code>_</code>) on the filename is semantic. It tells the template renderer
that this file does not contain a manifest. That file declares some
templates that are used elsewhere in the chart.</p>

<p>Helpers (usually called &ldquo;partials&rdquo; in template languages) are an
advanced way for developers to structure their templates for optimal
reuse.</p>

<p>You can deploy this chart with <code>helm install docs/examples/nginx</code>. Or
you can see how this chart would render with <code>helm install --dry-run
--debug docs/examples/nginx</code>.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="helm-glossary">Helm Glossary</h1>

<p>Helm uses a few special terms to describe components of the
architecture.</p>

<h2 id="chart">Chart</h2>

<p>A Helm package that contains information sufficient for installing a set
of Kubernetes resources into a Kubernetes cluster.</p>

<p>Charts contain a <code>Chart.yaml</code> file as well as templates, default values
(<code>values.yaml</code>), and dependencies.</p>

<p>Charts are developed in a well-defined directory structure, and then
packaged into an archive format called a <em>chart archive</em>.</p>

<h2 id="chart-archive">Chart Archive</h2>

<p>A <em>chart archive</em> is a tarred and gzipped (and optionally signed) chart.</p>

<h2 id="chart-dependency-subcharts">Chart Dependency (Subcharts)</h2>

<p>Charts may depend upon other charts. There are two ways a dependency may
occur:</p>

<ul>
<li>Soft dependency: A chart may simply not function without another chart
being installed in a cluster. Helm does not provide tooling for this
case. In this case, dependencies may be managed separately.</li>
<li>Hard dependency: A chart may contain (inside of its <code>charts/</code>
directory) another chart upon which it depends. In this case,
installing the chart will install all of its dependencies. In this
case, a chart and its dependencies are managed as a collection.</li>
</ul>

<p>When a chart is packaged (via <code>helm package</code>) all of its hard dependencies
are bundled with it.</p>

<h2 id="chart-version">Chart Version</h2>

<p>Charts are versioned according to the <a href="http://semver.org">SemVer 2
spec</a>. A version number is required on every chart.</p>

<h2 id="chart-yaml">Chart.yaml</h2>

<p>Information about a chart is stored in a special file called
<code>Chart.yaml</code>. Every chart must have this file.</p>

<h2 id="helm-and-helm">Helm (and helm)</h2>

<p>Helm is the package manager for Kubernetes. As an operating system
package manager makes it easy to install tools on an OS, Helm makes it
easy to install applications and resources into Kubernetes clusters.</p>

<p>While <em>Helm</em> is the name of the project, the command line client is also
named <code>helm</code>. By convention, when speaking of the project, <em>Helm</em> is
capitalized. When speaking of the client, <em>helm</em> is in lowercase.</p>

<h2 id="helm-home-helm-home">Helm Home (HELM_HOME)</h2>

<p>The Helm client stores information in a local directory referred to as
<em>helm home</em>. By default, this is in the <code>$HOME/.helm</code> directory.</p>

<p>This directory contains configuration and cache data, and is created by
<code>helm init</code>.</p>

<h2 id="kube-config-kubeconfig">Kube Config (KUBECONFIG)</h2>

<p>The Helm client learns about Kubernetes clusters by using files in the <em>Kube
config</em> file format. By default, Helm attempts to find this file in the
place where <code>kubectl</code> creates it (<code>$HOME/.kube/config</code>).</p>

<h2 id="lint-linting">Lint (Linting)</h2>

<p>To <em>lint</em> a chart is to validate that it follows the conventions and
requirements of the Helm chart standard. Helm provides tools to do this,
notably the <code>helm lint</code> command.</p>

<h2 id="provenance-provenance-file">Provenance (Provenance file)</h2>

<p>Helm charts may be accompanied by a <em>provenance file</em> which provides
information about where the chart came from and what it contains.</p>

<p>Provenance files are one part of the Helm security story. A provenance contains
a cryptographic hash of the chart archive file, the Chart.yaml data, and
a signature block (an OpenPGP &ldquo;clearsign&rdquo; block). When coupled with a
keychain, this provides chart users with the ability to:</p>

<ul>
<li>Validate that a chart was signed by a trusted party</li>
<li>Validate that the chart file has not been tampered with</li>
<li>Validate the contents of a chart metadata (<code>Chart.yaml</code>)</li>
<li>Quickly match a chart to its provenance data</li>
</ul>

<p>Provenance files have the <code>.prov</code> extension, and can be served from a
chart repository server or any other HTTP server.</p>

<h2 id="release">Release</h2>

<p>When a chart is installed, Tiller (the Helm server) creates a <em>release</em>
to track that installation.</p>

<p>A single chart may be installed many times into the same cluster, and
create many different releases. For example, one can install three
PostgreSQL databases by running <code>helm install</code> three times with a
different release name.</p>

<p>(Prior to 2.0.0-Alpha.1, releases were called <em>deployments</em>. But this
caused confusion with the Kubernetes <em>Deployment</em> kind.)</p>

<h2 id="release-number-release-version">Release Number (Release Version)</h2>

<p>A single release can be updated multiple times. A sequential counter is
used to track releases as they change. After a first <code>helm install</code>, a
release will have <em>release number</em> 1. Each time a release is upgraded or
rolled back, the release number will be incremented.</p>

<h2 id="rollback">Rollback</h2>

<p>A release can be upgraded to a newer chart or configuration. But since
release history is stored, a release can also be <em>rolled back</em> to a
previous release number. This is done with the <code>helm rollback</code> command.</p>

<p>Importantly, a rolled back release will receive a new release number.</p>

<table>
<thead>
<tr>
<th>Operation</th>
<th>Release Number</th>
</tr>
</thead>

<tbody>
<tr>
<td>install</td>
<td>release 1</td>
</tr>

<tr>
<td>upgrade</td>
<td>release 2</td>
</tr>

<tr>
<td>upgrade</td>
<td>release 3</td>
</tr>

<tr>
<td>rollback 1</td>
<td>release 4 (but running the same config as release 1)</td>
</tr>
</tbody>
</table>

<p>The above table illustrates how release numbers increment across
install, upgrade, and rollback.</p>

<h2 id="tiller">Tiller</h2>

<p>Tiller is the in-cluster component of Helm. It interacts directly with
the Kubernetes API server to install, upgrade, query, and remove
Kubernetes resources. It also stores the objects that represent
releases.</p>

<h2 id="repository-repo-chart-repository">Repository (Repo, Chart Repository)</h2>

<p>Helm charts may be stored on dedicated HTTP servers called <em>chart
repositories</em> (<em>repositories</em>, or just <em>repos</em>).</p>

<p>A chart repository server is a simple HTTP server that can serve an
<code>index.yaml</code> file that describes a batch of charts, and provides
information on where each chart can be downloaded from. (Many chart
repositories serve the charts as well as the <code>index.yaml</code> file.)</p>

<p>A Helm client can point to zero or more chart repositories. By default,
Helm clients point to the <code>stable</code> official Kubernetes chart
repository.</p>

<h2 id="values-values-files-values-yaml">Values (Values Files, values.yaml)</h2>

<p>Values provide a way to override template defaults with your own
information.</p>

<p>Helm Charts are &ldquo;parameterized&rdquo;, which means the chart developer may
expose configuration that can be overridden at installation time. For
example, a chart may expose a <code>username</code> field that allows setting a
user name for a service.</p>

<p>These exposed variables are called <em>values</em> in Helm parlance.</p>

<p>Values can be set during <code>helm install</code> and <code>helm upgrade</code> operations,
either by passing them in directly, or by uploading a <code>values.yaml</code>
file.</p>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm">helm</h2>

<p>The Helm package manager for Kubernetes.</p>

<h3 id="synopsis">Synopsis</h3>

<p>The Kubernetes package manager</p>

<p>To begin working with Helm, run the &lsquo;helm init&rsquo; command:</p>

<pre><code>$ helm init
</code></pre>

<p>This will install Tiller to your running Kubernetes cluster.
It will also set up any necessary local configuration.</p>

<p>Common actions from this point include:</p>

<ul>
<li>helm search:    search for charts</li>
<li>helm fetch:     download a chart to your local directory to view</li>
<li>helm install:   upload the chart to Kubernetes</li>
<li>helm list:      list releases of charts</li>
</ul>

<p>Environment:
  $HELM_HOME           set an alternative location for Helm files. By default, these are stored in ~/.helm
  $HELM_HOST           set an alternative Tiller host. The format is host:port
  $HELM_NO_PLUGINS     disable plugins. Set HELM_NO_PLUGINS=1 to disable plugins.
  $TILLER_NAMESPACE    set an alternative Tiller namespace (default &ldquo;kube-system&rdquo;)
  $KUBECONFIG          set an alternative Kubernetes configuration file (default &ldquo;~/.kube/config&rdquo;)
  $HELM_TLS_CA_CERT    path to TLS CA certificate used to verify the Helm client and Tiller server certificates (default &ldquo;$HELM_HOME/ca.pem&rdquo;)
  $HELM_TLS_CERT       path to TLS client certificate file for authenticating to Tiller (default &ldquo;$HELM_HOME/cert.pem&rdquo;)
  $HELM_TLS_KEY        path to TLS client key file for authenticating to Tiller (default &ldquo;$HELM_HOME/key.pem&rdquo;)
  $HELM_TLS_VERIFY     enable TLS connection between Helm and Tiller and verify Tiller server certificate (default &ldquo;false&rdquo;)
  $HELM_TLS_ENABLE     enable TLS connection between Helm and Tiller (default &ldquo;false&rdquo;)
  $HELM_KEY_PASSPHRASE set HELM_KEY_PASSPHRASE to the passphrase of your PGP private key. If set, you will not be prompted for
                       the passphrase while signing helm charts</p>

<h3 id="options">Options</h3>

<pre><code>      --debug                           enable verbose output
  -h, --help                            help for helm
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_completion">helm completion</a>     - Generate autocompletions script for the specified shell (bash or zsh)</li>
<li><a href="../../helm/#helm_create">helm create</a>     - create a new chart with the given name</li>
<li><a href="../../helm/#helm_delete">helm delete</a>     - given a release name, delete the release from Kubernetes</li>
<li><a href="../../helm/#helm_dependency">helm dependency</a>     - manage a chart&rsquo;s dependencies</li>
<li><a href="../../helm/#helm_fetch">helm fetch</a>   - download a chart from a repository and (optionally) unpack it in local directory</li>
<li><a href="../../helm/#helm_get">helm get</a>   - download a named release</li>
<li><a href="../../helm/#helm_history">helm history</a>   - fetch release history</li>
<li><a href="../../helm/#helm_home">helm home</a>     - displays the location of HELM_HOME</li>
<li><a href="../../helm/#helm_init">helm init</a>     - initialize Helm on both client and server</li>
<li><a href="../../helm/#helm_inspect">helm inspect</a>   - inspect a chart</li>
<li><a href="../../helm/#helm_install">helm install</a>   - install a chart archive</li>
<li><a href="../../helm/#helm_lint">helm lint</a>     - examines a chart for possible issues</li>
<li><a href="../../helm/#helm_list">helm list</a>     - list releases</li>
<li><a href="../../helm/#helm_package">helm package</a>   - package a chart directory into a chart archive</li>
<li><a href="../../helm/#helm_plugin">helm plugin</a>     - add, list, or remove Helm plugins</li>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
<li><a href="../../helm/#helm_reset">helm reset</a>   - uninstalls Tiller from a cluster</li>
<li><a href="../../helm/#helm_rollback">helm rollback</a>     - roll back a release to a previous revision</li>
<li><a href="../../helm/#helm_search">helm search</a>     - search for a keyword in charts</li>
<li><a href="../../helm/#helm_serve">helm serve</a>   - start a local http web server</li>
<li><a href="../../helm/#helm_status">helm status</a>     - displays the status of the named release</li>
<li><a href="../../helm/#helm_template">helm template</a>     - locally render templates</li>
<li><a href="../../helm/#helm_test">helm test</a>     - test a release</li>
<li><a href="../../helm/#helm_upgrade">helm upgrade</a>   - upgrade a release</li>
<li><a href="../../helm/#helm_verify">helm verify</a>     - verify that a chart at the given path has been signed and is valid</li>
<li><a href="../../helm/#helm_version">helm version</a>   - print the client/server version information</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-16-oct-2018">Auto generated by spf13/cobra on 16-Oct-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-completion">helm completion</h2>

<p>Generate autocompletions script for the specified shell (bash or zsh)</p>

<h3 id="synopsis">Synopsis</h3>

<p>Generate autocompletions script for Helm for the specified shell (bash or zsh).</p>

<p>This command can generate shell autocompletions. e.g.</p>

<pre><code>$ helm completion bash
</code></pre>

<p>Can be sourced as such</p>

<pre><code>$ source &lt;(helm completion bash)
</code></pre>

<pre><code>helm completion SHELL [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for completion
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-create">helm create</h2>

<p>create a new chart with the given name</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command creates a chart directory along with the common files and
directories used in a chart.</p>

<p>For example, &lsquo;helm create foo&rsquo; will create a directory structure that looks
something like this:</p>

<pre><code>foo/
  |
  |- .helmignore        # Contains patterns to ignore when packaging Helm charts.
  |
  |- Chart.yaml         # Information about your chart
  |
  |- values.yaml        # The default values for your templates
  |
  |- charts/            # Charts that this chart depends on
  |
  |- templates/         # The template files
  |
  |- templates/tests/   # The test files
</code></pre>

<p>&lsquo;helm create&rsquo; takes a path for an argument. If directories in the given path
do not exist, Helm will attempt to create them as it goes. If the given
destination exists and there are files in that directory, conflicting files
will be overwritten, but other files will be left alone.</p>

<pre><code>helm create NAME [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help             help for create
  -p, --starter string   the named Helm starter scaffold
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-18-sep-2018">Auto generated by spf13/cobra on 18-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-delete">helm delete</h2>

<p>given a release name, delete the release from Kubernetes</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command takes a release name, and then deletes the release from Kubernetes.
It removes all of the resources associated with the last release of the chart.</p>

<p>Use the &lsquo;&ndash;dry-run&rsquo; flag to see which releases will be deleted without actually
deleting them.</p>

<pre><code>helm delete [flags] RELEASE_NAME [...]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --description string    specify a description for the release
      --dry-run               simulate a delete
  -h, --help                  help for delete
      --no-hooks              prevent hooks from running during deletion
      --purge                 remove the release from the store and make its name free for later use
      --timeout int           time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks) (default 300)
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-dependency">helm dependency</h2>

<p>manage a chart&rsquo;s dependencies</p>

<h3 id="synopsis">Synopsis</h3>

<p>Manage the dependencies of a chart.</p>

<p>Helm charts store their dependencies in &lsquo;charts/&rsquo;. For chart developers, it is
often easier to manage a single dependency file (&lsquo;requirements.yaml&rsquo;)
which declares all dependencies.</p>

<p>The dependency commands operate on that file, making it easy to synchronize
between the desired dependencies and the actual dependencies stored in the
&lsquo;charts/&rsquo; directory.</p>

<p>A &lsquo;requirements.yaml&rsquo; file is a YAML file in which developers can declare chart
dependencies, along with the location of the chart and the desired version.
For example, this requirements file declares two dependencies:</p>

<pre><code># requirements.yaml
dependencies:
- name: nginx
  version: &quot;1.2.3&quot;
  repository: &quot;https://example.com/charts&quot;
- name: memcached
  version: &quot;3.2.1&quot;
  repository: &quot;https://another.example.com/charts&quot;
</code></pre>

<p>The &lsquo;name&rsquo; should be the name of a chart, where that name must match the name
in that chart&rsquo;s &lsquo;Chart.yaml&rsquo; file.</p>

<p>The &lsquo;version&rsquo; field should contain a semantic version or version range.</p>

<p>The &lsquo;repository&rsquo; URL should point to a Chart Repository. Helm expects that by
appending &lsquo;/index.yaml&rsquo; to the URL, it should be able to retrieve the chart
repository&rsquo;s index. Note: &lsquo;repository&rsquo; can be an alias. The alias must start
with &lsquo;alias:&rsquo; or &lsquo;@&rsquo;.</p>

<p>Starting from 2.2.0, repository can be defined as the path to the directory of
the dependency charts stored locally. The path should start with a prefix of
&ldquo;file://&ldquo;. For example,</p>

<pre><code># requirements.yaml
dependencies:
- name: nginx
  version: &quot;1.2.3&quot;
  repository: &quot;file://../dependency_chart/nginx&quot;
</code></pre>

<p>If the dependency chart is retrieved locally, it is not required to have the
repository added to helm by &ldquo;helm add repo&rdquo;. Version matching is also supported
for this case.</p>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for dependency
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
<li><a href="../../helm/#helm_dependency_build">helm dependency build</a>     - rebuild the charts/ directory based on the requirements.lock file</li>
<li><a href="../../helm/#helm_dependency_list">helm dependency list</a>   - list the dependencies for the given chart</li>
<li><a href="../../helm/#helm_dependency_update">helm dependency update</a>   - update charts/ based on the contents of requirements.yaml</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-dependency-build">helm dependency build</h2>

<p>rebuild the charts/ directory based on the requirements.lock file</p>

<h3 id="synopsis">Synopsis</h3>

<p>Build out the charts/ directory from the requirements.lock file.</p>

<p>Build is used to reconstruct a chart&rsquo;s dependencies to the state specified in
the lock file. This will not re-negotiate dependencies, as &lsquo;helm dependency update&rsquo;
does.</p>

<p>If no lock file is found, &lsquo;helm dependency build&rsquo; will mirror the behavior
of &lsquo;helm dependency update&rsquo;.</p>

<pre><code>helm dependency build [flags] CHART
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help             help for build
      --keyring string   keyring containing public keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --verify           verify the packages against signatures
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_dependency">helm dependency</a>     - manage a chart&rsquo;s dependencies</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-dependency-list">helm dependency list</h2>

<p>list the dependencies for the given chart</p>

<h3 id="synopsis">Synopsis</h3>

<p>List all of the dependencies declared in a chart.</p>

<p>This can take chart archives and chart directories as input. It will not alter
the contents of a chart.</p>

<p>This will produce an error if the chart cannot be loaded. It will emit a warning
if it cannot find a requirements.yaml.</p>

<pre><code>helm dependency list [flags] CHART
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for list
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_dependency">helm dependency</a>     - manage a chart&rsquo;s dependencies</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-dependency-update">helm dependency update</h2>

<p>update charts/ based on the contents of requirements.yaml</p>

<h3 id="synopsis">Synopsis</h3>

<p>Update the on-disk dependencies to mirror the requirements.yaml file.</p>

<p>This command verifies that the required charts, as expressed in &lsquo;requirements.yaml&rsquo;,
are present in &lsquo;charts/&rsquo; and are at an acceptable version. It will pull down
the latest charts that satisfy the dependencies, and clean up old dependencies.</p>

<p>On successful update, this will generate a lock file that can be used to
rebuild the requirements to an exact version.</p>

<p>Dependencies are not required to be represented in &lsquo;requirements.yaml&rsquo;. For that
reason, an update command will not remove charts unless they are (a) present
in the requirements.yaml file, but (b) at the wrong version.</p>

<pre><code>helm dependency update [flags] CHART
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help             help for update
      --keyring string   keyring containing public keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --skip-refresh     do not refresh the local repository cache
      --verify           verify the packages against signatures
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_dependency">helm dependency</a>     - manage a chart&rsquo;s dependencies</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-fetch">helm fetch</h2>

<p>download a chart from a repository and (optionally) unpack it in local directory</p>

<h3 id="synopsis">Synopsis</h3>

<p>Retrieve a package from a package repository, and download it locally.</p>

<p>This is useful for fetching packages to inspect, modify, or repackage. It can
also be used to perform cryptographic verification of a chart without installing
the chart.</p>

<p>There are options for unpacking the chart after download. This will create a
directory for the chart and uncompress into that directory.</p>

<p>If the &ndash;verify flag is specified, the requested chart MUST have a provenance
file, and MUST pass the verification process. Failure in any part of this will
result in an error, and the chart will not be saved locally.</p>

<pre><code>helm fetch [flags] [chart URL | repo/chartname] [...]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string       verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string     identify HTTPS client using this SSL certificate file
  -d, --destination string   location to write the chart. If this and tardir are specified, tardir is appended to this (default &quot;.&quot;)
      --devel                use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored.
  -h, --help                 help for fetch
      --key-file string      identify HTTPS client using this SSL key file
      --keyring string       keyring containing public keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --password string      chart repository password
      --prov                 fetch the provenance file, but don't perform verification
      --repo string          chart repository url where to locate the requested chart
      --untar                if set to true, will untar the chart after downloading it
      --untardir string      if untar is specified, this flag specifies the name of the directory into which the chart is expanded (default &quot;.&quot;)
      --username string      chart repository username
      --verify               verify the package against its signature
      --version string       specific version of a chart. Without this, the latest version is fetched
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-get">helm get</h2>

<p>download a named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command shows the details of a named release.</p>

<p>It can be used to get extended information about the release, including:</p>

<ul>
<li>The values used to generate the release</li>
<li>The chart used to generate the release</li>
<li>The generated manifest file</li>
</ul>

<p>By default, this prints a human readable collection of information about the
chart, the supplied values, and the generated manifest file.</p>

<pre><code>helm get [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                  help for get
      --revision int32        get the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
<li><a href="../../helm/#helm_get_hooks">helm get hooks</a>   - download all hooks for a named release</li>
<li><a href="../../helm/#helm_get_manifest">helm get manifest</a>     - download the manifest for a named release</li>
<li><a href="../../helm/#helm_get_notes">helm get notes</a>   - displays the notes of the named release</li>
<li><a href="../../helm/#helm_get_values">helm get values</a>     - download the values file for a named release</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-sep-2018">Auto generated by spf13/cobra on 1-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-get-hooks">helm get hooks</h2>

<p>download all hooks for a named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command downloads hooks for a given release.</p>

<p>Hooks are formatted in YAML and separated by the YAML &lsquo;&mdash;\n&rsquo; separator.</p>

<pre><code>helm get hooks [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                  help for hooks
      --revision int32        get the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_get">helm get</a>   - download a named release</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-get-manifest">helm get manifest</h2>

<p>download the manifest for a named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command fetches the generated manifest for a given release.</p>

<p>A manifest is a YAML-encoded representation of the Kubernetes resources that
were generated from this release&rsquo;s chart(s). If a chart is dependent on other
charts, those resources will also be included in the manifest.</p>

<pre><code>helm get manifest [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                  help for manifest
      --revision int32        get the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_get">helm get</a>   - download a named release</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-get-notes">helm get notes</h2>

<p>displays the notes of the named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command shows notes provided by the chart of a named release.</p>

<pre><code>helm get notes [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                  help for notes
      --revision int32        get the notes of the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_get">helm get</a>   - download a named release</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-sep-2018">Auto generated by spf13/cobra on 1-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-get-values">helm get values</h2>

<p>download the values file for a named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command downloads a values file for a given release.</p>

<pre><code>helm get values [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -a, --all                   dump all (computed) values
  -h, --help                  help for values
      --output string         output the specified format (json or yaml) (default &quot;yaml&quot;)
      --revision int32        get the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_get">helm get</a>   - download a named release</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-7-sep-2018">Auto generated by spf13/cobra on 7-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-history">helm history</h2>

<p>fetch release history</p>

<h3 id="synopsis">Synopsis</h3>

<p>History prints historical revisions for a given release.</p>

<p>A default maximum of 256 revisions will be returned. Setting &lsquo;&ndash;max&rsquo;
configures the maximum length of the revision list returned.</p>

<p>The historical release set is printed as a formatted table, e.g:</p>

<pre><code>$ helm history angry-bird --max=4
REVISION   UPDATED                      STATUS           CHART        DESCRIPTION
1           Mon Oct 3 10:15:13 2016     SUPERSEDED      alpine-0.1.0  Initial install
2           Mon Oct 3 10:15:13 2016     SUPERSEDED      alpine-0.1.0  Upgraded successfully
3           Mon Oct 3 10:15:13 2016     SUPERSEDED      alpine-0.1.0  Rolled back to 2
4           Mon Oct 3 10:15:13 2016     DEPLOYED        alpine-0.1.0  Upgraded successfully
</code></pre>

<pre><code>helm history [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --col-width uint        specifies the max column width of output (default 60)
  -h, --help                  help for history
      --max int32             maximum number of revision to include in history (default 256)
  -o, --output string         prints the output in the specified format (json|table|yaml) (default &quot;table&quot;)
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-home">helm home</h2>

<p>displays the location of HELM_HOME</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command displays the location of HELM_HOME. This is where
any helm configuration files live.</p>

<pre><code>helm home [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for home
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-init">helm init</h2>

<p>initialize Helm on both client and server</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command installs Tiller (the Helm server-side component) onto your
Kubernetes Cluster and sets up local configuration in $HELM_HOME (default ~/.helm/).</p>

<p>As with the rest of the Helm commands, &lsquo;helm init&rsquo; discovers Kubernetes clusters
by reading $KUBECONFIG (default &lsquo;~/.kube/config&rsquo;) and using the default context.</p>

<p>To set up just a local environment, use &lsquo;&ndash;client-only&rsquo;. That will configure
$HELM_HOME, but not attempt to connect to a Kubernetes cluster and install the Tiller
deployment.</p>

<p>When installing Tiller, &lsquo;helm init&rsquo; will attempt to install the latest released
version. You can specify an alternative image with &lsquo;&ndash;tiller-image&rsquo;. For those
frequently working on the latest code, the flag &lsquo;&ndash;canary-image&rsquo; will install
the latest pre-release version of Tiller (e.g. the HEAD commit in the GitHub
repository on the master branch).</p>

<p>To dump a manifest containing the Tiller deployment YAML, combine the
&lsquo;&ndash;dry-run&rsquo; and &lsquo;&ndash;debug&rsquo; flags.</p>

<pre><code>helm init [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --automount-service-account-token   auto-mount the given service account to tiller (default true)
      --canary-image                      use the canary Tiller image
  -c, --client-only                       if set does not install Tiller
      --dry-run                           do not install local or remote
      --force-upgrade                     force upgrade of Tiller to the current helm version
  -h, --help                              help for init
      --history-max int                   limit the maximum number of revisions saved per release. Use 0 for no limit.
      --local-repo-url string             URL for local repository (default &quot;http://127.0.0.1:8879/charts&quot;)
      --net-host                          install Tiller with net=host
      --node-selectors string             labels to specify the node on which Tiller is installed (app=tiller,helm=rocks)
  -o, --output OutputFormat               skip installation and output Tiller's manifest in specified format (json or yaml)
      --override stringArray              override values for the Tiller Deployment manifest (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --replicas int                      amount of tiller instances to run on the cluster (default 1)
      --service-account string            name of service account
      --skip-refresh                      do not refresh (download) the local repository cache
      --stable-repo-url string            URL for stable repository (default &quot;https://kubernetes-charts.storage.googleapis.com&quot;)
  -i, --tiller-image string               override Tiller image
      --tiller-tls                        install Tiller with TLS enabled
      --tiller-tls-cert string            path to TLS certificate file to install with Tiller
      --tiller-tls-hostname string        the server name used to verify the hostname on the returned certificates from Tiller
      --tiller-tls-key string             path to TLS key file to install with Tiller
      --tiller-tls-verify                 install Tiller with TLS enabled and to verify remote certificates
      --tls-ca-cert string                path to CA root certificate
      --upgrade                           upgrade if Tiller is already installed
      --wait                              block until Tiller is running and ready to receive requests
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-4-sep-2018">Auto generated by spf13/cobra on 4-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-inspect">helm inspect</h2>

<p>inspect a chart</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command inspects a chart and displays information. It takes a chart reference
(&lsquo;stable/drupal&rsquo;), a full path to a directory or packaged chart, or a URL.</p>

<p>Inspect prints the contents of the Chart.yaml file and the values.yaml file.</p>

<pre><code>helm inspect [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string     chart repository url where to locate the requested chart
      --cert-file string   verify certificates of HTTPS-enabled servers using this CA bundle
  -h, --help               help for inspect
      --key-file string    identify HTTPS client using this SSL key file
      --keyring string     path to the keyring containing public verification keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --password string    chart repository password where to locate the requested chart
      --repo string        chart repository url where to locate the requested chart
      --username string    chart repository username where to locate the requested chart
      --verify             verify the provenance data for this chart
      --version string     version of the chart. By default, the newest chart is shown
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
<li><a href="../../helm/#helm_inspect_chart">helm inspect chart</a>   - shows inspect chart</li>
<li><a href="../../helm/#helm_inspect_readme">helm inspect readme</a>     - shows inspect readme</li>
<li><a href="../../helm/#helm_inspect_values">helm inspect values</a>     - shows inspect values</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-inspect-chart">helm inspect chart</h2>

<p>shows inspect chart</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command inspects a chart (directory, file, or URL) and displays the contents
of the Charts.yaml file</p>

<pre><code>helm inspect chart [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string     chart repository url where to locate the requested chart
      --cert-file string   verify certificates of HTTPS-enabled servers using this CA bundle
  -h, --help               help for chart
      --key-file string    identify HTTPS client using this SSL key file
      --keyring string     path to the keyring containing public verification keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --password string    chart repository password where to locate the requested chart
      --repo string        chart repository url where to locate the requested chart
      --username string    chart repository username where to locate the requested chart
      --verify             verify the provenance data for this chart
      --version string     version of the chart. By default, the newest chart is shown
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_inspect">helm inspect</a>   - inspect a chart</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-inspect-readme">helm inspect readme</h2>

<p>shows inspect readme</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command inspects a chart (directory, file, or URL) and displays the contents
of the README file</p>

<pre><code>helm inspect readme [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string     chart repository url where to locate the requested chart
      --cert-file string   verify certificates of HTTPS-enabled servers using this CA bundle
  -h, --help               help for readme
      --key-file string    identify HTTPS client using this SSL key file
      --keyring string     path to the keyring containing public verification keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --repo string        chart repository url where to locate the requested chart
      --verify             verify the provenance data for this chart
      --version string     version of the chart. By default, the newest chart is shown
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_inspect">helm inspect</a>   - inspect a chart</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-inspect-values">helm inspect values</h2>

<p>shows inspect values</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command inspects a chart (directory, file, or URL) and displays the contents
of the values.yaml file</p>

<pre><code>helm inspect values [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string     chart repository url where to locate the requested chart
      --cert-file string   verify certificates of HTTPS-enabled servers using this CA bundle
  -h, --help               help for values
      --key-file string    identify HTTPS client using this SSL key file
      --keyring string     path to the keyring containing public verification keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --password string    chart repository password where to locate the requested chart
      --repo string        chart repository url where to locate the requested chart
      --username string    chart repository username where to locate the requested chart
      --verify             verify the provenance data for this chart
      --version string     version of the chart. By default, the newest chart is shown
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_inspect">helm inspect</a>   - inspect a chart</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-install">helm install</h2>

<p>install a chart archive</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command installs a chart archive.</p>

<p>The install argument must be a chart reference, a path to a packaged chart,
a path to an unpacked chart directory or a URL.</p>

<p>To override values in a chart, use either the &lsquo;&ndash;values&rsquo; flag and pass in a file
or use the &lsquo;&ndash;set&rsquo; flag and pass configuration from the command line.  To force string
values in &lsquo;&ndash;set&rsquo;, use &lsquo;&ndash;set-string&rsquo; instead. In case a value is large and therefore
you want not to use neither &lsquo;&ndash;values&rsquo; nor &lsquo;&ndash;set&rsquo;, use &lsquo;&ndash;set-file&rsquo; to read the
single large value from file.</p>

<pre><code>$ helm install -f myvalues.yaml ./redis
</code></pre>

<p>or</p>

<pre><code>$ helm install --set name=prod ./redis
</code></pre>

<p>or</p>

<pre><code>$ helm install --set-string long_int=1234567890 ./redis
</code></pre>

<p>or
    $ helm install &ndash;set-file multiline_text=path/to/textfile</p>

<p>You can specify the &lsquo;&ndash;values&rsquo;/&lsquo;-f&rsquo; flag multiple times. The priority will be given to the
last (right-most) file specified. For example, if both myvalues.yaml and override.yaml
contained a key called &lsquo;Test&rsquo;, the value set in override.yaml would take precedence:</p>

<pre><code>$ helm install -f myvalues.yaml -f override.yaml ./redis
</code></pre>

<p>You can specify the &lsquo;&ndash;set&rsquo; flag multiple times. The priority will be given to the
last (right-most) set specified. For example, if both &lsquo;bar&rsquo; and &lsquo;newbar&rsquo; values are
set for a key called &lsquo;foo&rsquo;, the &lsquo;newbar&rsquo; value would take precedence:</p>

<pre><code>$ helm install --set foo=bar --set foo=newbar ./redis
</code></pre>

<p>To check the generated manifests of a release without installing the chart,
the &lsquo;&ndash;debug&rsquo; and &lsquo;&ndash;dry-run&rsquo; flags can be combined. This will still require a
round-trip to the Tiller server.</p>

<p>If &ndash;verify is set, the chart MUST have a provenance file, and the provenance
file MUST pass all verification steps.</p>

<p>There are five different ways you can express the chart you want to install:</p>

<ol>
<li>By chart reference: helm install stable/mariadb</li>
<li>By path to a packaged chart: helm install ./nginx-1.2.3.tgz</li>
<li>By path to an unpacked chart directory: helm install ./nginx</li>
<li>By absolute URL: helm install <a href="https://example.com/charts/nginx-1.2.3.tgz">https://example.com/charts/nginx-1.2.3.tgz</a></li>
<li>By chart reference and repo url: helm install &ndash;repo <a href="https://example.com/charts/">https://example.com/charts/</a> nginx</li>
</ol>

<p>CHART REFERENCES</p>

<p>A chart reference is a convenient way of reference a chart in a chart repository.</p>

<p>When you use a chart reference with a repo prefix (&lsquo;stable/mariadb&rsquo;), Helm will look in the local
configuration for a chart repository named &lsquo;stable&rsquo;, and will then look for a
chart in that repository whose name is &lsquo;mariadb&rsquo;. It will install the latest
version of that chart unless you also supply a version number with the
&lsquo;&ndash;version&rsquo; flag.</p>

<p>To see the list of chart repositories, use &lsquo;helm repo list&rsquo;. To search for
charts in a repository, use &lsquo;helm search&rsquo;.</p>

<pre><code>helm install [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string           verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string         identify HTTPS client using this SSL certificate file
      --dep-up                   run helm dependency update before installing the chart
      --description string       specify a description for the release
      --devel                    use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored.
      --dry-run                  simulate an install
  -h, --help                     help for install
      --key-file string          identify HTTPS client using this SSL key file
      --keyring string           location of public keys used for verification (default &quot;~/.gnupg/pubring.gpg&quot;)
  -n, --name string              release name. If unspecified, it will autogenerate one for you
      --name-template string     specify template used to name the release
      --namespace string         namespace to install the release into. Defaults to the current kube config namespace.
      --no-crd-hook              prevent CRD hooks from running, but run other hooks
      --no-hooks                 prevent hooks from running during install
      --password string          chart repository password where to locate the requested chart
      --replace                  re-use the given name, even if that name is already used. This is unsafe in production
      --repo string              chart repository url where to locate the requested chart
      --set stringArray          set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray     set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-string stringArray   set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --timeout int              time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks) (default 300)
      --tls                      enable TLS for request
      --tls-ca-cert string       path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string          path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string      the server name used to verify the hostname on the returned certificates from the server
      --tls-key string           path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify               enable TLS for request and verify remote
      --username string          chart repository username where to locate the requested chart
  -f, --values valueFiles        specify values in a YAML file or a URL(can specify multiple) (default [])
      --verify                   verify the package before installing it
      --version string           specify the exact chart version to install. If this is not specified, the latest version is installed
      --wait                     if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are in a ready state before marking the release as successful. It will wait for as long as --timeout
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-lint">helm lint</h2>

<p>examines a chart for possible issues</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command takes a path to a chart and runs a series of tests to verify that
the chart is well-formed.</p>

<p>If the linter encounters things that will cause the chart to fail installation,
it will emit [ERROR] messages. If it encounters issues that break with convention
or recommendation, it will emit [WARNING] messages.</p>

<pre><code>helm lint [flags] PATH
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                     help for lint
      --namespace string         namespace to put the release into (default &quot;default&quot;)
      --set stringArray          set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray     set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-string stringArray   set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --strict                   fail on lint warnings
  -f, --values valueFiles        specify values in a YAML file (can specify multiple) (default [])
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-list">helm list</h2>

<p>list releases</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command lists all of the releases.</p>

<p>By default, it lists only releases that are deployed or failed. Flags like
&lsquo;&ndash;deleted&rsquo; and &lsquo;&ndash;all&rsquo; will alter this behavior. Such flags can be combined:
&lsquo;&ndash;deleted &ndash;failed&rsquo;.</p>

<p>By default, items are sorted alphabetically. Use the &lsquo;-d&rsquo; flag to sort by
release date.</p>

<p>If an argument is provided, it will be treated as a filter. Filters are
regular expressions (Perl compatible) that are applied to the list of releases.
Only items that match the filter will be returned.</p>

<pre><code>$ helm list 'ara[a-z]+'
NAME                UPDATED                     CHART
maudlin-arachnid    Mon May  9 16:07:08 2016    alpine-0.1.0
</code></pre>

<p>If no results are found, &lsquo;helm list&rsquo; will exit 0, but with no output (or in
the case of no &lsquo;-q&rsquo; flag, only headers).</p>

<p>By default, up to 256 items may be returned. To limit this, use the &lsquo;&ndash;max&rsquo; flag.
Setting &lsquo;&ndash;max&rsquo; to 0 will not return all results. Rather, it will return the
server&rsquo;s default, which may be much higher than 256. Pairing the &lsquo;&ndash;max&rsquo;
flag with the &lsquo;&ndash;offset&rsquo; flag allows you to page through results.</p>

<pre><code>helm list [flags] [FILTER]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -a, --all                   show all releases, not just the ones marked DEPLOYED
  -c, --chart-name            sort by chart name
      --col-width uint        specifies the max column width of output (default 60)
  -d, --date                  sort by release date
      --deleted               show deleted releases
      --deleting              show releases that are currently being deleted
      --deployed              show deployed releases. If no other is specified, this will be automatically enabled
      --failed                show failed releases
  -h, --help                  help for list
  -m, --max int               maximum number of releases to fetch (default 256)
      --namespace string      show releases within a specific namespace
  -o, --offset string         next release name in the list, used to offset from start value
      --output string         output the specified format (json or yaml)
      --pending               show pending releases
  -r, --reverse               reverse the sort order
  -q, --short                 output short (quiet) listing format
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-sep-2018">Auto generated by spf13/cobra on 1-Sep-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-package">helm package</h2>

<p>package a chart directory into a chart archive</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command packages a chart into a versioned chart archive file. If a path
is given, this will look at that path for a chart (which must contain a
Chart.yaml file) and then package that directory.</p>

<p>If no path is given, this will look in the present working directory for a
Chart.yaml file, and (if found) build the current directory into a chart.</p>

<p>Versioned chart archives are used by Helm package repositories.</p>

<pre><code>helm package [flags] [CHART_PATH] [...]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --app-version string   set the appVersion on the chart to this version
  -u, --dependency-update    update dependencies from &quot;requirements.yaml&quot; to dir &quot;charts/&quot; before packaging
  -d, --destination string   location to write the chart. (default &quot;.&quot;)
  -h, --help                 help for package
      --key string           name of the key to use when signing. Used if --sign is true
      --keyring string       location of a public keyring (default &quot;~/.gnupg/pubring.gpg&quot;)
      --save                 save packaged chart to local chart repository (default true)
      --sign                 use a PGP private key to sign this package
      --version string       set the version on the chart to this semver version
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-plugin">helm plugin</h2>

<p>add, list, or remove Helm plugins</p>

<h3 id="synopsis">Synopsis</h3>

<p>Manage client-side Helm plugins.</p>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for plugin
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
<li><a href="../../helm/#helm_plugin_install">helm plugin install</a>     - install one or more Helm plugins</li>
<li><a href="../../helm/#helm_plugin_list">helm plugin list</a>   - list installed Helm plugins</li>
<li><a href="../../helm/#helm_plugin_remove">helm plugin remove</a>   - remove one or more Helm plugins</li>
<li><a href="../../helm/#helm_plugin_update">helm plugin update</a>   - update one or more Helm plugins</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-plugin-install">helm plugin install</h2>

<p>install one or more Helm plugins</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command allows you to install a plugin from a url to a VCS repo or a local path.</p>

<p>Example usage:
    $ helm plugin install <a href="https://github.com/technosophos/helm-template">https://github.com/technosophos/helm-template</a></p>

<pre><code>helm plugin install [options] &lt;path|url&gt;... [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help             help for install
      --version string   specify a version constraint. If this is not specified, the latest version is installed
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_plugin">helm plugin</a>     - add, list, or remove Helm plugins</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-plugin-list">helm plugin list</h2>

<p>list installed Helm plugins</p>

<h3 id="synopsis">Synopsis</h3>

<p>list installed Helm plugins</p>

<pre><code>helm plugin list [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for list
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_plugin">helm plugin</a>     - add, list, or remove Helm plugins</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-plugin-remove">helm plugin remove</h2>

<p>remove one or more Helm plugins</p>

<h3 id="synopsis">Synopsis</h3>

<p>remove one or more Helm plugins</p>

<pre><code>helm plugin remove &lt;plugin&gt;... [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for remove
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_plugin">helm plugin</a>     - add, list, or remove Helm plugins</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-plugin-update">helm plugin update</h2>

<p>update one or more Helm plugins</p>

<h3 id="synopsis">Synopsis</h3>

<p>update one or more Helm plugins</p>

<pre><code>helm plugin update &lt;plugin&gt;... [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for update
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_plugin">helm plugin</a>     - add, list, or remove Helm plugins</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo">helm repo</h2>

<p>add, list, remove, update, and index chart repositories</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command consists of multiple subcommands to interact with chart repositories.</p>

<p>It can be used to add, remove, list, and index chart repositories.
Example usage:
    $ helm repo add [NAME] [REPO_URL]</p>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for repo
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
<li><a href="../../helm/#helm_repo_add">helm repo add</a>     - add a chart repository</li>
<li><a href="../../helm/#helm_repo_index">helm repo index</a>     - generate an index file given a directory containing packaged charts</li>
<li><a href="../../helm/#helm_repo_list">helm repo list</a>   - list chart repositories</li>
<li><a href="../../helm/#helm_repo_remove">helm repo remove</a>   - remove a chart repository</li>
<li><a href="../../helm/#helm_repo_update">helm repo update</a>   - update information of available charts locally from chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo-add">helm repo add</h2>

<p>add a chart repository</p>

<h3 id="synopsis">Synopsis</h3>

<p>add a chart repository</p>

<pre><code>helm repo add [flags] [NAME] [URL]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string     verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string   identify HTTPS client using this SSL certificate file
  -h, --help               help for add
      --key-file string    identify HTTPS client using this SSL key file
      --no-update          raise error if repo is already registered
      --password string    chart repository password
      --username string    chart repository username
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo-index">helm repo index</h2>

<p>generate an index file given a directory containing packaged charts</p>

<h3 id="synopsis">Synopsis</h3>

<p>Read the current directory and generate an index file based on the charts found.</p>

<p>This tool is used for creating an &lsquo;index.yaml&rsquo; file for a chart repository. To
set an absolute URL to the charts, use &lsquo;&ndash;url&rsquo; flag.</p>

<p>To merge the generated index with an existing index file, use the &lsquo;&ndash;merge&rsquo;
flag. In this case, the charts found in the current directory will be merged
into the existing index, with local charts taking priority over existing charts.</p>

<pre><code>helm repo index [flags] [DIR]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help           help for index
      --merge string   merge the generated index into the given index
      --url string     url of chart repository
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo-list">helm repo list</h2>

<p>list chart repositories</p>

<h3 id="synopsis">Synopsis</h3>

<p>list chart repositories</p>

<pre><code>helm repo list [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for list
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo-remove">helm repo remove</h2>

<p>remove a chart repository</p>

<h3 id="synopsis">Synopsis</h3>

<p>remove a chart repository</p>

<pre><code>helm repo remove [flags] [NAME]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help   help for remove
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-repo-update">helm repo update</h2>

<p>update information of available charts locally from chart repositories</p>

<h3 id="synopsis">Synopsis</h3>

<p>Update gets the latest information about charts from the respective chart repositories.
Information is cached locally, where it is used by commands like &lsquo;helm search&rsquo;.</p>

<p>&lsquo;helm update&rsquo; is the deprecated form of &lsquo;helm repo update&rsquo;. It will be removed in
future releases.</p>

<pre><code>helm repo update [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help     help for update
      --strict   fail on update warnings
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm_repo">helm repo</a>     - add, list, remove, update, and index chart repositories</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-15-nov-2018">Auto generated by spf13/cobra on 15-Nov-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-reset">helm reset</h2>

<p>uninstalls Tiller from a cluster</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command uninstalls Tiller (the Helm server-side component) from your
Kubernetes Cluster and optionally deletes local configuration in
$HELM_HOME (default ~/.helm/)</p>

<pre><code>helm reset [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -f, --force                 forces Tiller uninstall even if there are releases installed, or if Tiller is not in ready state. Releases are not deleted.)
  -h, --help                  help for reset
      --remove-helm-home      if set deletes $HELM_HOME
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-rollback">helm rollback</h2>

<p>roll back a release to a previous revision</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command rolls back a release to a previous revision.</p>

<p>The first argument of the rollback command is the name of a release, and the
second is a revision (version) number. To see revision numbers, run
&lsquo;helm history RELEASE&rsquo;.</p>

<pre><code>helm rollback [flags] [RELEASE] [REVISION]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --description string    specify a description for the release
      --dry-run               simulate a rollback
      --force                 force resource update through delete/recreate if needed
  -h, --help                  help for rollback
      --no-hooks              prevent hooks from running during rollback
      --recreate-pods         performs pods restart for the resource if applicable
      --timeout int           time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks) (default 300)
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
      --wait                  if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are in a ready state before marking the release as successful. It will wait for as long as --timeout
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-search">helm search</h2>

<p>search for a keyword in charts</p>

<h3 id="synopsis">Synopsis</h3>

<p>Search reads through all of the repositories configured on the system, and
looks for matches.</p>

<p>Repositories are managed with &lsquo;helm repo&rsquo; commands.</p>

<pre><code>helm search [keyword] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --col-width uint   specifies the max column width of output (default 60)
  -h, --help             help for search
  -r, --regexp           use regular expressions for searching
  -v, --version string   search using semantic versioning constraints
  -l, --versions         show the long listing, with each version of each chart on its own line
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-serve">helm serve</h2>

<p>start a local http web server</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command starts a local chart repository server that serves charts from a local directory.</p>

<p>The new server will provide HTTP access to a repository. By default, it will
scan all of the charts in &lsquo;$HELM_HOME/repository/local&rsquo; and serve those over
the local IPv4 TCP port (default &lsquo;127.0.0.1:8879&rsquo;).</p>

<p>This command is intended to be used for educational and testing purposes only.
It is best to rely on a dedicated web server or a cloud-hosted solution like
Google Cloud Storage for production use.</p>

<p>See <a href="https://github.com/helm/helm/blob/master/docs/developing_charts.md#hosting-chart-repositories">https://github.com/helm/helm/blob/master/docs/developing_charts.md#hosting-chart-repositories</a>
for more information on hosting chart repositories in a production setting.</p>

<pre><code>helm serve [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --address string     address to listen on (default &quot;127.0.0.1:8879&quot;)
  -h, --help               help for serve
      --repo-path string   local directory path from which to serve charts
      --url string         external URL of chart repository
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-status">helm status</h2>

<p>displays the status of the named release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command shows the status of a named release.
The status consists of:
- last deployment time
- k8s namespace in which the release lives
- state of the release (can be: UNKNOWN, DEPLOYED, DELETED, SUPERSEDED, FAILED or DELETING)
- list of resources that this release consists of, sorted by kind
- details on last test suite run, if applicable
- additional notes provided by the chart</p>

<pre><code>helm status [flags] RELEASE_NAME
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help                  help for status
  -o, --output string         output the status in the specified format (json or yaml)
      --revision int32        if set, display the status of the named release with revision
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-template">helm template</h2>

<p>locally render templates</p>

<h3 id="synopsis">Synopsis</h3>

<p>Render chart templates locally and display the output.</p>

<p>This does not require Tiller. However, any values that would normally be
looked up or retrieved in-cluster will be faked locally. Additionally, none
of the server-side testing of chart validity (e.g. whether an API is supported)
is done.</p>

<p>To render just one template in a chart, use &lsquo;-x&rsquo;:</p>

<pre><code>$ helm template mychart -x templates/deployment.yaml
</code></pre>

<pre><code>helm template [flags] CHART
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -x, --execute stringArray      only execute the given templates
  -h, --help                     help for template
      --is-upgrade               set .Release.IsUpgrade instead of .Release.IsInstall
      --kube-version string      kubernetes version used as Capabilities.KubeVersion.Major/Minor (default &quot;1.9&quot;)
  -n, --name string              release name (default &quot;release-name&quot;)
      --name-template string     specify template used to name the release
      --namespace string         namespace to install the release into
      --notes                    show the computed NOTES.txt file as well
      --output-dir string        writes the executed templates to files in output-dir instead of stdout
      --set stringArray          set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray     set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-string stringArray   set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
  -f, --values valueFiles        specify values in a YAML file (can specify multiple) (default [])
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-test">helm test</h2>

<p>test a release</p>

<h3 id="synopsis">Synopsis</h3>

<p>The test command runs the tests for a release.</p>

<p>The argument this command takes is the name of a deployed release.
The tests to be run are defined in the chart that was installed.</p>

<pre><code>helm test [RELEASE] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --cleanup               delete test pods upon completion
  -h, --help                  help for test
      --parallel              run test pods in parallel
      --timeout int           time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks) (default 300)
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-9-nov-2018">Auto generated by spf13/cobra on 9-Nov-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-upgrade">helm upgrade</h2>

<p>upgrade a release</p>

<h3 id="synopsis">Synopsis</h3>

<p>This command upgrades a release to a specified version of a chart and/or updates chart values.</p>

<p>Required arguments are release and chart. The chart argument can be one of:
 - a chart reference(&lsquo;stable/mariadb&rsquo;); use &lsquo;&ndash;version&rsquo; and &lsquo;&ndash;devel&rsquo; flags for versions other than latest,
 - a path to a chart directory,
 - a packaged chart,
 - a fully qualified URL.</p>

<p>To customize the chart values, use any of
 - &lsquo;&ndash;values&rsquo;/&lsquo;-f&rsquo; to pass in a yaml file holding settings,
 - &lsquo;&ndash;set&rsquo; to provide one or more key=val pairs directly,
 - &lsquo;&ndash;set-string&rsquo; to provide key=val forcing val to be stored as a string,
 - &lsquo;&ndash;set-file&rsquo; to provide key=path to read a single large value from a file at path.</p>

<p>To edit or append to the existing customized values, add the
 &lsquo;&ndash;reuse-values&rsquo; flag, otherwise any existing customized values are ignored.</p>

<p>If no chart value arguments are provided on the command line, any existing customized values are carried
forward. If you want to revert to just the values provided in the chart, use the &lsquo;&ndash;reset-values&rsquo; flag.</p>

<p>You can specify any of the chart value flags multiple times. The priority will be given to the last
(right-most) value specified. For example, if both myvalues.yaml and override.yaml contained a key
called &lsquo;Test&rsquo;, the value set in override.yaml would take precedence:</p>

<pre><code>$ helm upgrade -f myvalues.yaml -f override.yaml redis ./redis
</code></pre>

<p>Note that the key name provided to the &lsquo;&ndash;set&rsquo;, &lsquo;&ndash;set-string&rsquo; and &lsquo;&ndash;set-file&rsquo; flags can reference
structure elements. Examples:
  - mybool=TRUE
  - livenessProbe.timeoutSeconds=10
  - metrics.annotations[0]=hey,metrics.annotations[1]=ho</p>

<p>which sets the top level key mybool to true, the nested timeoutSeconds to 10, and two array values, respectively.</p>

<p>Note that the value side of the key=val provided to &lsquo;&ndash;set&rsquo; and &lsquo;&ndash;set-string&rsquo; flags will pass through
shell evaluation followed by yaml type parsing to produce the final value. This may alter inputs with
special characters in unexpected ways, for example</p>

<pre><code>$ helm upgrade --set pwd=3jk$o2,z=f\30.e redis ./redis
</code></pre>

<p>results in &ldquo;pwd: 3jk&rdquo; and &ldquo;z: f30.e&rdquo;. Use single quotes to avoid shell evaluation and argument delimiters,
and use backslash to escape yaml special characters:</p>

<pre><code>$ helm upgrade --set pwd='3jk$o2z=f\\30.e' redis ./redis
</code></pre>

<p>which results in the expected &ldquo;pwd: 3jk$o2z=f\30.e&rdquo;. If a single quote occurs in your value then follow
your shell convention for escaping it; for example in bash:</p>

<pre><code>$ helm upgrade --set pwd='3jk$o2z=f\\30with'\''quote'
</code></pre>

<p>which results in &ldquo;pwd: 3jk$o2z=f\30with&rsquo;quote&rdquo;.</p>

<pre><code>helm upgrade [RELEASE] [CHART] [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>      --ca-file string           verify certificates of HTTPS-enabled servers using this CA bundle
      --cert-file string         identify HTTPS client using this SSL certificate file
      --description string       specify the description to use for the upgrade, rather than the default
      --devel                    use development versions, too. Equivalent to version '&gt;0.0.0-0'. If --version is set, this is ignored.
      --dry-run                  simulate an upgrade
      --force                    force resource update through delete/recreate if needed
  -h, --help                     help for upgrade
  -i, --install                  if a release by this name doesn't already exist, run an install
      --key-file string          identify HTTPS client using this SSL key file
      --keyring string           path to the keyring that contains public signing keys (default &quot;~/.gnupg/pubring.gpg&quot;)
      --namespace string         namespace to install the release into (only used if --install is set). Defaults to the current kube config namespace
      --no-hooks                 disable pre/post upgrade hooks
      --password string          chart repository password where to locate the requested chart
      --recreate-pods            performs pods restart for the resource if applicable
      --repo string              chart repository url where to locate the requested chart
      --reset-values             when upgrading, reset the values to the ones built into the chart
      --reuse-values             when upgrading, reuse the last release's values and merge in any overrides from the command line via --set and -f. If '--reset-values' is specified, this is ignored.
      --set stringArray          set values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --set-file stringArray     set values from respective files specified via the command line (can specify multiple or separate values with commas: key1=path1,key2=path2)
      --set-string stringArray   set STRING values on the command line (can specify multiple or separate values with commas: key1=val1,key2=val2)
      --timeout int              time in seconds to wait for any individual Kubernetes operation (like Jobs for hooks) (default 300)
      --tls                      enable TLS for request
      --tls-ca-cert string       path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string          path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string      the server name used to verify the hostname on the returned certificates from the server
      --tls-key string           path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify               enable TLS for request and verify remote
      --username string          chart repository username where to locate the requested chart
  -f, --values valueFiles        specify values in a YAML file or a URL(can specify multiple) (default [])
      --verify                   verify the provenance of the chart before upgrading
      --version string           specify the exact chart version to use. If this is not specified, the latest version is used
      --wait                     if set, will wait until all Pods, PVCs, Services, and minimum number of Pods of a Deployment are in a ready state before marking the release as successful. It will wait for as long as --timeout
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-24-aug-2018">Auto generated by spf13/cobra on 24-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-verify">helm verify</h2>

<p>verify that a chart at the given path has been signed and is valid</p>

<h3 id="synopsis">Synopsis</h3>

<p>Verify that the given chart has a valid provenance file.</p>

<p>Provenance files provide crytographic verification that a chart has not been
tampered with, and was packaged by a trusted provider.</p>

<p>This command can be used to verify a local chart. Several other commands provide
&lsquo;&ndash;verify&rsquo; flags that run the same validation. To generate a signed package, use
the &lsquo;helm package &ndash;sign&rsquo; command.</p>

<pre><code>helm verify [flags] PATH
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -h, --help             help for verify
      --keyring string   keyring containing public keys (default &quot;~/.gnupg/pubring.gpg&quot;)
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-1-aug-2018">Auto generated by spf13/cobra on 1-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="helm-version">helm version</h2>

<p>print the client/server version information</p>

<h3 id="synopsis">Synopsis</h3>

<p>Show the client and server versions for Helm and tiller.</p>

<p>This will print a representation of the client and server versions of Helm and
Tiller. The output will look something like this:</p>

<p>Client: &amp;version.Version{SemVer:&ldquo;v2.0.0&rdquo;, GitCommit:&ldquo;ff52399e51bb880526e9cd0ed8386f6433b74da1&rdquo;, GitTreeState:&ldquo;clean&rdquo;}
Server: &amp;version.Version{SemVer:&ldquo;v2.0.0&rdquo;, GitCommit:&ldquo;b0c113dfb9f612a9add796549da66c0d294508a3&rdquo;, GitTreeState:&ldquo;clean&rdquo;}</p>

<ul>
<li>SemVer is the semantic version of the release.</li>
<li>GitCommit is the SHA for the commit that this version was built from.</li>
<li>GitTreeState is &ldquo;clean&rdquo; if there are no local code changes when this binary was
built, and &ldquo;dirty&rdquo; if the binary was built from locally modified code.</li>
</ul>

<p>To print just the client version, use &lsquo;&ndash;client&rsquo;. To print just the server version,
use &lsquo;&ndash;server&rsquo;.</p>

<pre><code>helm version [flags]
</code></pre>

<h3 id="options">Options</h3>

<pre><code>  -c, --client                client version only
  -h, --help                  help for version
  -s, --server                server version only
      --short                 print the version number
      --template string       template for version string format
      --tls                   enable TLS for request
      --tls-ca-cert string    path to TLS CA certificate file (default &quot;$HELM_HOME/ca.pem&quot;)
      --tls-cert string       path to TLS certificate file (default &quot;$HELM_HOME/cert.pem&quot;)
      --tls-hostname string   the server name used to verify the hostname on the returned certificates from the server
      --tls-key string        path to TLS key file (default &quot;$HELM_HOME/key.pem&quot;)
      --tls-verify            enable TLS for request and verify remote
</code></pre>

<h3 id="options-inherited-from-parent-commands">Options inherited from parent commands</h3>

<pre><code>      --debug                           enable verbose output
      --home string                     location of your Helm config. Overrides $HELM_HOME (default &quot;~/.helm&quot;)
      --host string                     address of Tiller. Overrides $HELM_HOST
      --kube-context string             name of the kubeconfig context to use
      --kubeconfig string               absolute path to the kubeconfig file to use
      --tiller-connection-timeout int   the duration (in seconds) Helm will wait to establish a connection to tiller (default 300)
      --tiller-namespace string         namespace of Tiller (default &quot;kube-system&quot;)
</code></pre>

<h3 id="see-also">SEE ALSO</h3>

<ul>
<li><a href="../../helm/#helm">helm</a>   - The Helm package manager for Kubernetes.</li>
</ul>

<h6 id="auto-generated-by-spf13-cobra-on-10-aug-2018">Auto generated by spf13/cobra on 10-Aug-2018</h6>
</div>
</article>
          
            <article id="">
  <div>

<h2 id="the-history-of-the-project">The History of the Project</h2>

<p>Kubernetes Helm is the merged result of <a href="https://github.com/helm/helm">Helm
Classic</a> and the Kubernetes port of GCS Deployment
Manager. The project was jointly started by Google and Deis, though it
is now part of the CNCF. Many companies now contribute regularly to Helm.</p>

<p>Differences from Helm Classic:</p>

<ul>
<li>Helm now has both a client (<code>helm</code>) and a server (<code>tiller</code>). The
server runs inside of Kubernetes, and manages your resources.</li>
<li>Helm&rsquo;s chart format has changed for the better:

<ul>
<li>Dependencies are immutable and stored inside of a chart&rsquo;s <code>charts/</code>
directory.</li>
<li>Charts are strongly versioned using <a href="http://semver.org/spec/v2.0.0.html">SemVer 2</a></li>
<li>Charts can be loaded from directories or from chart archive files</li>
<li>Helm supports Go templates without requiring you to run <code>generate</code>
or <code>template</code> commands.</li>
<li>Helm makes it easy to configure your releases &ndash; and share the
configuration with the rest of your team.</li>
</ul></li>
<li>Helm chart repositories now use plain HTTP(S) instead of Git/GitHub.
There is no longer any GitHub dependency.

<ul>
<li>A chart server is a simple HTTP server</li>
<li>Charts are referenced by version</li>
<li>The <code>helm serve</code> command will run a local chart server, though you
can easily use object storage (S3, GCS) or a regular web server.</li>
<li>And you can still load charts from a local directory.</li>
</ul></li>
<li>The Helm workspace is gone. You can now work anywhere on your
filesystem that you want to work.</li>
</ul>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="installing-helm">Installing Helm</h1>

<p>There are two parts to Helm: The Helm client (<code>helm</code>) and the Helm
server (Tiller). This guide shows how to install the client, and then
proceeds to show two ways to install the server.</p>

<p><strong>IMPORTANT</strong>: If you are responsible for ensuring your cluster is a controlled environment, especially when resources are shared, it is strongly recommended installing Tiller using a secured configuration. For guidance, see <a href="./#securing-your-helm-installation">Securing your Helm Installation</a>.</p>

<h2 id="installing-the-helm-client">Installing the Helm Client</h2>

<p>The Helm client can be installed either from source, or from pre-built binary
releases.</p>

<h3 id="from-the-binary-releases">From the Binary Releases</h3>

<p>Every <a href="https://github.com/helm/helm/releases">release</a> of Helm
provides binary releases for a variety of OSes. These binary versions
can be manually downloaded and installed.</p>

<ol>
<li>Download your <a href="https://github.com/helm/helm/releases">desired version</a></li>
<li>Unpack it (<code>tar -zxvf helm-v2.0.0-linux-amd64.tgz</code>)</li>
<li>Find the <code>helm</code> binary in the unpacked directory, and move it to its
desired destination (<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li>
</ol>

<p>From there, you should be able to run the client: <code>helm help</code>.</p>

<h3 id="from-snap-linux">From Snap (Linux)</h3>

<p>The Snap package for Helm is maintained by
<a href="https://github.com/snapcrafters/helm">Snapcrafters</a>.</p>

<pre><code>$ sudo snap install helm --classic
</code></pre>

<h3 id="from-homebrew-macos">From Homebrew (macOS)</h3>

<p>Members of the Kubernetes community have contributed a Helm formula build to
Homebrew. This formula is generally up to date.</p>

<pre><code>brew install kubernetes-helm
</code></pre>

<p>(Note: There is also a formula for emacs-helm, which is a different
project.)</p>

<h3 id="from-chocolatey-windows">From Chocolatey (Windows)</h3>

<p>Members of the Kubernetes community have contributed a <a href="https://chocolatey.org/packages/kubernetes-helm">Helm package</a> build to
<a href="https://chocolatey.org/">Chocolatey</a>. This package is generally up to date.</p>

<pre><code>choco install kubernetes-helm
</code></pre>

<h2 id="from-script">From Script</h2>

<p>Helm now has an installer script that will automatically grab the latest version
of the Helm client and <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get">install it locally</a>.</p>

<p>You can fetch that script, and then execute it locally. It&rsquo;s well documented so
that you can read through it and understand what it is doing before you run it.</p>

<pre><code>$ curl https://raw.githubusercontent.com/helm/helm/master/scripts/get &gt; get_helm.sh
$ chmod 700 get_helm.sh
$ ./get_helm.sh
</code></pre>

<p>Yes, you can <code>curl https://raw.githubusercontent.com/helm/helm/master/scripts/get | bash</code> that if you want to live on the edge.</p>

<h3 id="from-canary-builds">From Canary Builds</h3>

<p>&ldquo;Canary&rdquo; builds are versions of the Helm software that are built from
the latest master branch. They are not official releases, and may not be
stable. However, they offer the opportunity to test the cutting edge
features.</p>

<p>Canary Helm binaries are stored in the <a href="https://kubernetes-helm.storage.googleapis.com">Kubernetes Helm GCS bucket</a>.
Here are links to the common builds:</p>

<ul>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-linux-amd64.tar.gz">Linux AMD64</a></li>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-darwin-amd64.tar.gz">macOS AMD64</a></li>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip">Experimental Windows AMD64</a></li>
</ul>

<h3 id="from-source-linux-macos">From Source (Linux, macOS)</h3>

<p>Building Helm from source is slightly more work, but is the best way to
go if you want to test the latest (pre-release) Helm version.</p>

<p>You must have a working Go environment with
<a href="https://github.com/Masterminds/glide">glide</a> installed.</p>

<pre><code class="language-console">$ cd $GOPATH
$ mkdir -p src/k8s.io
$ cd src/k8s.io
$ git clone https://github.com/helm/helm.git
$ cd helm
$ make bootstrap build
</code></pre>

<p>The <code>bootstrap</code> target will attempt to install dependencies, rebuild the
<code>vendor/</code> tree, and validate configuration.</p>

<p>The <code>build</code> target will compile <code>helm</code> and place it in <code>bin/helm</code>.
Tiller is also compiled, and is placed in <code>bin/tiller</code>.</p>

<h2 id="installing-tiller">Installing Tiller</h2>

<p>Tiller, the server portion of Helm, typically runs inside of your
Kubernetes cluster. But for development, it can also be run locally, and
configured to talk to a remote Kubernetes cluster.</p>

<h3 id="special-note-for-rbac-users">Special Note for RBAC Users</h3>

<p>Most cloud providers enable a feature called Role-Based Access Control - RBAC for short. If your cloud provider enables this feature, you will need to create a service account for Tiller with the right roles and permissions to access resources.</p>

<p>Check the <a href="./#kubernetes_distros.md">Kubernetes Distribution Guide</a> to see if there&rsquo;s any further points of interest on using Helm with your cloud provider. Also check out the guide on <a href="rbac">Tiller and Role-Based Access Control</a> for more information on how to run Tiller in an RBAC-enabled Kubernetes cluster.</p>

<h3 id="easy-in-cluster-installation">Easy In-Cluster Installation</h3>

<p>The easiest way to install <code>tiller</code> into the cluster is simply to run
<code>helm init</code>. This will validate that <code>helm</code>&rsquo;s local environment is set
up correctly (and set it up if necessary). Then it will connect to
whatever cluster <code>kubectl</code> connects to by default (<code>kubectl config
view</code>). Once it connects, it will install <code>tiller</code> into the
<code>kube-system</code> namespace.</p>

<p>After <code>helm init</code>, you should be able to run <code>kubectl get pods --namespace
kube-system</code> and see Tiller running.</p>

<p>You can explicitly tell <code>helm init</code> to&hellip;</p>

<ul>
<li>Install the canary build with the <code>--canary-image</code> flag</li>
<li>Install a particular image (version) with <code>--tiller-image</code></li>
<li>Install to a particular cluster with <code>--kube-context</code></li>
<li>Install into a particular namespace with <code>--tiller-namespace</code></li>
<li>Install Tiller with a Service Account with <code>--service-account</code> (for <a href="securing-your-helm-installation.md#role-based-access-control">RBAC enabled clusters</a>)</li>
<li>Install Tiller without mounting a service account with <code>--automount-service-account false</code></li>
</ul>

<p>Once Tiller is installed, running <code>helm version</code> should show you both
the client and server version. (If it shows only the client version,
<code>helm</code> cannot yet connect to the server. Use <code>kubectl</code> to see if any
<code>tiller</code> pods are running.)</p>

<p>Helm will look for Tiller in the <code>kube-system</code> namespace unless
<code>--tiller-namespace</code> or <code>TILLER_NAMESPACE</code> is set.</p>

<h3 id="installing-tiller-canary-builds">Installing Tiller Canary Builds</h3>

<p>Canary images are built from the <code>master</code> branch. They may not be
stable, but they offer you the chance to test out the latest features.</p>

<p>The easiest way to install a canary image is to use <code>helm init</code> with the
<code>--canary-image</code> flag:</p>

<pre><code class="language-console">$ helm init --canary-image
</code></pre>

<p>This will use the most recently built container image. You can always
uninstall Tiller by deleting the Tiller deployment from the
<code>kube-system</code> namespace using <code>kubectl</code>.</p>

<h3 id="running-tiller-locally">Running Tiller Locally</h3>

<p>For development, it is sometimes easier to work on Tiller locally, and
configure it to connect to a remote Kubernetes cluster.</p>

<p>The process of building Tiller is explained above.</p>

<p>Once <code>tiller</code> has been built, simply start it:</p>

<pre><code class="language-console">$ bin/tiller
Tiller running on :44134
</code></pre>

<p>When Tiller is running locally, it will attempt to connect to the
Kubernetes cluster that is configured by <code>kubectl</code>. (Run <code>kubectl config
view</code> to see which cluster that is.)</p>

<p>You must tell <code>helm</code> to connect to this new local Tiller host instead of
connecting to the one in-cluster. There are two ways to do this. The
first is to specify the <code>--host</code> option on the command line. The second
is to set the <code>$HELM_HOST</code> environment variable.</p>

<pre><code class="language-console">$ export HELM_HOST=localhost:44134
$ helm version # Should connect to localhost.
Client: &amp;version.Version{SemVer:&quot;v2.0.0-alpha.4&quot;, GitCommit:&quot;db...&quot;, GitTreeState:&quot;dirty&quot;}
Server: &amp;version.Version{SemVer:&quot;v2.0.0-alpha.4&quot;, GitCommit:&quot;a5...&quot;, GitTreeState:&quot;dirty&quot;}
</code></pre>

<p>Importantly, even when running locally, Tiller will store release
configuration in ConfigMaps inside of Kubernetes.</p>

<h2 id="upgrading-tiller">Upgrading Tiller</h2>

<p>As of Helm 2.2.0, Tiller can be upgraded using <code>helm init --upgrade</code>.</p>

<p>For older versions of Helm, or for manual upgrades, you can use <code>kubectl</code> to modify
the Tiller image:</p>

<pre><code class="language-console">$ export TILLER_TAG=v2.0.0-beta.1        # Or whatever version you want
$ kubectl --namespace=kube-system set image deployments/tiller-deploy tiller=gcr.io/kubernetes-helm/tiller:$TILLER_TAG
deployment &quot;tiller-deploy&quot; image updated
</code></pre>

<p>Setting <code>TILLER_TAG=canary</code> will get the latest snapshot of master.</p>

<h2 id="deleting-or-reinstalling-tiller">Deleting or Reinstalling Tiller</h2>

<p>Because Tiller stores its data in Kubernetes ConfigMaps, you can safely
delete and re-install Tiller without worrying about losing any data. The
recommended way of deleting Tiller is with <code>kubectl delete deployment
tiller-deploy --namespace kube-system</code>, or more concisely <code>helm reset</code>.</p>

<p>Tiller can then be re-installed from the client with:</p>

<pre><code class="language-console">$ helm init
</code></pre>

<h2 id="advanced-usage">Advanced Usage</h2>

<p><code>helm init</code> provides additional flags for modifying Tiller&rsquo;s deployment
manifest before it is installed.</p>

<h3 id="using-node-selectors">Using <code>--node-selectors</code></h3>

<p>The <code>--node-selectors</code> flag allows us to specify the node labels required
for scheduling the Tiller pod.</p>

<p>The example below will create the specified label under the nodeSelector
property.</p>

<pre><code>helm init --node-selectors &quot;beta.kubernetes.io/os&quot;=&quot;linux&quot;
</code></pre>

<p>The installed deployment manifest will contain our node selector label.</p>

<pre><code>...
spec:
  template:
    spec:
      nodeSelector:
        beta.kubernetes.io/os: linux
...
</code></pre>

<h3 id="using-override">Using <code>--override</code></h3>

<p><code>--override</code> allows you to specify properties of Tiller&rsquo;s
deployment manifest. Unlike the <code>--set</code> command used elsewhere in Helm,
<code>helm init --override</code> manipulates the specified properties of the final
manifest (there is no &ldquo;values&rdquo; file). Therefore you may specify any valid
value for any valid property in the deployment manifest.</p>

<h4 id="override-annotation">Override annotation</h4>

<p>In the example below we use <code>--override</code> to add the revision property and set
its value to 1.</p>

<pre><code>helm init --override metadata.annotations.&quot;deployment\.kubernetes\.io/revision&quot;=&quot;1&quot;
</code></pre>

<p>Output:</p>

<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: &quot;1&quot;
...
</code></pre>

<h4 id="override-affinity">Override affinity</h4>

<p>In the example below we set properties for node affinity. Multiple
<code>--override</code> commands may be combined to modify different properties of the
same list item.</p>

<pre><code>helm init --override &quot;spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].weight&quot;=&quot;1&quot; --override &quot;spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].preference.matchExpressions[0].key&quot;=&quot;e2e-az-name&quot;
</code></pre>

<p>The specified properties are combined into the
&ldquo;preferredDuringSchedulingIgnoredDuringExecution&rdquo; property&rsquo;s first
list item.</p>

<pre><code>...
spec:
  strategy: {}
  template:
    ...
    spec:
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - preference:
              matchExpressions:
              - key: e2e-az-name
                operator: &quot;&quot;
            weight: 1
...
</code></pre>

<h3 id="using-output">Using <code>--output</code></h3>

<p>The <code>--output</code> flag allows us skip the installation of Tiller&rsquo;s deployment
manifest and simply output the deployment manifest to stdout in either
JSON or YAML format. The output may then be modified with tools like <code>jq</code>
and installed manually with <code>kubectl</code>.</p>

<p>In the example below we execute <code>helm init</code> with the <code>--output json</code> flag.</p>

<pre><code>helm init --output json
</code></pre>

<p>The Tiller installation is skipped and the manifest is output to stdout
in JSON format.</p>

<pre><code>&quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;,
&quot;kind&quot;: &quot;Deployment&quot;,
&quot;metadata&quot;: {
    &quot;creationTimestamp&quot;: null,
    &quot;labels&quot;: {
        &quot;app&quot;: &quot;helm&quot;,
        &quot;name&quot;: &quot;tiller&quot;
    },
    &quot;name&quot;: &quot;tiller-deploy&quot;,
    &quot;namespace&quot;: &quot;kube-system&quot;
},
...
</code></pre>

<h3 id="storage-backends">Storage backends</h3>

<p>By default, <code>tiller</code> stores release information in <code>ConfigMaps</code> in the namespace
where it is running. As of Helm 2.7.0, there is now a beta storage backend that
uses <code>Secrets</code> for storing release information. This was added for additional
security in protecting charts in conjunction with the release of <code>Secret</code>
encryption in Kubernetes.</p>

<p>To enable the secrets backend, you&rsquo;ll need to init Tiller with the following
options:</p>

<pre><code class="language-shell">helm init --override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}'
</code></pre>

<p>Currently, if you want to switch from the default backend to the secrets
backend, you&rsquo;ll have to do the migration for this on your own. When this backend
graduates from beta, there will be a more official path of migration</p>

<h2 id="conclusion">Conclusion</h2>

<p>In most cases, installation is as simple as getting a pre-built <code>helm</code> binary
and running <code>helm init</code>. This document covers additional cases for those
who want to do more sophisticated things with Helm.</p>

<p>Once you have the Helm Client and Tiller successfully installed, you can
move on to using Helm to manage charts.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="installation-frequently-asked-questions">Installation: Frequently Asked Questions</h1>

<p>This section tracks some of the more frequently encountered issues with installing
or getting started with Helm.</p>

<p><strong>We&rsquo;d love your help</strong> making this document better. To add, correct, or remove
information, <a href="https://github.com/helm/helm/issues">file an issue</a> or
send us a pull request.</p>

<h2 id="downloading">Downloading</h2>

<p>I want to know more about my downloading options.</p>

<p><strong>Q: I can&rsquo;t get to GitHub releases of the newest Helm. Where are they?</strong></p>

<p>A: We no longer use GitHub releases. Binaries are now stored in a
<a href="https://kubernetes-helm.storage.googleapis.com">GCS public bucket</a>.</p>

<p><strong>Q: Why aren&rsquo;t there Debian/Fedora/&hellip; native packages of Helm?</strong></p>

<p>We&rsquo;d love to provide these or point you toward a trusted provider. If you&rsquo;re
interested in helping, we&rsquo;d love it. This is how the Homebrew formula was
started.</p>

<p><strong>Q: Why do you provide a <code>curl ...|bash</code> script?</strong></p>

<p>A: There is a script in our repository (<code>scripts/get</code>) that can be executed as
a <code>curl ..|bash</code> script. The transfers are all protected by HTTPS, and the script
does some auditing of the packages it fetches. However, the script has all the
usual dangers of any shell script.</p>

<p>We provide it because it is useful, but we suggest that users carefully read the
script first. What we&rsquo;d really like, though, are better packaged releases of
Helm.</p>

<h2 id="installing">Installing</h2>

<p>I&rsquo;m trying to install Helm/Tiller, but something is not right.</p>

<p><strong>Q: How do I put the Helm client files somewhere other than ~/.helm?</strong></p>

<p>Set the <code>$HELM_HOME</code> environment variable, and then run <code>helm init</code>:</p>

<pre><code class="language-console">export HELM_HOME=/some/path
helm init --client-only
</code></pre>

<p>Note that if you have existing repositories, you will need to re-add them
with <code>helm repo add...</code>.</p>

<p><strong>Q: How do I configure Helm, but not install Tiller?</strong></p>

<p>A: By default, <code>helm init</code> will ensure that the local <code>$HELM_HOME</code> is configured,
and then install Tiller on your cluster. To locally configure, but not install
Tiller, use <code>helm init --client-only</code>.</p>

<p><strong>Q: How do I manually install Tiller on the cluster?</strong></p>

<p>A: Tiller is installed as a Kubernetes <code>deployment</code>. You can get the manifest
by running <code>helm init --dry-run --debug</code>, and then manually install it with
<code>kubectl</code>. It is suggested that you do not remove or change the labels on that
deployment, as they are sometimes used by supporting scripts and tools.</p>

<p><strong>Q: Why do I get <code>Error response from daemon: target is unknown</code> during Tiller install?</strong></p>

<p>A: Users have reported being unable to install Tiller on Kubernetes instances that
are using Docker 1.13.0. The root cause of this was a bug in Docker that made
that one version incompatible with images pushed to the Docker registry by
earlier versions of Docker.</p>

<p>This <a href="https://github.com/docker/docker/issues/30083">issue</a> was fixed shortly
after the release, and is available in Docker 1.13.1-RC1 and later.</p>

<h2 id="getting-started">Getting Started</h2>

<p>I successfully installed Helm/Tiller but I can&rsquo;t use it.</p>

<p><strong>Q: Trying to use Helm, I get the error &ldquo;client transport was broken&rdquo;</strong></p>

<pre><code>E1014 02:26:32.885226   16143 portforward.go:329] an error occurred forwarding 37008 -&gt; 44134: error forwarding port 44134 to pod tiller-deploy-2117266891-e4lev_kube-system, uid : unable to do port forwarding: socat not found.
2016/10/14 02:26:32 transport: http2Client.notifyError got notified that the client transport was broken EOF.
Error: transport is closing
</code></pre>

<p>A: This is usually a good indication that Kubernetes is not set up to allow port forwarding.</p>

<p>Typically, the missing piece is <code>socat</code>. If you are running CoreOS, we have been
told that it may have been misconfigured on installation. The CoreOS team
recommends reading this:</p>

<ul>
<li><a href="https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html">https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html</a></li>
</ul>

<p>Here are a few resolved issues that may help you get started:</p>

<ul>
<li><a href="https://github.com/helm/helm/issues/1371">https://github.com/helm/helm/issues/1371</a></li>
<li><a href="https://github.com/helm/helm/issues/966">https://github.com/helm/helm/issues/966</a></li>
</ul>

<p><strong>Q: Trying to use Helm, I get the error &ldquo;lookup XXXXX on 8.8.8.8:53: no such host&rdquo;</strong></p>

<pre><code>Error: Error forwarding ports: error upgrading connection: dial tcp: lookup kube-4gb-lon1-02 on 8.8.8.8:53: no such host
</code></pre>

<p>A: We have seen this issue with Ubuntu and Kubeadm in multi-node clusters. The
issue is that the nodes expect certain DNS records to be obtainable via global
DNS. Until this is resolved upstream, you can work around the issue as
follows. On each of the control plane nodes:</p>

<p>1) Add entries to <code>/etc/hosts</code>, mapping your hostnames to their public IPs
2) Install <code>dnsmasq</code> (e.g. <code>apt install -y dnsmasq</code>)
3) Remove the k8s api server container (kubelet will recreate it)
4) Then <code>systemctl restart docker</code> (or reboot the node) for it to pick up the /etc/resolv.conf changes</p>

<p>See this issue for more information: <a href="https://github.com/helm/helm/issues/1455">https://github.com/helm/helm/issues/1455</a></p>

<p><strong>Q: On GKE (Google Container Engine) I get &ldquo;No SSH tunnels currently open&rdquo;</strong></p>

<pre><code>Error: Error forwarding ports: error upgrading connection: No SSH tunnels currently open. Were the targets able to accept an ssh-key for user &quot;gke-[redacted]&quot;?
</code></pre>

<p>Another variation of the error message is:</p>

<pre><code>Unable to connect to the server: x509: certificate signed by unknown authority

</code></pre>

<p>A: The issue is that your local Kubernetes config file must have the correct credentials.</p>

<p>When you create a cluster on GKE, it will give you credentials, including SSL
certificates and certificate authorities. These need to be stored in a Kubernetes
config file (Default: <code>~/.kube/config</code> so that <code>kubectl</code> and <code>helm</code> can access
them.</p>

<p><strong>Q: When I run a Helm command, I get an error about the tunnel or proxy</strong></p>

<p>A: Helm uses the Kubernetes proxy service to connect to the Tiller server.
If the command <code>kubectl proxy</code> does not work for you, neither will Helm.
Typically, the error is related to a missing <code>socat</code> service.</p>

<p><strong>Q: Tiller crashes with a panic</strong></p>

<p>When I run a command on Helm, Tiller crashes with an error like this:</p>

<pre><code>Tiller is listening on :44134
Probes server is listening on :44135
Storage driver is ConfigMap
Cannot initialize Kubernetes connection: the server has asked for the client to provide credentials 2016-12-20 15:18:40.545739 I | storage.go:37: Getting release &quot;bailing-chinchilla&quot; (v1) from storage
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x8053d5]

goroutine 77 [running]:
panic(0x1abbfc0, 0xc42000a040)
        /usr/local/go/src/runtime/panic.go:500 +0x1a1
k8s.io/helm/vendor/k8s.io/kubernetes/pkg/client/unversioned.(*ConfigMaps).Get(0xc4200c6200, 0xc420536100, 0x15, 0x1ca7431, 0x6, 0xc42016b6a0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/k8s.io/kubernetes/pkg/client/unversioned/configmap.go:58 +0x75
k8s.io/helm/pkg/storage/driver.(*ConfigMaps).Get(0xc4201d6190, 0xc420536100, 0x15, 0xc420536100, 0x15, 0xc4205360c0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/storage/driver/cfgmaps.go:69 +0x62
k8s.io/helm/pkg/storage.(*Storage).Get(0xc4201d61a0, 0xc4205360c0, 0x12, 0xc400000001, 0x12, 0x0, 0xc420200070)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/storage/storage.go:38 +0x160
k8s.io/helm/pkg/tiller.(*ReleaseServer).uniqName(0xc42002a000, 0x0, 0x0, 0xc42016b800, 0xd66a13, 0xc42055a040, 0xc420558050, 0xc420122001)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:577 +0xd7
k8s.io/helm/pkg/tiller.(*ReleaseServer).prepareRelease(0xc42002a000, 0xc42027c1e0, 0xc42002a001, 0xc42016bad0, 0xc42016ba08)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:630 +0x71
k8s.io/helm/pkg/tiller.(*ReleaseServer).InstallRelease(0xc42002a000, 0x7f284c434068, 0xc420250c00, 0xc42027c1e0, 0x0, 0x31a9, 0x31a9)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:604 +0x78
k8s.io/helm/pkg/proto/hapi/services._ReleaseService_InstallRelease_Handler(0x1c51f80, 0xc42002a000, 0x7f284c434068, 0xc420250c00, 0xc42027c190, 0x0, 0x0, 0x0, 0x0, 0x0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/proto/hapi/services/tiller.pb.go:747 +0x27d
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).processUnaryRPC(0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690, 0xc420166150, 0x288cbe8, 0xc420250bd0, 0x0, 0x0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:608 +0xc50
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).handleStream(0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690, 0xc420250bd0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:766 +0x6b0
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).serveStreams.func1.1(0xc420124710, 0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:419 +0xab
created by k8s.io/helm/vendor/google.golang.org/grpc.(*Server).serveStreams.func1
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:420 +0xa3
</code></pre>

<p>A: Check your security settings for Kubernetes.</p>

<p>A panic in Tiller is almost always the result of a failure to negotiate with the
Kubernetes API server (at which point Tiller can no longer do anything useful, so
it panics and exits).</p>

<p>Often, this is a result of authentication failing because the Pod in which Tiller
is running does not have the right token.</p>

<p>To fix this, you will need to change your Kubernetes configuration. Make sure
that <code>--service-account-private-key-file</code> from <code>controller-manager</code> and
<code>--service-account-key-file</code> from apiserver point to the <em>same</em> x509 RSA key.</p>

<h2 id="upgrading">Upgrading</h2>

<p>My Helm used to work, then I upgrade. Now it is broken.</p>

<p><strong>Q: After upgrade, I get the error &ldquo;Client version is incompatible&rdquo;. What&rsquo;s wrong?</strong></p>

<p>Tiller and Helm have to negotiate a common version to make sure that they can safely
communicate without breaking API assumptions. That error means that the version
difference is too great to safely continue. Typically, you need to upgrade
Tiller manually for this.</p>

<p>The <a href="../using_helm/#installing-helm">Installation Guide</a> has definitive information about safely
upgrading Helm and Tiller.</p>

<p>The rules for version numbers are as follows:</p>

<ul>
<li>Pre-release versions are incompatible with everything else. <code>Alpha.1</code> is incompatible with <code>Alpha.2</code>.</li>
<li>Patch revisions <em>are compatible</em>: 1.2.3 is compatible with 1.2.4</li>
<li>Minor revisions <em>are not compatible</em>: 1.2.0 is not compatible with 1.3.0,
though we may relax this constraint in the future.</li>
<li>Major revisions <em>are not compatible</em>: 1.0.0 is not compatible with 2.0.0.</li>
</ul>

<h2 id="uninstalling">Uninstalling</h2>

<p>I am trying to remove stuff.</p>

<p><strong>Q: When I delete the Tiller deployment, how come all the releases are still there?</strong></p>

<p>Releases are stored in ConfigMaps inside of the <code>kube-system</code> namespace. You will
have to manually delete them to get rid of the record, or use <code>helm delete --purge</code>.</p>

<p><strong>Q: I want to delete my local Helm. Where are all its files?</strong></p>

<p>Along with the <code>helm</code> binary, Helm stores some files in <code>$HELM_HOME</code>, which is
located by default in <code>~/.helm</code>.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="kubernetes-distribution-guide">Kubernetes Distribution Guide</h1>

<p>This document captures information about using Helm in specific Kubernetes
environments.</p>

<p>We are trying to add more details to this document. Please contribute via Pull
Requests if you can.</p>

<h2 id="minikube">MiniKube</h2>

<p>Helm is tested and known to work with <a href="https://github.com/kubernetes/minikube">minikube</a>.
It requires no additional configuration.</p>

<h2 id="scripts-local-cluster-and-hyperkube"><code>scripts/local-cluster</code> and Hyperkube</h2>

<p>Hyperkube configured via <code>scripts/local-cluster.sh</code> is known to work. For raw
Hyperkube you may need to do some manual configuration.</p>

<h2 id="gke">GKE</h2>

<p>Google&rsquo;s GKE hosted Kubernetes platform enables RBAC by default. You will need to create a service account for tiller, and use the &ndash;service-account flag when initializing the helm server.</p>

<p>See <a href="https://docs.helm.sh/using_helm/#role-based-access-control">Tiller and role-based access control</a> for more information.</p>

<h2 id="ubuntu-with-kubeadm">Ubuntu with &lsquo;kubeadm&rsquo;</h2>

<p>Kubernetes bootstrapped with <code>kubeadm</code> is known to work on the following Linux
distributions:</p>

<ul>
<li>Ubuntu 16.04</li>
<li>Fedora release 25</li>
</ul>

<p>Some versions of Helm (v2.0.0-beta2) require you to <code>export KUBECONFIG=/etc/kubernetes/admin.conf</code>
or create a <code>~/.kube/config</code>.</p>

<h2 id="container-linux-by-coreos">Container Linux by CoreOS</h2>

<p>Helm requires that kubelet have access to a copy of the <code>socat</code> program to proxy connections to the Tiller API. On Container Linux the Kubelet runs inside of a <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube">hyperkube</a> container image that has socat. So, even though Container Linux doesn&rsquo;t ship <code>socat</code> the container filesystem running kubelet does have socat. To learn more read the <a href="https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html">Kubelet Wrapper</a> docs.</p>

<h2 id="openshift">Openshift</h2>

<p>Helm works straightforward on OpenShift Online, OpenShift Dedicated, OpenShift Container Platform (version &gt;= 3.6) or OpenShift Origin (version &gt;= 3.6). To learn more read <a href="https://blog.openshift.com/getting-started-helm-openshift/">this blog</a> post.</p>

<h2 id="platform9">Platform9</h2>

<p>Helm Client and Helm Server (Tiller) are pre-installed with <a href="https://platform9.com/managed-kubernetes/?utm_source=helm_distro_notes">Platform9 Managed Kubernetes</a>. Platform9 provides access to all official Helm charts through the App Catalog UI and native Kubernetes CLI. Additional repositories can be manually added. Further details are available in this <a href="https://platform9.com/support/deploying-kubernetes-apps-platform9-managed-kubernetes/?utm_source=helm_distro_notes">Platform9 App Catalog article</a>.</p>

<h2 id="dc-os">DC/OS</h2>

<p>Helm (both client and server) has been tested and is working on Mesospheres DC/OS 1.11 Kubernetes platform, and requires
no additional configuration.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="the-helm-plugins-guide">The Helm Plugins Guide</h1>

<p>Helm 2.1.0 introduced the concept of a client-side Helm <em>plugin</em>. A plugin is a
tool that can be accessed through the <code>helm</code> CLI, but which is not part of the
built-in Helm codebase.</p>

<p>Existing plugins can be found on <a href="related.md#helm-plugins">related</a> section or by searching <a href="https://github.com/search?q=topic%3Ahelm-plugin&amp;type=Repositories">Github</a>.</p>

<p>This guide explains how to use and create plugins.</p>

<h2 id="an-overview">An Overview</h2>

<p>Helm plugins are add-on tools that integrate seamlessly with Helm. They provide
a way to extend the core feature set of Helm, but without requiring every new
feature to be written in Go and added to the core tool.</p>

<p>Helm plugins have the following features:</p>

<ul>
<li>They can be added and removed from a Helm installation without impacting the
core Helm tool.</li>
<li>They can be written in any programming language.</li>
<li>They integrate with Helm, and will show up in <code>helm help</code> and other places.</li>
</ul>

<p>Helm plugins live in <code>$(helm home)/plugins</code>.</p>

<p>The Helm plugin model is partially modeled on Git&rsquo;s plugin model. To that end,
you may sometimes hear <code>helm</code> referred to as the <em>porcelain</em> layer, with
plugins being the <em>plumbing</em>. This is a shorthand way of suggesting that
Helm provides the user experience and top level processing logic, while the
plugins do the &ldquo;detail work&rdquo; of performing a desired action.</p>

<h2 id="installing-a-plugin">Installing a Plugin</h2>

<p>Plugins are installed using the <code>$ helm plugin install &lt;path|url&gt;</code> command. You can pass in a path to a plugin on your local file system or a url of a remote VCS repo. The <code>helm plugin install</code> command clones or copies the plugin at the path/url given into <code>$ (helm home)/plugins</code></p>

<pre><code class="language-console">$ helm plugin install https://github.com/technosophos/helm-template
</code></pre>

<p>If you have a plugin tar distribution, simply untar the plugin into the
<code>$(helm home)/plugins</code> directory.</p>

<p>You can also install tarball plugins directly from url by issuing <code>helm plugin install http://domain/path/to/plugin.tar.gz</code></p>

<h2 id="building-plugins">Building Plugins</h2>

<p>In many ways, a plugin is similar to a chart. Each plugin has a top-level
directory, and then a <code>plugin.yaml</code> file.</p>

<pre><code>$(helm home)/plugins/
  |- keybase/
      |
      |- plugin.yaml
      |- keybase.sh

</code></pre>

<p>In the example above, the <code>keybase</code> plugin is contained inside of a directory
named <code>keybase</code>. It has two files: <code>plugin.yaml</code> (required) and an executable
script, <code>keybase.sh</code> (optional).</p>

<p>The core of a plugin is a simple YAML file named <code>plugin.yaml</code>.
Here is a plugin YAML for a plugin that adds support for Keybase operations:</p>

<pre><code>name: &quot;keybase&quot;
version: &quot;0.1.0&quot;
usage: &quot;Integrate Keybase.io tools with Helm&quot;
description: |-
  This plugin provides Keybase services to Helm.
ignoreFlags: false
useTunnel: false
command: &quot;$HELM_PLUGIN_DIR/keybase.sh&quot;
</code></pre>

<p>The <code>name</code> is the name of the plugin. When Helm executes it plugin, this is the
name it will use (e.g. <code>helm NAME</code> will invoke this plugin).</p>

<p><em><code>name</code> should match the directory name.</em> In our example above, that means the
plugin with <code>name: keybase</code> should be contained in a directory named <code>keybase</code>.</p>

<p>Restrictions on <code>name</code>:</p>

<ul>
<li><code>name</code> cannot duplicate one of the existing <code>helm</code> top-level commands.</li>
<li><code>name</code> must be restricted to the characters ASCII a-z, A-Z, 0-9, <code>_</code> and <code>-</code>.</li>
</ul>

<p><code>version</code> is the SemVer 2 version of the plugin.
<code>usage</code> and <code>description</code> are both used to generate the help text of a command.</p>

<p>The <code>ignoreFlags</code> switch tells Helm to <em>not</em> pass flags to the plugin. So if a
plugin is called with <code>helm myplugin --foo</code> and <code>ignoreFlags: true</code>, then <code>--foo</code>
is silently discarded.</p>

<p>The <code>useTunnel</code> switch indicates that the plugin needs a tunnel to Tiller. This
should be set to <code>true</code> <em>anytime a plugin talks to Tiller</em>. It will cause Helm
to open a tunnel, and then set <code>$TILLER_HOST</code> to the right local address for that
tunnel. But don&rsquo;t worry: if Helm detects that a tunnel is not necessary because
Tiller is running locally, it will not create the tunnel.</p>

<p>Finally, and most importantly, <code>command</code> is the command that this plugin will
execute when it is called. Environment variables are interpolated before the plugin
is executed. The pattern above illustrates the preferred way to indicate where
the plugin program lives.</p>

<p>There are some strategies for working with plugin commands:</p>

<ul>
<li>If a plugin includes an executable, the executable for a <code>command:</code> should be
packaged in the plugin directory.</li>
<li>The <code>command:</code> line will have any environment variables expanded before
execution. <code>$HELM_PLUGIN_DIR</code> will point to the plugin directory.</li>
<li>The command itself is not executed in a shell. So you can&rsquo;t oneline a shell script.</li>
<li>Helm injects lots of configuration into environment variables. Take a look at
the environment to see what information is available.</li>
<li>Helm makes no assumptions about the language of the plugin. You can write it
in whatever you prefer.</li>
<li>Commands are responsible for implementing specific help text for <code>-h</code> and <code>--help</code>.
Helm will use <code>usage</code> and <code>description</code> for <code>helm help</code> and <code>helm help myplugin</code>,
but will not handle <code>helm myplugin --help</code>.</li>
</ul>

<h2 id="downloader-plugins">Downloader Plugins</h2>

<p>By default, Helm is able to fetch Charts using HTTP/S. As of Helm 2.4.0, plugins
can have a special capability to download Charts from arbitrary sources.</p>

<p>Plugins shall declare this special capability in the <code>plugin.yaml</code> file (top level):</p>

<pre><code>downloaders:
- command: &quot;bin/mydownloader&quot;
  protocols:
  - &quot;myprotocol&quot;
  - &quot;myprotocols&quot;
</code></pre>

<p>If such plugin is installed, Helm can interact with the repository using the specified
protocol scheme by invoking the <code>command</code>. The special repository shall be added
similarly to the regular ones: <code>helm repo add favorite myprotocol://example.com/</code>
The rules for the special repos are the same to the regular ones: Helm must be able
to download the <code>index.yaml</code> file in order to discover and cache the list of
available Charts.</p>

<p>The defined command will be invoked with the following scheme:
<code>command certFile keyFile caFile full-URL</code>. The SSL credentials are coming from the
repo definition, stored in <code>$HELM_HOME/repository/repositories.yaml</code>. Downloader
plugin is expected to dump the raw content to stdout and report errors on stderr.</p>

<h2 id="environment-variables">Environment Variables</h2>

<p>When Helm executes a plugin, it passes the outer environment to the plugin, and
also injects some additional environment variables.</p>

<p>Variables like <code>KUBECONFIG</code> are set for the plugin if they are set in the
outer environment.</p>

<p>The following variables are guaranteed to be set:</p>

<ul>
<li><code>HELM_PLUGIN</code>: The path to the plugins directory</li>
<li><code>HELM_PLUGIN_NAME</code>: The name of the plugin, as invoked by <code>helm</code>. So
<code>helm myplug</code> will have the short name <code>myplug</code>.</li>
<li><code>HELM_PLUGIN_DIR</code>: The directory that contains the plugin.</li>
<li><code>HELM_BIN</code>: The path to the <code>helm</code> command (as executed by the user).</li>
<li><code>HELM_HOME</code>: The path to the Helm home.</li>
<li><code>HELM_PATH_*</code>: Paths to important Helm files and directories are stored in
environment variables prefixed by <code>HELM_PATH</code>.</li>
<li><code>TILLER_HOST</code>: The <code>domain:port</code> to Tiller. If a tunnel is created, this
will point to the local endpoint for the tunnel. Otherwise, it will point
to <code>$HELM_HOST</code>, <code>--host</code>, or the default host (according to Helm&rsquo;s rules of
precedence).</li>
</ul>

<p>While <code>HELM_HOST</code> <em>may</em> be set, there is no guarantee that it will point to the
correct Tiller instance. This is done to allow plugin developer to access
<code>HELM_HOST</code> in its raw state when the plugin itself needs to manually configure
a connection.</p>

<h2 id="a-note-on-usetunnel">A Note on <code>useTunnel</code></h2>

<p>If a plugin specifies <code>useTunnel: true</code>, Helm will do the following (in order):</p>

<ol>
<li>Parse global flags and the environment</li>
<li>Create the tunnel</li>
<li>Set <code>TILLER_HOST</code></li>
<li>Execute the plugin</li>
<li>Close the tunnel</li>
</ol>

<p>The tunnel is removed as soon as the <code>command</code> returns. So, for example, a
command cannot background a process and assume that process will be able
to use the tunnel.</p>

<h2 id="a-note-on-flag-parsing">A Note on Flag Parsing</h2>

<p>When executing a plugin, Helm will parse global flags for its own use. Some of
these flags are <em>not</em> passed on to the plugin.</p>

<ul>
<li><code>--debug</code>: If this is specified, <code>$HELM_DEBUG</code> is set to <code>1</code></li>
<li><code>--home</code>: This is converted to <code>$HELM_HOME</code></li>
<li><code>--host</code>: This is converted to <code>$HELM_HOST</code></li>
<li><code>--kube-context</code>: This is simply dropped. If your plugin uses <code>useTunnel</code>, this
is used to set up the tunnel for you.</li>
</ul>

<p>Plugins <em>should</em> display help text and then exit for <code>-h</code> and <code>--help</code>. In all
other cases, plugins may use flags as appropriate.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="helm-provenance-and-integrity">Helm Provenance and Integrity</h1>

<p>Helm has provenance tools which help chart users verify the integrity and origin
of a package. Using industry-standard tools based on PKI, GnuPG, and well-respected
package managers, Helm can generate and verify signature files.</p>

<h2 id="overview">Overview</h2>

<p>Integrity is established by comparing a chart to a provenance record. Provenance
records are stored in <em>provenance files</em>, which are stored alongside a packaged
chart. For example, if a chart is named <code>myapp-1.2.3.tgz</code>, its provenance file
will be <code>myapp-1.2.3.tgz.prov</code>.</p>

<p>Provenance files are generated at packaging time (<code>helm package --sign ...</code>), and
can be checked by multiple commands, notable <code>helm install --verify</code>.</p>

<h2 id="the-workflow">The Workflow</h2>

<p>This section describes a potential workflow for using provenance data effectively.</p>

<p>Prerequisites:</p>

<ul>
<li>A valid PGP keypair in a binary (not ASCII-armored) format</li>
<li>The <code>helm</code> command line tool</li>
<li>GnuPG &gt;=2.1 command line tools (optional)</li>
<li>Keybase command line tools (optional)</li>
</ul>

<p><strong>NOTE:</strong> If your PGP private key has a passphrase, you will be prompted to enter
that passphrase for any commands that support the <code>--sign</code> option. You can set the
HELM_KEY_PASSPHRASE environment variable to that passphrase in case you don&rsquo;t want
to be prompted to enter the passphrase.</p>

<p><strong>NOTE:</strong> The keyfile format for GnuPG changed in version 2.1. Prior to that release
it was unnecessary to export keys out of GnuPG, and you could instead point Helm
at your <code>*.gpg</code> files. With 2.1, the new <code>.kbx</code> format was introduced, and this
format is not supported by Helm.</p>

<p>Creating a new chart is the same as before:</p>

<pre><code>$ helm create mychart
Creating mychart
</code></pre>

<p>Once ready to package, add the <code>--sign</code> flag to <code>helm package</code>. Also, specify
the name under which the signing key is known and the keyring containing the corresponding private key:</p>

<pre><code>$ helm package --sign --key 'helm signing key' --keyring path/to/keyring.secret mychart
</code></pre>

<p><strong>TIP:</strong> for GnuPG users, your secret keyring is in <code>~/.gnupg/secring.kbx</code>. You can
use <code>gpg --list-secret-keys</code> to list the keys you have.</p>

<p><strong>Warning:</strong>  the GnuPG v2.1 store your secret keyring using a new format &lsquo;kbx&rsquo; on the default location  &lsquo;~/.gnupg/pubring.kbx&rsquo;. Please use the following command to convert your keyring to the legacy gpg format:</p>

<pre><code>$ gpg --export-secret-keys &gt;~/.gnupg/secring.gpg
</code></pre>

<p>At this point, you should see both <code>mychart-0.1.0.tgz</code> and <code>mychart-0.1.0.tgz.prov</code>.
Both files should eventually be uploaded to your desired chart repository.</p>

<p>You can verify a chart using <code>helm verify</code>:</p>

<pre><code>$ helm verify mychart-0.1.0.tgz
</code></pre>

<p>A failed verification looks like this:</p>

<pre><code>$ helm verify topchart-0.1.0.tgz
Error: sha256 sum does not match for topchart-0.1.0.tgz: &quot;sha256:1939fbf7c1023d2f6b865d137bbb600e0c42061c3235528b1e8c82f4450c12a7&quot; != &quot;sha256:5a391a90de56778dd3274e47d789a2c84e0e106e1a37ef8cfa51fd60ac9e623a&quot;
</code></pre>

<p>To verify during an install, use the <code>--verify</code> flag.</p>

<pre><code>$ helm install --verify mychart-0.1.0.tgz
</code></pre>

<p>If the keyring (containing the public key associated with the signed chart) is not in the default location, you may need to point to the
keyring with <code>--keyring PATH</code> as in the <code>helm package</code> example.</p>

<p>If verification fails, the install will be aborted before the chart is even pushed
up to Tiller.</p>

<h3 id="using-keybase-io-credentials">Using Keybase.io credentials</h3>

<p>The <a href="https://keybase.io">Keybase.io</a> service makes it easy to establish a chain of
trust for a cryptographic identity. Keybase credentials can be used to sign charts.</p>

<p>Prerequisites:</p>

<ul>
<li>A configured Keybase.io account</li>
<li>GnuPG installed locally</li>
<li>The <code>keybase</code> CLI installed locally</li>
</ul>

<h4 id="signing-packages">Signing packages</h4>

<p>The first step is to import your keybase keys into your local GnuPG keyring:</p>

<pre><code>$ keybase pgp export -s &gt; secring.gpg
</code></pre>

<p>This will convert your Keybase key into the OpenPGP format, and then place it
locally into your <code>secring.gpg</code> file.</p>

<blockquote>
<p>Tip: If you need to add a Keybase key to an existing keyring, you will need to
do <code>keybase pgp export -s | gpg --import &amp;&amp; gpg --export-secret-keys --outfile secring.gpg</code></p>
</blockquote>

<p>Your secret key will have an identifier string:</p>

<pre><code>technosophos (keybase.io/technosophos) &lt;technosophos@keybase.io&gt;
</code></pre>

<p>That is the full name of your key.</p>

<p>Next, you can package and sign a chart with <code>helm package</code>. Make sure you use at
least part of that name string in <code>--key</code>.</p>

<pre><code>$ helm package --sign --key technosophos --keyring ~/.gnupg/secring.gpg mychart
</code></pre>

<p>As a result, the <code>package</code> command should produce both a <code>.tgz</code> file and a <code>.tgz.prov</code>
file.</p>

<h4 id="verifying-packages">Verifying packages</h4>

<p>You can also use a similar technique to verify a chart signed by someone else&rsquo;s
Keybase key. Say you want to verify a package signed by <code>keybase.io/technosophos</code>.
To do this, use the <code>keybase</code> tool:</p>

<pre><code>$ keybase follow technosophos
$ keybase pgp pull
</code></pre>

<p>The first command above tracks the user <code>technosophos</code>. Next <code>keybase pgp pull</code>
downloads the OpenPGP keys of all of the accounts you follow, placing them in
your GnuPG keyring (<code>~/.gnupg/pubring.gpg</code>).</p>

<p>At this point, you can now use <code>helm verify</code> or any of the commands with a <code>--verify</code>
flag:</p>

<pre><code>$ helm verify somechart-1.2.3.tgz
</code></pre>

<h3 id="reasons-a-chart-may-not-verify">Reasons a chart may not verify</h3>

<p>These are common reasons for failure.</p>

<ul>
<li>The prov file is missing or corrupt. This indicates that something is misconfigured
or that the original maintainer did not create a provenance file.</li>
<li>The key used to sign the file is not in your keyring. This indicate that the
entity who signed the chart is not someone you&rsquo;ve already signaled that you trust.</li>
<li>The verification of the prov file failed. This indicates that something is wrong
with either the chart or the provenance data.</li>
<li>The file hashes in the provenance file do not match the hash of the archive file. This
indicates that the archive has been tampered with.</li>
</ul>

<p>If a verification fails, there is reason to distrust the package.</p>

<h2 id="the-provenance-file">The Provenance File</h2>

<p>The provenance file contains a chart’s YAML file plus several pieces of
verification information. Provenance files are designed to be automatically
generated.</p>

<p>The following pieces of provenance data are added:</p>

<ul>
<li>The chart file (Chart.yaml) is included to give both humans and tools an easy
view into the contents of the chart.</li>
<li>The signature (SHA256, just like Docker) of the chart package (the .tgz file)
is included, and may be used to verify the integrity of the chart package.</li>
<li>The entire body is signed using the algorithm used by PGP (see
[<a href="http://keybase.io">http://keybase.io</a>] for an emerging way of making crypto signing and
verification easy).</li>
</ul>

<p>The combination of this gives users the following assurances:</p>

<ul>
<li>The package itself has not been tampered with (checksum package tgz).</li>
<li>The entity who released this package is known (via the GnuPG/PGP signature).</li>
</ul>

<p>The format of the file looks something like this:</p>

<pre><code>-----BEGIN PGP SIGNED MESSAGE-----
name: nginx
description: The nginx web server as a replication controller and service pair.
version: 0.5.1
keywords:
  - https
  - http
  - web server
  - proxy
source:
- https://github.com/foo/bar
home: http://nginx.com

...
files:
        nginx-0.5.1.tgz: “sha256:9f5270f50fc842cfcb717f817e95178f”
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEARECAAYFAkjilUEACgQkB01zfu119ZnHuQCdGCcg2YxF3XFscJLS4lzHlvte
WkQAmQGHuuoLEJuKhRNo+Wy7mhE7u1YG
=eifq
-----END PGP SIGNATURE-----
</code></pre>

<p>Note that the YAML section contains two documents (separated by <code>...\n</code>). The
first is the Chart.yaml. The second is the checksums, a map of filenames to
SHA-256 digests (value shown is fake/truncated)</p>

<p>The signature block is a standard PGP signature, which provides <a href="http://www.rossde.com/PGP/pgp_signatures.html">tamper
resistance</a>.</p>

<h2 id="chart-repositories">Chart Repositories</h2>

<p>Chart repositories serve as a centralized collection of Helm charts.</p>

<p>Chart repositories must make it possible to serve provenance files over HTTP via
a specific request, and must make them available at the same URI path as the chart.</p>

<p>For example, if the base URL for a package is <code>https://example.com/charts/mychart-1.2.3.tgz</code>,
the provenance file, if it exists, MUST be accessible at <code>https://example.com/charts/mychart-1.2.3.tgz.prov</code>.</p>

<p>From the end user&rsquo;s perspective, <code>helm install --verify myrepo/mychart-1.2.3</code>
should result in the download of both the chart and the provenance file with no
additional user configuration or action.</p>

<h2 id="establishing-authority-and-authenticity">Establishing Authority and Authenticity</h2>

<p>When dealing with chain-of-trust systems, it is important to be able to
establish the authority of a signer. Or, to put this plainly, the system
above hinges on the fact that you trust the person who signed the chart.
That, in turn, means you need to trust the public key of the signer.</p>

<p>One of the design decisions with Kubernetes Helm has been that the Helm
project would not insert itself into the chain of trust as a necessary
party. We don&rsquo;t want to be &ldquo;the certificate authority&rdquo; for all chart
signers. Instead, we strongly favor a decentralized model, which is part
of the reason we chose OpenPGP as our foundational technology.
So when it comes to establishing authority, we have left this
step more-or-less undefined in Helm 2.0.0.</p>

<p>However, we have some pointers and recommendations for those interested
in using the provenance system:</p>

<ul>
<li>The <a href="https://keybase.io">Keybase</a> platform provides a public
centralized repository for trust information.

<ul>
<li>You can use Keybase to store your keys or to get the public keys of others.</li>
<li>Keybase also has fabulous documentation available</li>
<li>While we haven&rsquo;t tested it, Keybase&rsquo;s &ldquo;secure website&rdquo; feature could
be used to serve Helm charts.</li>
</ul></li>
<li>The <a href="https://github.com/helm/charts">official Helm Charts project</a>
is trying to solve this problem for the official chart repository.

<ul>
<li>There is a long issue there <a href="https://github.com/helm/charts/issues/23">detailing the current thoughts</a>.</li>
<li>The basic idea is that an official &ldquo;chart reviewer&rdquo; signs charts with
her or his key, and the resulting provenance file is then uploaded
to the chart repository.</li>
<li>There has been some work on the idea that a list of valid signing
keys may be included in the <code>index.yaml</code> file of a repository.</li>
</ul></li>
</ul>

<p>Finally, chain-of-trust is an evolving feature of Helm, and some
community members have proposed adapting part of the OSI model for
signatures. This is an open line of inquiry in the Helm team. If you&rsquo;re
interested, jump on in.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="quickstart-guide">Quickstart Guide</h1>

<p>This guide covers how you can quickly get started using Helm.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>The following prerequisites are required for a successful and properly secured use of Helm.</p>

<ol>
<li>A Kubernetes cluster</li>
<li>Deciding what security configurations to apply to your installation, if any</li>
<li>Installing and configuring Helm and Tiller, the cluster-side service.</li>
</ol>

<h3 id="install-kubernetes-or-have-access-to-a-cluster">Install Kubernetes or have access to a cluster</h3>

<ul>
<li>You must have Kubernetes installed. For the latest release of Helm, we recommend the latest stable release of Kubernetes, which in most cases is the second-latest minor release.</li>
<li>You should also have a local configured copy of <code>kubectl</code>.</li>
</ul>

<p>NOTE: Kubernetes versions prior to 1.6 have limited or no support for role-based access controls (RBAC).</p>

<p>Helm will figure out where to install Tiller by reading your Kubernetes
configuration file (usually <code>$HOME/.kube/config</code>). This is the same file
that <code>kubectl</code> uses.</p>

<p>To find out which cluster Tiller would install to, you can run
<code>kubectl config current-context</code> or <code>kubectl cluster-info</code>.</p>

<pre><code class="language-console">$ kubectl config current-context
my-cluster
</code></pre>

<h3 id="understand-your-security-context">Understand your Security Context</h3>

<p>As with all powerful tools, ensure you are installing it correctly for your scenario.</p>

<p>If you&rsquo;re using Helm on a cluster that you completely control, like minikube or a cluster on a private network in which sharing is not a concern, the default installation &ndash; which applies no security configuration &ndash; is fine, and it&rsquo;s definitely the easiest. To install Helm without additional security steps, <a href="#installing-helm">install Helm</a> and then <a href="#initialize-helm-and-install-tiller">initialize Helm</a>.</p>

<p>However, if your cluster is exposed to a larger network or if you share your cluster with others &ndash; production clusters fall into this category &ndash; you must take extra steps to secure your installation to prevent careless or malicious actors from damaging the cluster or its data. To apply configurations that secure Helm for use in production environments and other multi-tenant scenarios, see <a href="./#securing-your-helm-installation">Securing a Helm installation</a></p>

<p>If your cluster has Role-Based Access Control (RBAC) enabled, you may want
to <a href="./#role-based-access-control">configure a service account and rules</a> before proceeding.</p>

<h2 id="install-helm">Install Helm</h2>

<p>Download a binary release of the Helm client. You can use tools like
<code>homebrew</code>, or look at <a href="https://github.com/helm/helm/releases">the official releases page</a>.</p>

<p>For more details, or for other options, see <a href="../using_helm/#installing-helm">the installation
guide</a>.</p>

<h2 id="initialize-helm-and-install-tiller">Initialize Helm and Install Tiller</h2>

<p>Once you have Helm ready, you can initialize the local CLI and also
install Tiller into your Kubernetes cluster in one step:</p>

<pre><code class="language-console">$ helm init
</code></pre>

<p>This will install Tiller into the Kubernetes cluster you saw with
<code>kubectl config current-context</code>.</p>

<p><strong>TIP:</strong> Want to install into a different cluster? Use the
<code>--kube-context</code> flag.</p>

<p><strong>TIP:</strong> When you want to upgrade Tiller, just run <code>helm init --upgrade</code>.</p>

<p>By default, when Tiller is installed, it does not have authentication enabled.
To learn more about configuring strong TLS authentication for Tiller, consult
<a href="./#using-ssl-between-helm-and-tiller">the Tiller TLS guide</a>.</p>

<h2 id="install-an-example-chart">Install an Example Chart</h2>

<p>To install a chart, you can run the <code>helm install</code> command. Helm has
several ways to find and install a chart, but the easiest is to use one
of the official <code>stable</code> charts.</p>

<pre><code class="language-console">$ helm repo update              # Make sure we get the latest list of charts
$ helm install stable/mysql
NAME:   wintering-rodent
LAST DEPLOYED: Thu Oct 18 14:21:18 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/Secret
NAME                    AGE
wintering-rodent-mysql  0s

==&gt; v1/ConfigMap
wintering-rodent-mysql-test  0s

==&gt; v1/PersistentVolumeClaim
wintering-rodent-mysql  0s

==&gt; v1/Service
wintering-rodent-mysql  0s

==&gt; v1beta1/Deployment
wintering-rodent-mysql  0s

==&gt; v1/Pod(related)

NAME                                    READY  STATUS   RESTARTS  AGE
wintering-rodent-mysql-6986fd6fb-988x7  0/1    Pending  0         0s


NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
wintering-rodent-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default wintering-rodent-mysql -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update &amp;&amp; apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h wintering-rodent-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/wintering-rodent-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}

</code></pre>

<p>In the example above, the <code>stable/mysql</code> chart was released, and the name of
our new release is <code>wintering-rodent</code>. You get a simple idea of the
features of this MySQL chart by running <code>helm inspect stable/mysql</code>.</p>

<p>Whenever you install a chart, a new release is created. So one chart can
be installed multiple times into the same cluster. And each can be
independently managed and upgraded.</p>

<p>The <code>helm install</code> command is a very powerful command with many
capabilities. To learn more about it, check out the <a href="./#using_helm">Using Helm
Guide</a></p>

<h2 id="learn-about-releases">Learn About Releases</h2>

<p>It&rsquo;s easy to see what has been released using Helm:</p>

<pre><code class="language-console">$ helm ls
NAME            	REVISION	UPDATED                 	STATUS  	CHART       	APP VERSION	NAMESPACE
wintering-rodent	1       	Thu Oct 18 15:06:58 2018	DEPLOYED	mysql-0.10.1	5.7.14     	default
</code></pre>

<p>The <code>helm list</code> function will show you a list of all deployed releases.</p>

<h2 id="uninstall-a-release">Uninstall a Release</h2>

<p>To uninstall a release, use the <code>helm delete</code> command:</p>

<pre><code class="language-console">$ helm delete wintering-rodent
release &quot;wintering-rodent&quot; deleted
</code></pre>

<p>This will uninstall <code>wintering-rodent</code> from Kubernetes, but you will
still be able to request information about that release:</p>

<pre><code class="language-console">$ helm status wintering-rodent
LAST DEPLOYED: Thu Oct 18 14:21:18 2018
NAMESPACE: default
STATUS: DELETED

NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
wintering-rodent-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default wintering-rodent-mysql -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update &amp;&amp; apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h wintering-rodent-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/wintering-rodent-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}
</code></pre>

<p>Because Helm tracks your releases even after you&rsquo;ve deleted them, you
can audit a cluster&rsquo;s history, and even undelete a release (with <code>helm
rollback</code>).</p>

<h2 id="reading-the-help-text">Reading the Help Text</h2>

<p>To learn more about the available Helm commands, use <code>helm help</code> or type
a command followed by the <code>-h</code> flag:</p>

<pre><code class="language-console">$ helm get -h
</code></pre>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="role-based-access-control">Role-based Access Control</h1>

<p>In Kubernetes, granting a role to an application-specific service account is a best practice to ensure that your application is operating in the scope that you have specified. Read more about service account permissions <a href="https://kubernetes.io/docs/admin/authorization/rbac/#service-account-permissions">in the official Kubernetes docs</a>.</p>

<p>Bitnami also has a fantastic guide for <a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/">configuring RBAC in your cluster</a> that takes you through RBAC basics.</p>

<p>This guide is for users who want to restrict Tiller&rsquo;s capabilities to install resources to certain namespaces, or to grant a Helm client running access to a Tiller instance.</p>

<h2 id="tiller-and-role-based-access-control">Tiller and Role-based Access Control</h2>

<p>You can add a service account to Tiller using the <code>--service-account &lt;NAME&gt;</code> flag while you&rsquo;re configuring Helm. As a prerequisite, you&rsquo;ll have to create a role binding which specifies a <a href="https://kubernetes.io/docs/admin/authorization/rbac/#role-and-clusterrole">role</a> and a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">service account</a> name that have been set up in advance.</p>

<p>Once you have satisfied the pre-requisite and have a service account with the correct permissions, you&rsquo;ll run a command like this: <code>helm init --service-account &lt;NAME&gt;</code></p>

<h3 id="example-service-account-with-cluster-admin-role">Example: Service account with cluster-admin role</h3>

<p>In <code>rbac-config.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
</code></pre>

<p><em>Note: The cluster-admin role is created by default in a Kubernetes cluster, so you don&rsquo;t have to define it explicitly.</em></p>

<pre><code class="language-console">$ kubectl create -f rbac-config.yaml
serviceaccount &quot;tiller&quot; created
clusterrolebinding &quot;tiller&quot; created
$ helm init --service-account tiller
</code></pre>

<h3 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-only-in-that-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources only in that namespace</h3>

<p>In the example above, we gave Tiller admin access to the entire cluster. You are not at all required to give Tiller cluster-admin access for it to work. Instead of specifying a ClusterRole or a ClusterRoleBinding, you can specify a Role and RoleBinding to limit Tiller&rsquo;s scope to a particular namespace.</p>

<pre><code class="language-console">$ kubectl create namespace tiller-world
namespace &quot;tiller-world&quot; created
$ kubectl create serviceaccount tiller --namespace tiller-world
serviceaccount &quot;tiller&quot; created
</code></pre>

<p>Define a Role that allows Tiller to manage all resources in <code>tiller-world</code> like in <code>role-tiller.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: tiller-world
rules:
- apiGroups: [&quot;&quot;, &quot;batch&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;*&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>In <code>rolebinding-tiller.yaml</code>,</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: tiller-world
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: tiller-world
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<p>Afterwards you can run <code>helm init</code> to install Tiller in the <code>tiller-world</code> namespace.</p>

<pre><code class="language-console">$ helm init --service-account tiller --tiller-namespace tiller-world
$HELM_HOME has been configured at /Users/awesome-user/.helm.

Tiller (the Helm server side component) has been installed into your Kubernetes Cluster.
Happy Helming!

$ helm install nginx --tiller-namespace tiller-world --namespace tiller-world
NAME:   wayfaring-yak
LAST DEPLOYED: Mon Aug  7 16:00:16 2017
NAMESPACE: tiller-world
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/Pod
NAME                  READY  STATUS             RESTARTS  AGE
wayfaring-yak-alpine  0/1    ContainerCreating  0         0s
</code></pre>

<h3 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-in-another-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources in another namespace</h3>

<p>In the example above, we gave Tiller admin access to the namespace it was deployed inside. Now, let&rsquo;s limit Tiller&rsquo;s scope to deploy resources in a different namespace!</p>

<p>For example, let&rsquo;s install Tiller in the namespace <code>myorg-system</code> and allow Tiller to deploy resources in the namespace <code>myorg-users</code>.</p>

<pre><code class="language-console">$ kubectl create namespace myorg-system
namespace &quot;myorg-system&quot; created
$ kubectl create serviceaccount tiller --namespace myorg-system
serviceaccount &quot;tiller&quot; created
</code></pre>

<p>Define a Role that allows Tiller to manage all resources in <code>myorg-users</code> like in <code>role-tiller.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: myorg-users
rules:
- apiGroups: [&quot;&quot;, &quot;batch&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;*&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>Bind the service account to that role. In <code>rolebinding-tiller.yaml</code>,</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-users
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<p>We&rsquo;ll also need to grant Tiller access to read configmaps in myorg-system so it can store release information. In <code>role-tiller-myorg-system.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: myorg-system
  name: tiller-manager
rules:
- apiGroups: [&quot;&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;configmaps&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller-myorg-system.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>And the respective role binding. In <code>rolebinding-tiller-myorg-system.yaml</code>:</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-system
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller-myorg-system.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<h2 id="helm-and-role-based-access-control">Helm and Role-based Access Control</h2>

<p>When running a Helm client in a pod, in order for the Helm client to talk to a Tiller instance, it will need certain privileges to be granted. Specifically, the Helm client will need to be able to create pods, forward ports and be able to list pods in the namespace where Tiller is running (so it can find Tiller).</p>

<h3 id="example-deploy-helm-in-a-namespace-talking-to-tiller-in-another-namespace">Example: Deploy Helm in a namespace, talking to Tiller in another namespace</h3>

<p>In this example, we will assume Tiller is running in a namespace called <code>tiller-world</code> and that the Helm client is running in a namespace called <code>helm-world</code>. By default, Tiller is running in the <code>kube-system</code> namespace.</p>

<p>In <code>helm-user.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm
  namespace: helm-world
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: tiller-user
  namespace: tiller-world
rules:
- apiGroups:
  - &quot;&quot;
  resources:
  - pods/portforward
  verbs:
  - create
- apiGroups:
  - &quot;&quot;
  resources:
  - pods
  verbs:
  - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tiller-user-binding
  namespace: tiller-world
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: tiller-user
subjects:
- kind: ServiceAccount
  name: helm
  namespace: helm-world
</code></pre>

<pre><code class="language-console">$ kubectl create -f helm-user.yaml
serviceaccount &quot;helm&quot; created
role &quot;tiller-user&quot; created
rolebinding &quot;tiller-user-binding&quot; created
</code></pre>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="related-projects-and-documentation">Related Projects and Documentation</h1>

<p>The Helm community has produced many extra tools, plugins, and documentation about
Helm. We love to hear about these projects. If you have anything you&rsquo;d like to
add to this list, please open an <a href="https://github.com/helm/helm/issues">issue</a>
or <a href="https://github.com/helm/helm/pulls">pull request</a>.</p>

<h2 id="article-blogs-how-tos-and-extra-documentation">Article, Blogs, How-Tos, and Extra Documentation</h2>

<ul>
<li><a href="https://github.com/cdwv/awesome-helm">Awesome Helm</a> - List of awesome Helm resources</li>
<li><a href="http://www.slideshare.net/Diacode/cicd-with-kubernetes-helm-wercker-madscalability">CI/CD with Kubernetes, Helm &amp; Wercker </a></li>
<li><a href="http://technosophos.com/2017/03/21/creating-a-helm-plugin.html">Creating a Helm Plugin in 3 Steps</a></li>
<li><a href="http://cloudacademy.com/blog/deploying-kubernetes-applications-with-helm/">Deploying Kubernetes Applications with Helm</a></li>
<li><a href="https://medium.com/@enxebre/gitlab-consumer-driven-contracts-helm-and-kubernetes-b7235a60a1cb#.xwp1y4tgi">GitLab, Consumer Driven Contracts, Helm and Kubernetes</a></li>
<li><a href="https://gist.github.com/so0k/f927a4b60003cedd101a0911757c605a">Honestbee&rsquo;s Helm Chart Conventions</a></li>
<li><a href="https://medium.com/@enxebre/releasing-backward-incompatible-changes-kubernetes-jenkins-plugin-prometheus-operator-helm-self-6263ca61a1b1#.e0c7elxhq">Releasing backward-incompatible changes: Kubernetes, Jenkins, Prometheus Operator, Helm and Traefik</a></li>
<li><a href="https://hackernoon.com/the-missing-ci-cd-kubernetes-component-helm-package-manager-1fe002aac680#.691sk2zhu">The Missing CI/CD Kubernetes Component: Helm package manager</a></li>
<li><a href="https://daemonza.github.io/2017/02/20/using-helm-to-deploy-to-kubernetes/">Using Helm to Deploy to Kubernetes</a></li>
<li><a href="https://www.influxdata.com/packaged-kubernetes-deployments-writing-helm-chart/">Writing a Helm Chart</a></li>
<li><a href="https://github.com/muffin87/helm-tutorial">A basic walk through Kubernetes Helm</a></li>
<li><a href="https://rimusz.net/tillerless-helm/">Tillerless Helm v2</a></li>
</ul>

<h2 id="video-audio-and-podcast">Video, Audio, and Podcast</h2>

<ul>
<li><a href="https://www.youtube.com/watch?v=NVoln4HdZOY">CI/CD with Jenkins, Kubernetes, and Helm</a>: AKA &ldquo;The Infamous Croc Hunter Video&rdquo;.</li>
<li><a href="https://gcppodcast.com/post/episode-50-helm-with-michelle-noorali-and-matthew-butcher/">Helm with Michelle Noorali and Matthew Butcher</a>: The official Google CloudPlatform Podcast interviews Michelle and Matt about Helm.</li>
<li><a href="https://www.youtube.com/watch?v=zBc1goRfk3k&amp;index=49&amp;list=PLj6h78yzYM2PqgIGU1Qmi8nY7dqn9PCr4">KubeCon2016: Delivering Kubernetes-Native Applications by Michelle Noorali</a></li>
</ul>

<h2 id="helm-plugins">Helm Plugins</h2>

<ul>
<li><a href="https://github.com/app-registry/helm-plugin">App Registry</a> - Plugin to manage charts via the <a href="https://github.com/app-registry/spec">App Registry specification</a></li>
<li><a href="https://github.com/maorfr/helm-backup">helm-backup</a> - Plugin which performs backup/restore of releases in a namespace to/from a file</li>
<li><a href="https://github.com/databus23/helm-diff">Helm Diff</a> - Preview <code>helm upgrade</code> as a coloured diff</li>
<li><a href="https://github.com/skuid/helm-value-store">Helm Value Store</a> - Plugin for working with Helm deployment values</li>
<li><a href="https://github.com/technosophos/helm-plugins">Technosophos&rsquo;s Helm Plugins</a> - Plugins for GitHub, Keybase, and GPG</li>
<li><a href="https://github.com/ContainerSolutions/helm-convert">helm-convert</a> - Plugin to convert charts into Kustomize compatible packages</li>
<li><a href="https://github.com/imroc/helm-cos">helm-cos</a> - Plugin to manage repositories on Tencent Cloud Object Storage</li>
<li><a href="https://github.com/mstrzele/helm-edit">helm-edit</a> - Plugin for editing release&rsquo;s values</li>
<li><a href="https://github.com/adamreese/helm-env">helm-env</a> - Plugin to show current environment</li>
<li><a href="https://github.com/nouney/helm-gcs">helm-gcs</a> - Plugin to manage repositories on Google Cloud Storage</li>
<li><a href="https://github.com/sagansystems/helm-github">helm-github</a> - Plugin to install Helm Charts from Github repositories</li>
<li><a href="https://github.com/balboah/helm-hashtag">helm-hashtag</a> - Plugin for tracking docker tag hash digests as values</li>
<li><a href="https://github.com/maorfr/helm-inject">helm-inject</a> - Plugin for injecting additional configurations during release upgrade</li>
<li><a href="https://github.com/cststack/k8comp">helm-k8comp</a> - Plugin to create Helm Charts from hiera using k8comp</li>
<li><a href="https://github.com/adamreese/helm-last">helm-last</a> - Plugin to show the latest release</li>
<li><a href="https://github.com/adamreese/helm-local">helm-local</a> - Plugin to run Tiller as a local daemon</li>
<li><a href="https://github.com/maorfr/helm-logs">helm-logs</a> - Plugin to view changed releases over time</li>
<li><a href="https://github.com/ContainerSolutions/helm-monitor">helm-monitor</a> - Plugin to monitor a release and rollback based on Prometheus/ElasticSearch query</li>
<li><a href="https://github.com/adamreese/helm-nuke">helm-nuke</a> - Plugin to destroy all releases</li>
<li><a href="https://github.com/maorfr/helm-plugin-utils">helm-plugin-utils</a> - Utility functions to be used within Helm plugins</li>
<li><a href="https://github.com/maorfr/helm-restore">helm-restore</a> - Plugin to restore a deployed release to its original state</li>
<li><a href="https://github.com/futuresimple/helm-secrets">helm-secrets</a> - Plugin to manage and store secrets safely</li>
<li><a href="https://github.com/IBM/helm-stop">helm-stop</a> - Plugin for stopping a release pods</li>
<li><a href="https://github.com/technosophos/helm-template">helm-template</a> - Debug/render templates client-side</li>
<li><a href="https://github.com/adamreese/helm-tiller">helm-tiller</a> - Additional commands to work with Tiller</li>
<li><a href="https://github.com/lrills/helm-unittest">helm-unittest</a> - Plugin for unit testing chart locally with YAML</li>
<li><a href="https://github.com/rimusz/helm-tiller">Tillerless Helm v2</a> - Helm plugin for using Tiller locally and in CI/CD pipelines</li>
</ul>

<p>We also encourage GitHub authors to use the <a href="https://github.com/search?q=topic%3Ahelm-plugin&amp;type=Repositories">helm-plugin</a>
tag on their plugin repositories.</p>

<h2 id="additional-tools">Additional Tools</h2>

<p>Tools layered on top of Helm or Tiller.</p>

<ul>
<li><a href="https://github.com/appscode/swift">AppsCode Swift</a> - Ajax friendly Helm Tiller Proxy using <a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a></li>
<li><a href="https://github.com/att-comdev/armada">Armada</a> - Manage prefixed releases throughout various Kubernetes namespaces, and removes completed jobs for complex deployments. Used by the <a href="https://github.com/openstack/openstack-helm">Openstack-Helm</a> team.</li>
<li><a href="https://github.com/reactiveops/autohelm">Autohelm</a> - Autohelm is <em>another</em> simple declarative spec for deploying helm charts. Written in python and supports git urls as a source for helm charts.</li>
<li><a href="https://github.com/chartmuseum/chartmuseum">ChartMuseum</a> - Helm Chart Repository with support for Amazon S3 and Google Cloud Storage</li>
<li><a href="https://github.com/appscode/chartify">Chartify</a> - Generate Helm charts from existing Kubernetes resources.</li>
<li><a href="https://codefresh.io">Codefresh</a> - Kubernetes native CI/CD and management platform with UI dashboards for managing Helm charts and releases</li>
<li><a href="https://github.com/ohaiwalt/cog-helm">Cog</a> - Helm chart to deploy Cog on Kubernetes</li>
<li><a href="http://plugins.drone.io/ipedrazas/drone-helm/">Drone.io Helm Plugin</a> - Run Helm inside of the Drone CI/CD system</li>
<li><a href="https://github.com/luizbafilho/helm-chart-publisher">Helm Chart Publisher</a> - HTTP API for publishing Helm Charts in an easy way</li>
<li><a href="https://github.com/qmfrederik/helm">Helm.NET</a> - A .NET client for Tiller&rsquo;s API</li>
<li><a href="https://github.com/roboll/helmfile">Helmfile</a> - Helmfile is a declarative spec for deploying helm charts</li>
<li><a href="https://github.com/Praqma/helmsman">Helmsman</a> - Helmsman is a helm-charts-as-code tool which enables installing/upgrading/protecting/moving/deleting releases from version controlled desired state files (described in a simple TOML format).</li>
<li><a href="https://github.com/Eneco/landscaper/">Landscaper</a> - &ldquo;Landscaper takes a set of Helm Chart references with values (a desired state), and realizes this in a Kubernetes cluster.&rdquo;</li>
<li><a href="https://github.com/helm/monocular">Monocular</a> - Web UI for Helm Chart repositories</li>
<li><a href="https://github.com/maorfr/orca">Orca</a> - Advanced CI\CD tool for Kubernetes and Helm made simple.</li>
<li><a href="https://coreos.com/blog/quay-application-registry-for-kubernetes.html">Quay App Registry</a> - Open Kubernetes application registry, including a Helm access client</li>
<li><a href="https://github.com/AcalephStorage/rudder">Rudder</a> - RESTful (JSON) proxy for Tiller&rsquo;s API</li>
<li><a href="https://github.com/databus23/schelm">Schelm</a> - Render a Helm manifest to a directory</li>
<li><a href="https://github.com/andrewstuart/vim-kubernetes">VIM-Kubernetes</a> - VIM plugin for Kubernetes and Helm</li>
</ul>

<h2 id="helm-included">Helm Included</h2>

<p>Platforms, distributions, and services that include Helm support.</p>

<ul>
<li><a href="http://www.skippbox.com/cabin/">Cabin</a> - Mobile App for Managing Kubernetes</li>
<li><a href="https://fabric8.io">Fabric8</a> - Integrated development platform for Kubernetes</li>
<li><a href="http://jenkins-x.io/">Jenkins X</a> - open source automated CI/CD for Kubernetes which uses Helm for <a href="http://jenkins-x.io/about/features/#promotion">promoting</a> applications through <a href="http://jenkins-x.io/about/features/#environments">environments via GitOps</a></li>
<li><a href="https://kubernetic.com/">Kubernetic</a> - Kubernetes Desktop Client</li>
<li><a href="https://qstack.com">Qstack</a></li>
</ul>

<h2 id="misc">Misc</h2>

<p>Grab bag of useful things for Chart authors and Helm users</p>

<ul>
<li><a href="https://github.com/saltside/await">Await</a> - Docker image to &ldquo;await&rdquo; different conditions&ndash;especially useful for init containers. <a href="http://blog.slashdeploy.com/2017/02/16/introducing-await/">More Info</a></li>
</ul>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="release-checklist">Release Checklist</h1>

<p><strong>IMPORTANT</strong>: If your experience deviates from this document, please document the changes to keep it up-to-date.</p>

<h2 id="release-meetings">Release Meetings</h2>

<p>As part of the release process, two of the weekly developer calls will be co-opted
as &ldquo;release meetings.&rdquo;</p>

<h3 id="start-of-the-release-cycle">Start of the Release Cycle</h3>

<p>The first developer call after a release will be used as the release meeting to
start the next release cycle. During this meeting, the following items must be
identified:</p>

<ul>
<li>Release date</li>
<li>Goals/Objectives for this release</li>
<li>The release manager (basically whoever is going to cut the release)</li>
<li>Any other important details for the community</li>
</ul>

<p>All of this information should be added to the GitHub milestone for the given
release. This should give the community and maintainers a clear set of guidelines
to follow when choosing whether or not to add issues and PRs to a given release.</p>

<h3 id="end-almost-of-the-release-cycle">End (almost) of the Release Cycle</h3>

<p>The developer call closest to two weeks before the scheduled release date will
be used to review any remaining PRs that should be pulled into the release. This
is the place to debate whether or not we should wait before cutting a release and
any other concerns. At the end of this meeting, if the release date has not been
pushed out, the first RC should be cut. Subsequent developer calls in between this
meeting and the release date should have some time set aside to see if any bugs
were found. Once the release date is reached, the final release can be cut</p>

<h2 id="a-maintainer-s-guide-to-releasing-helm">A Maintainer&rsquo;s Guide to Releasing Helm</h2>

<p>So you&rsquo;re in charge of a new release for Helm? Cool. Here&rsquo;s what to do&hellip;</p>

<p><img src="https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/nothing.png" alt="TODO: Nothing" /></p>

<p>Just kidding! :trollface:</p>

<p>All releases will be of the form vX.Y.Z where X is the major version number, Y is the minor version number and Z is the patch release number. This project strictly follows <a href="http://semver.org/">semantic versioning</a> so following this step is critical.</p>

<p>It is important to note that this document assumes that the git remote in your repository that corresponds to &ldquo;<a href="https://github.com/helm/helm&quot;">https://github.com/helm/helm&quot;</a> is named &ldquo;upstream&rdquo;. If yours is not (for example, if you&rsquo;ve chosen to name it &ldquo;origin&rdquo; or something similar instead), be sure to adjust the listed snippets for your local environment accordingly. If you are not sure what your upstream remote is named, use a command like <code>git remote -v</code> to find out.</p>

<p>If you don&rsquo;t have an upstream remote, you can add one easily using something like:</p>

<pre><code class="language-shell">git remote add upstream git@github.com:helm/helm.git
</code></pre>

<p>In this doc, we are going to reference a few environment variables as well, which you may want to set for convenience. For major/minor releases, use the following:</p>

<pre><code class="language-shell">export RELEASE_NAME=vX.Y.0
export RELEASE_BRANCH_NAME=&quot;release-X.Y&quot;
export RELEASE_CANDIDATE_NAME=&quot;$RELEASE_NAME-rc.1&quot;
</code></pre>

<p>If you are creating a patch release, you may want to use the following instead:</p>

<pre><code class="language-shell">export PREVIOUS_PATCH_RELEASE=vX.Y.Z
export RELEASE_NAME=vX.Y.Z+1
export RELEASE_BRANCH_NAME=&quot;release-X.Y&quot;
export RELEASE_CANDIDATE_NAME=&quot;$RELEASE_NAME-rc.1&quot;
</code></pre>

<h2 id="1-create-the-release-branch">1. Create the Release Branch</h2>

<h3 id="major-minor-releases">Major/Minor Releases</h3>

<p>Major releases are for new feature additions and behavioral changes <em>that break backwards compatibility</em>. Minor releases are for new feature additions that do not break backwards compatibility. To create a major or minor release, start by creating a <code>release-vX.Y.0</code> branch from master.</p>

<pre><code class="language-shell">git fetch upstream
git checkout upstream/master
git checkout -b $RELEASE_BRANCH_NAME
</code></pre>

<p>This new branch is going to be the base for the release, which we are going to iterate upon later.</p>

<h3 id="patch-releases">Patch releases</h3>

<p>Patch releases are a few critical cherry-picked fixes to existing releases. Start by creating a <code>release-vX.Y.Z</code> branch from the latest patch release.</p>

<pre><code class="language-shell">git fetch upstream --tags
git checkout $PREVIOUS_PATCH_RELEASE
git checkout -b $RELEASE_BRANCH_NAME
</code></pre>

<p>From here, we can cherry-pick the commits we want to bring into the patch release:</p>

<pre><code class="language-shell"># get the commits ids we want to cherry-pick
git log --oneline
# cherry-pick the commits starting from the oldest one, without including merge commits
git cherry-pick -x &lt;commit-id&gt;
git cherry-pick -x &lt;commit-id&gt;
</code></pre>

<p>This new branch is going to be the base for the release, which we are going to iterate upon later.</p>

<h2 id="2-change-the-version-number-in-git">2. Change the Version Number in Git</h2>

<p>When doing a minor release, make sure to update pkg/version/version.go with the new release version.</p>

<pre><code class="language-shell">$ git diff pkg/version/version.go
diff --git a/pkg/version/version.go b/pkg/version/version.go
index 2109a0a..6f5a1a4 100644
--- a/pkg/version/version.go
+++ b/pkg/version/version.go
@@ -26,7 +26,7 @@ var (
        // Increment major number for new feature additions and behavioral changes.
        // Increment minor number for bug fixes and performance enhancements.
        // Increment patch number for critical fixes to existing releases.
-       Version = &quot;v2.6&quot;
+       Version = &quot;v2.7&quot;

        // BuildMetadata is extra build time data
        BuildMetadata = &quot;unreleased&quot;
</code></pre>

<pre><code class="language-shell">git add .
git commit -m &quot;bump version to $RELEASE_CANDIDATE_NAME&quot;
</code></pre>

<h2 id="3-commit-and-push-the-release-branch">3. Commit and Push the Release Branch</h2>

<p>In order for others to start testing, we can now push the release branch upstream and start the test process.</p>

<pre><code class="language-shell">git push upstream $RELEASE_BRANCH_NAME
</code></pre>

<p>Make sure to check <a href="https://circleci.com/gh/helm/helm">helm on CircleCI</a> and make sure the release passed CI before proceeding.</p>

<p>If anyone is available, let others peer-review the branch before continuing to ensure that all the proper changes have been made and all of the commits for the release are there.</p>

<h2 id="4-create-a-release-candidate">4. Create a Release Candidate</h2>

<p>Now that the release branch is out and ready, it is time to start creating and iterating on release candidates.</p>

<pre><code class="language-shell">git tag --sign --annotate &quot;${RELEASE_CANDIDATE_NAME}&quot; --message &quot;Helm release ${RELEASE_CANDIDATE_NAME}&quot;
git push upstream $RELEASE_CANDIDATE_NAME
</code></pre>

<p>CircleCI will automatically create a tagged release image and client binary to test with.</p>

<p>For testers, the process to start testing after CircleCI finishes building the artifacts involves the following steps to grab the client from Google Cloud Storage:</p>

<p>linux/amd64, using /bin/bash:</p>

<pre><code class="language-shell">wget https://kubernetes-helm.storage.googleapis.com/helm-$RELEASE_CANDIDATE_NAME-linux-amd64.tar.gz
</code></pre>

<p>darwin/amd64, using Terminal.app:</p>

<pre><code class="language-shell">wget https://kubernetes-helm.storage.googleapis.com/helm-$RELEASE_CANDIDATE_NAME-darwin-amd64.tar.gz
</code></pre>

<p>windows/amd64, using PowerShell:</p>

<pre><code class="language-shell">PS C:\&gt; Invoke-WebRequest -Uri &quot;https://kubernetes-helm.storage.googleapis.com/helm-$RELEASE_CANDIDATE_NAME-windows-amd64.zip&quot; -OutFile &quot;helm-$ReleaseCandidateName-windows-amd64.zip&quot;
</code></pre>

<p>Then, unpack and move the binary to somewhere on your $PATH, or move it somewhere and add it to your $PATH (e.g. /usr/local/bin/helm for linux/macOS, C:\Program Files\helm\helm.exe for Windows).</p>

<h2 id="5-iterate-on-successive-release-candidates">5. Iterate on Successive Release Candidates</h2>

<p>Spend several days explicitly investing time and resources to try and break helm in every possible way, documenting any findings pertinent to the release. This time should be spent testing and finding ways in which the release might have caused various features or upgrade environments to have issues, not coding. During this time, the release is in code freeze, and any additional code changes will be pushed out to the next release.</p>

<p>During this phase, the $RELEASE_BRANCH_NAME branch will keep evolving as you will produce new release candidates. The frequency of new candidates is up to the release manager: use your best judgement taking into account the severity of reported issues, testers&rsquo; availability, and the release deadline date. Generally speaking, it is better to let a release roll over the deadline than to ship a broken release.</p>

<p>Each time you&rsquo;ll want to produce a new release candidate, you will start by adding commits to the branch by cherry-picking from master:</p>

<pre><code class="language-shell">git cherry-pick -x &lt;commit_id&gt;
</code></pre>

<p>You will also want to update the release version number and the CHANGELOG as we did in steps 2 and 3 as separate commits.</p>

<p>After that, tag it and notify users of the new release candidate:</p>

<pre><code class="language-shell">export RELEASE_CANDIDATE_NAME=&quot;$RELEASE_NAME-rc.2&quot;
git tag --sign --annotate &quot;${RELEASE_CANDIDATE_NAME}&quot; --message &quot;Helm release ${RELEASE_CANDIDATE_NAME}&quot;
git push upstream $RELEASE_CANDIDATE_NAME
</code></pre>

<p>From here on just repeat this process, continuously testing until you&rsquo;re happy with the release candidate.</p>

<h2 id="6-finalize-the-release">6. Finalize the Release</h2>

<p>When you&rsquo;re finally happy with the quality of a release candidate, you can move on and create the real thing. Double-check one last time to make sure everything is in order, then finally push the release tag.</p>

<pre><code class="language-shell">git checkout $RELEASE_BRANCH_NAME
git tag --sign --annotate &quot;${RELEASE_NAME}&quot; --message &quot;Helm release ${RELEASE_NAME}&quot;
git push upstream $RELEASE_NAME
</code></pre>

<h2 id="7-write-the-release-notes">7. Write the Release Notes</h2>

<p>We will auto-generate a changelog based on the commits that occurred during a release cycle, but it is usually more beneficial to the end-user if the release notes are hand-written by a human being/marketing team/dog.</p>

<p>If you&rsquo;re releasing a major/minor release, listing notable user-facing features is usually sufficient. For patch releases, do the same, but make note of the symptoms and who is affected.</p>

<p>An example release note for a minor release would look like this:</p>

<pre><code class="language-markdown">## vX.Y.Z

Helm vX.Y.Z is a feature release. This release, we focused on &lt;insert focal point&gt;. Users are encouraged to upgrade for the best experience.

The community keeps growing, and we'd love to see you there!

- Join the discussion in [Kubernetes Slack](https://kubernetes.slack.com):
  - `#helm-users` for questions and just to hang out
  - `#helm-dev` for discussing PRs, code, and bugs
- Hang out at the Public Developer Call: Thursday, 9:30 Pacific via [Zoom](https://zoom.us/j/696660622)
- Test, debug, and contribute charts: [GitHub/helm/charts](https://github.com/helm/charts)

## Installation and Upgrading

Download Helm X.Y. The common platform binaries are here:

- [MacOS amd64](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-darwin-amd64.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-darwin-amd64.tar.gz.sha256))
- [Linux amd64](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-amd64.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-amd64.tar.gz.sha256))
- [Linux arm](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-arm.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-arm.tar.gz.sha256))
- [Linux arm64](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-arm64.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-arm64.tar.gz.sha256))
- [Linux i386](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-386.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-386.tar.gz.sha256))
- [Linux ppc64le](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-ppc64le.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-ppc64le.tar.gz.sha256))
- [Linux s390x](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-s390x.tar.gz) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-linux-s390x.tar.gz.sha256))
- [Windows amd64](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-windows-amd64.zip) ([checksum](https://storage.googleapis.com/kubernetes-helm/helm-vX.Y.Z-windows-amd64.zip.sha256))

Once you have the client installed, upgrade Tiller with `helm init --upgrade`.

The [Quickstart Guide](https://docs.helm.sh/using_helm/#quickstart-guide) will get you going from there. For **upgrade instructions** or detailed installation notes, check the [install guide](https://docs.helm.sh/using_helm/#installing-helm). You can also use a [script to install](https://raw.githubusercontent.com/helm/helm/master/scripts/get) on any system with `bash`.

## What's Next

- vX.Y.Z+1 will contain only bug fixes.
- vX.Y+1.Z is the next feature release. This release will focus on ...

## Changelog

- chore(*): bump version to v2.7.0 08c1144f5eb3e3b636d9775617287cc26e53dba4 (Adam Reese)
- fix circle not building tags f4f932fabd197f7e6d608c8672b33a483b4b76fa (Matthew Fisher)
</code></pre>

<p>The changelog at the bottom of the release notes can be generated with this command:</p>

<pre><code class="language-shell">PREVIOUS_RELEASE=vX.Y.Z
git log --no-merges --pretty=format:'- %s %H (%aN)' $PREVIOUS_RELEASE..$RELEASE_NAME
</code></pre>

<p>Once finished, go into GitHub and edit the release notes for the tagged release with the notes written here.</p>

<h2 id="8-evangelize">8. Evangelize</h2>

<p>Congratulations! You&rsquo;re done. Go grab yourself a $DRINK_OF_CHOICE. You&rsquo;ve earned it.</p>

<p>After enjoying a nice $DRINK_OF_CHOICE, go forth and announce the glad tidings of the new release in Slack and on Twitter. You should also notify any key partners in the helm community such as the homebrew formula maintainers, the owners of incubator projects (e.g. ChartMuseum) and any other interested parties.</p>

<p>Optionally, write a blog post about the new release and showcase some of the new features on there!</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="securing-your-helm-installation">Securing your Helm Installation</h1>

<p>Helm is a powerful and flexible package-management and operations tool for Kubernetes. Installing it using the default installation command &ndash; <code>helm init</code> &ndash; quickly and easily installs <strong>Tiller</strong>, the server-side component with which Helm corresponds.</p>

<p>This default installation applies <strong><em>no security configurations</em></strong>, however. It&rsquo;s completely appropriate to use this type of installation when you are working against a cluster with no or very few security concerns, such as local development with Minikube or with a cluster that is well-secured in a private network with no data-sharing or no other users or teams. If this is the case, then the default installation is fine, but remember: With great power comes great responsibility. Always use due diligence when deciding to use the default installation.</p>

<h2 id="who-needs-security-configurations">Who Needs Security Configurations?</h2>

<p>For the following types of clusters we strongly recommend that you apply the proper security configurations to Helm and Tiller to ensure the safety of the cluster, the data in it, and the network to which it is connected.</p>

<ul>
<li>Clusters that are exposed to uncontrolled network environments: either untrusted network actors can access the cluster, or untrusted applications that can access the network environment.</li>
<li>Clusters that are for many people to use &ndash; <em>multitenant</em> clusters &ndash; as a shared environment</li>
<li>Clusters that have access to or use high-value data or networks of any type</li>
</ul>

<p>Often, environments like these are referred to as <em>production grade</em> or <em>production quality</em> because the damage done to any company by misuse of the cluster can be profound for either customers, the company itself, or both. Once the risk of damage becomes high enough, you need to ensure the integrity of your cluster no matter what the actual risk.</p>

<p>To configure your installation properly for your environment, you must:</p>

<ul>
<li>Understand the security context of your cluster</li>
<li>Choose the Best Practices you should apply to your helm installation</li>
</ul>

<p>The following assumes you have a Kubernetes configuration file (a <em>kubeconfig</em> file) or one was given to you to access a cluster.</p>

<h2 id="understanding-the-security-context-of-your-cluster">Understanding the Security Context of your Cluster</h2>

<p><code>helm init</code> installs Tiller into the cluster in the <code>kube-system</code> namespace and without any RBAC rules applied. This is appropriate for local development and other private scenarios because it enables you to be productive immediately. It also enables you to continue running Helm with existing Kubernetes clusters that do not have role-based access control (RBAC) support until you can move your workloads to a more recent Kubernetes version.</p>

<p>There are four main areas to consider when securing a tiller installation:</p>

<ol>
<li>Role-based access control, or RBAC</li>
<li>Tiller&rsquo;s gRPC endpoint and its usage by Helm</li>
<li>Tiller release information</li>
<li>Helm charts</li>
</ol>

<h3 id="rbac">RBAC</h3>

<p>Recent versions of Kubernetes employ a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">role-based access control (or RBAC)</a> system (as do modern operating systems) to help mitigate the damage that can be done if credentials are misused or bugs exist. Even where an identity is hijacked, the identity has only so many permissions to a controlled space. This effectively adds a layer of security to limit the scope of any attack with that identity.</p>

<p>Helm and Tiller are designed to install, remove, and modify logical applications that can contain many services interacting together. As a result, often its usefulness involves cluster-wide operations, which in a multitenant cluster means that great care must be taken with access to a cluster-wide Tiller installation to prevent improper activity.</p>

<p>Specific users and teams &ndash; developers, operators, system and network administrators &ndash; will need their own portion of the cluster in which they can use Helm and Tiller without risking other portions of the cluster. This means using a Kubernetes cluster with RBAC enabled and Tiller configured to enforce them. For more information about using RBAC in Kubernetes, see <a href="./#role-based-access-control">Using RBAC Authorization</a>.</p>

<h4 id="tiller-and-user-permissions">Tiller and User Permissions</h4>

<p>Tiller in its current form does not provide a way to map user credentials to specific permissions within Kubernetes. When Tiller is running inside of the cluster, it operates with the permissions of its service account. If no service account name is supplied to Tiller, it runs with the default service account for that namespace. This means that all Tiller operations on that server are executed using the Tiller pod&rsquo;s credentials and permissions.</p>

<p>To properly limit what Tiller itself can do, the standard Kubernetes RBAC mechanisms must be attached to Tiller, including Roles and RoleBindings that place explicit limits on what things a Tiller instance can install, and where.</p>

<p>This situation may change in the future. While the community has several methods that might address this, at the moment performing actions using the rights of the client, instead of the rights of Tiller, is contingent upon the outcome of the Pod Identity Working Group, which has taken on the task of solving the problem in a general way.</p>

<h3 id="the-tiller-grpc-endpoint">The Tiller gRPC Endpoint</h3>

<p>In the default installation the gRPC endpoint that Tiller offers is available inside the cluster (not external to the cluster) without authentication configuration applied. Without applying authentication, any process in the cluster can use the gRPC endpoint to perform operations inside the cluster. In a local or secured private cluster, this enables rapid usage and is normal. (When running outside the cluster, Helm authenticates through the Kubernetes API server to reach Tiller, leveraging existing Kubernetes authentication support.)</p>

<p>The following two sub-sections describe options of how to setup Tiller so there isn&rsquo;t an unauthenticated endpoint (i.e. gRPC) in your cluster.</p>

<h4 id="enabling-tls">Enabling TLS</h4>

<p>(Note that out of the two options, this is the recommended one for Helm 2.)</p>

<p>Shared and production clusters &ndash; for the most part &ndash; should use Helm 2.7.2 at a minimum and configure TLS for each Tiller gRPC endpoint to ensure that within the cluster usage of gRPC endpoints is only for the properly authenticated identity for that endpoint (i.e. configure each endpoint to use a separate TLS certificate). Doing so enables any number of Tiller instances to be deployed in any number of namespaces and yet no unauthenticated usage of any gRPC endpoint is possible. Finally, use Helm <code>init</code> with the <code>--tiller-tls-verify</code> option to install Tiller with TLS enabled and to verify remote certificates, and all other Helm commands should use the <code>--tls</code> option.</p>

<p>For more information about the proper steps to configure Tiller and use Helm properly with TLS configured, see the <a href="./##best-practices-for-securing-helm-and-tiller">Best Practices</a> section below, and <a href="tiller_ssl">Using SSL between Helm and Tiller</a>.</p>

<p>When Helm clients are connecting from outside of the cluster, the security between the Helm client and the API server is managed by Kubernetes itself. You may want to ensure that this link is secure. Note that if you are using the TLS configuration recommended above, not even the Kubernetes API server has access to the encrypted messages between the client and Tiller.</p>

<h4 id="running-tiller-locally">Running Tiller Locally</h4>

<p>Contrary to the previous <a href="./##enabling-tls">Enabling TLS</a> section, this section does not involve running a tiller server pod in your cluster (for what it&rsquo;s worth, that lines up with the current <a href="https://github.com/helm/community/blob/master/helm-v3/000-helm-v3">helm v3 proposal</a>), thus there is no gRPC endpoint (and thus there&rsquo;s no need to create &amp; manage TLS certificates to secure each gRPC endpoint).</p>

<p>Steps:
 * Fetch the latest helm release tarball from the <a href="https://github.com/helm/helm/releases">GitHub release page</a>, and extract and move <code>helm</code> and <code>tiller</code> somewhere on your <code>$PATH</code>.
 * &ldquo;Server&rdquo;: Run <code>tiller --storage=secret</code>. (Note that <code>tiller</code> has a default value of &ldquo;:44134&rdquo; for the <code>--listen</code> argument.)
 * Client: In another terminal (and on the same host that the aforementioned <code>tiller</code> command was run for the previous bullet): Run <code>export HELM_HOST=:44134</code>, and then run <code>helm</code> commands as usual.</p>

<h3 id="tiller-s-release-information">Tiller&rsquo;s Release Information</h3>

<p>For historical reasons, Tiller stores its release information in ConfigMaps. We suggest changing the default to Secrets.</p>

<p>Secrets are the Kubernetes accepted mechanism for saving configuration data that is considered sensitive. While secrets don&rsquo;t themselves offer many protections, Kubernetes cluster management software often treats them differently than other objects. Thus, we suggest using secrets to store releases.</p>

<p>Enabling this feature currently requires setting the <code>--storage=secret</code> flag in the tiller-deploy deployment. This entails directly modifying the deployment or using <code>helm init --override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}'</code>, as no helm init flag is currently available to do this for you.</p>

<h3 id="thinking-about-charts">Thinking about Charts</h3>

<p>Because of the relative longevity of Helm, the Helm chart ecosystem evolved without the immediate concern for cluster-wide control, and especially in the developer space this makes complete sense. However, charts are a kind of package that not only installs containers you may or may not have validated yourself, but it may also install into more than one namespace.</p>

<p>As with all shared software, in a controlled or shared environment you must validate all software you install yourself <em>before</em> you install it. If you have secured Tiller with TLS and have installed it with permissions to only one or a subset of namespaces, some charts may fail to install &ndash; but in these environments, that is exactly what you want. If you need to use the chart, you may have to work with the creator or modify it yourself in order to use it securely in a multitenant cluster with proper RBAC rules applied. The <code>helm template</code> command renders the chart locally and displays the output.</p>

<p>Once vetted, you can use Helm&rsquo;s provenance tools to <a href="./#helm-provenance-and-integrity">ensure the provenance and integrity of charts</a> that you use.</p>

<h3 id="grpc-tools-and-secured-tiller-configurations">gRPC Tools and Secured Tiller Configurations</h3>

<p>Many very useful tools use the gRPC interface directly, and having been built against the default installation &ndash; which provides cluster-wide access &ndash; may fail once security configurations have been applied. RBAC policies are controlled by you or by the cluster operator, and either can be adjusted for the tool, or the tool can be configured to work properly within the constraints of specific RBAC policies applied to Tiller. The same may need to be done if the gRPC endpoint is secured: the tools need their own secure TLS configuration in order to use a specific Tiller instance. The combination of RBAC policies and a secured gRPC endpoint configured in conjunction with gRPC tools enables you to control your cluster environment as you should.</p>

<h2 id="best-practices-for-securing-helm-and-tiller">Best Practices for Securing Helm and Tiller</h2>

<p>The following guidelines reiterate the Best Practices for securing Helm and Tiller and using them correctly.</p>

<ol>
<li>Create a cluster with RBAC enabled</li>
<li>Configure each Tiller gRPC endpoint to use a separate TLS certificate</li>
<li>Release information should be a Kubernetes Secret</li>
<li>Install one Tiller per user, team, or other organizational entity with the <code>--service-account</code> flag, Roles, and RoleBindings</li>
<li>Use the <code>--tiller-tls-verify</code> option with <code>helm init</code> and the <code>--tls</code> flag with other Helm commands to enforce verification</li>
</ol>

<p>If these steps are followed, an example <code>helm init</code> command might look something like this:</p>

<pre><code class="language-bash">$ helm init \
--override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}' \
--tiller-tls \
--tiller-tls-verify \
--tiller-tls-cert=cert.pem \
--tiller-tls-key=key.pem \
--tls-ca-cert=ca.pem \
--service-account=accountname
</code></pre>

<p>This command will start Tiller with strong authentication over gRPC, release information stored in a Kubernetes Secret, and a service account to which RBAC policies have been applied.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="using-ssl-between-helm-and-tiller">Using SSL Between Helm and Tiller</h1>

<p>This document explains how to create strong SSL/TLS connections between Helm and
Tiller. The emphasis here is on creating an internal CA, and using both the
cryptographic and identity functions of SSL.</p>

<blockquote>
<p>Support for TLS-based auth was introduced in Helm 2.3.0</p>
</blockquote>

<p>Configuring SSL is considered an advanced topic, and knowledge of Helm and Tiller
is assumed.</p>

<h2 id="overview">Overview</h2>

<p>The Tiller authentication model uses client-side SSL certificates. Tiller itself
verifies these certificates using a certificate authority. Likewise, the client
also verifies Tiller&rsquo;s identity by certificate authority.</p>

<p>There are numerous possible configurations for setting up certificates and authorities,
but the method we cover here will work for most situations.</p>

<blockquote>
<p>As of Helm 2.7.2, Tiller <em>requires</em> that the client certificate be validated
by its CA. In prior versions, Tiller used a weaker validation strategy that
allowed self-signed certificates.</p>
</blockquote>

<p>In this guide, we will show how to:</p>

<ul>
<li>Create a private CA that is used to issue certificates for Tiller clients and
servers.</li>
<li>Create a certificate for Tiller</li>
<li>Create a certificate for the Helm client</li>
<li>Create a Tiller instance that uses the certificate</li>
<li>Configure the Helm client to use the CA and client-side certificate</li>
</ul>

<p>By the end of this guide, you should have a Tiller instance running that will
only accept connections from clients who can be authenticated by SSL certificate.</p>

<h2 id="generating-certificate-authorities-and-certificates">Generating Certificate Authorities and Certificates</h2>

<p>One way to generate SSL CAs is via the <code>openssl</code> command line tool. There are many
guides and best practices documents available online. This explanation is focused
on getting ready within a small amount of time. For production configurations,
we urge readers to read <a href="https://www.openssl.org">the official documentation</a> and
consult other resources.</p>

<h3 id="generate-a-certificate-authority">Generate a Certificate Authority</h3>

<p>The simplest way to generate a certificate authority is to run two commands:</p>

<pre><code class="language-console">$ openssl genrsa -out ./ca.key.pem 4096
$ openssl req -key ca.key.pem -new -x509 -days 7300 -sha256 -out ca.cert.pem -extensions v3_ca
Enter pass phrase for ca.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:CO
Locality Name (eg, city) []:Boulder
Organization Name (eg, company) [Internet Widgits Pty Ltd]:tiller
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:tiller
Email Address []:tiller@example.com
</code></pre>

<p>Note that the data input above is <em>sample data</em>. You should customize to your own
specifications.</p>

<p>The above will generate both a secret key and a CA. Note that these two files are
very important. The key in particular should be handled with particular care.</p>

<p>Often, you will want to generate an intermediate signing key. For the sake of brevity,
we will be signing keys with our root CA.</p>

<h3 id="generating-certificates">Generating Certificates</h3>

<p>We will be generating two certificates, each representing a type of certificate:</p>

<ul>
<li>One certificate is for Tiller. You will want one of these <em>per tiller host</em> that
you run.</li>
<li>One certificate is for the user. You will want one of these <em>per helm user</em>.</li>
</ul>

<p>Since the commands to generate these are the same, we&rsquo;ll be creating both at the
same time. The names will indicate their target.</p>

<p>First, the Tiller key:</p>

<pre><code class="language-console">$ openssl genrsa -out ./tiller.key.pem 4096
Generating RSA private key, 4096 bit long modulus
..........................................................................................................................................................................................................................................................................................................................++
............................................................................++
e is 65537 (0x10001)
Enter pass phrase for ./tiller.key.pem:
Verifying - Enter pass phrase for ./tiller.key.pem:
</code></pre>

<p>Next, generate the Helm client&rsquo;s key:</p>

<pre><code class="language-console">$ openssl genrsa -out ./helm.key.pem 4096
Generating RSA private key, 4096 bit long modulus
.....++
......................................................................................................................................................................................++
e is 65537 (0x10001)
Enter pass phrase for ./helm.key.pem:
Verifying - Enter pass phrase for ./helm.key.pem:
</code></pre>

<p>Again, for production use you will generate one client certificate for each user.</p>

<p>Next we need to create certificates from these keys. For each certificate, this is
a two-step process of creating a CSR, and then creating the certificate.</p>

<pre><code class="language-console">$ openssl req -key tiller.key.pem -new -sha256 -out tiller.csr.pem
Enter pass phrase for tiller.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:CO
Locality Name (eg, city) []:Boulder
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Tiller Server
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:tiller-server
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
</code></pre>

<p>And we repeat this step for the Helm client certificate:</p>

<pre><code class="language-console">$ openssl req -key helm.key.pem -new -sha256 -out helm.csr.pem
# Answer the questions with your client user's info
</code></pre>

<p>(In rare cases, we&rsquo;ve had to add the <code>-nodes</code> flag when generating the request.)</p>

<p>Now we sign each of these CSRs with the CA certificate we created (adjust the days parameter to suit your requirements):</p>

<pre><code class="language-console">$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in tiller.csr.pem -out tiller.cert.pem -days 365
Signature ok
subject=/C=US/ST=CO/L=Boulder/O=Tiller Server/CN=tiller-server
Getting CA Private Key
Enter pass phrase for ca.key.pem:
</code></pre>

<p>And again for the client certificate:</p>

<pre><code class="language-console">$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in helm.csr.pem -out helm.cert.pem  -days 365
</code></pre>

<p>At this point, the important files for us are these:</p>

<pre><code># The CA. Make sure the key is kept secret.
ca.cert.pem
ca.key.pem
# The Helm client files
helm.cert.pem
helm.key.pem
# The Tiller server files.
tiller.cert.pem
tiller.key.pem
</code></pre>

<p>Now we&rsquo;re ready to move on to the next steps.</p>

<h2 id="creating-a-custom-tiller-installation">Creating a Custom Tiller Installation</h2>

<p>Helm includes full support for creating a deployment configured for SSL. By specifying
a few flags, the <code>helm init</code> command can create a new Tiller installation complete
with all of our SSL configuration.</p>

<p>To take a look at what this will generate, run this command:</p>

<pre><code class="language-console">$ helm init --dry-run --debug --tiller-tls --tiller-tls-cert ./tiller.cert.pem --tiller-tls-key ./tiller.key.pem --tiller-tls-verify --tls-ca-cert ca.cert.pem
</code></pre>

<p>The output will show you a Deployment, a Secret, and a Service. Your SSL information
will be preloaded into the Secret, which the Deployment will mount to pods as they
start up.</p>

<p>If you want to customize the manifest, you can save that output to a file and then
use <code>kubectl create</code> to load it into your cluster.</p>

<blockquote>
<p>We strongly recommend enabling RBAC on your cluster and adding <a href="./#role-based-access-control">service accounts</a>
with RBAC.</p>
</blockquote>

<p>Otherwise, you can remove the <code>--dry-run</code> and <code>--debug</code> flags. We also recommend
putting Tiller in a non-system namespace (<code>--tiller-namespace=something</code>) and enable
a service account (<code>--service-account=somename</code>). But for this example we will stay
with the basics:</p>

<pre><code class="language-console">$ helm init --tiller-tls --tiller-tls-cert ./tiller.cert.pem --tiller-tls-key ./tiller.key.pem --tiller-tls-verify --tls-ca-cert ca.cert.pem
</code></pre>

<p>In a minute or two it should be ready. We can check Tiller like this:</p>

<pre><code class="language-console">$ kubectl -n kube-system get deployment
NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
... other stuff
tiller-deploy   1         1         1            1           2m
</code></pre>

<p>If there is a problem, you may want to use <code>kubectl get pods -n kube-system</code> to
find out what went wrong. With the SSL/TLS support, the most common problems all
have to do with improperly generated TLS certificates or accidentally swapping the
cert and the key.</p>

<p>At this point, you should get a <em>failure</em> when you run basic Helm commands:</p>

<pre><code class="language-console">$ helm ls
Error: transport is closing
</code></pre>

<p>This is because your Helm client does not have the correct certificate to authenticate
to Tiller.</p>

<h2 id="configuring-the-helm-client">Configuring the Helm Client</h2>

<p>The Tiller server is now running with TLS protection. It&rsquo;s time to configure the
Helm client to also perform TLS operations.</p>

<p>For a quick test, we can specify our configuration manually. We&rsquo;ll run a normal
Helm command (<code>helm ls</code>), but with SSL/TLS enabled.</p>

<pre><code class="language-console">helm ls --tls --tls-ca-cert ca.cert.pem --tls-cert helm.cert.pem --tls-key helm.key.pem
</code></pre>

<p>This configuration sends our client-side certificate to establish identity, uses
the client key for encryption, and uses the CA certificate to validate the remote
Tiller&rsquo;s identity.</p>

<p>Typing a line that is cumbersome, though. The shortcut is to move the key,
cert, and CA into <code>$HELM_HOME</code>:</p>

<pre><code class="language-console">$ cp ca.cert.pem $(helm home)/ca.pem
$ cp helm.cert.pem $(helm home)/cert.pem
$ cp helm.key.pem $(helm home)/key.pem
</code></pre>

<p>With this, you can simply run <code>helm ls --tls</code> to enable TLS.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p><em>Running a command, I get <code>Error: transport is closing</code></em></p>

<p>This is almost always due to a configuration error in which the client is missing
a certificate (<code>--tls-cert</code>) or the certificate is bad.</p>

<p><em>I&rsquo;m using a certificate, but get <code>Error: remote error: tls: bad certificate</code></em></p>

<p>This means that Tiller&rsquo;s CA cannot verify your certificate. In the examples above,
we used a single CA to generate both the client and server certificates. In these
examples, the CA has <em>signed</em> the client&rsquo;s certificate. We then load that CA
up to Tiller. So when the client certificate is sent to the server, Tiller
checks the client certificate against the CA.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: certificate is valid for tiller-server, not localhost</code></em></p>

<p>If you plan to use <code>--tls-verify</code> on the client, you will need to make sure that
the host name that Helm connects to matches the host name on the certificate. In
some cases this is awkward, since Helm will connect over localhost, or the FQDN is
not available for public resolution.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: cannot validate certificate for 127.0.0.1 because it doesn't contain any IP SANs</code></em></p>

<p>By default, the Helm client connects to Tiller via tunnel (i.e. kube proxy) at 127.0.0.1. During the TLS handshake,
a target, usually provided as a hostname (e.g. example.com), is checked against the subject and subject alternative
names of the certificate (i.e. hostname verficiation). However, because of the tunnel, the target is an IP address.
Therefore, to validate the certificate, the IP address 127.0.0.1 must be listed as an IP subject alternative name
(IP SAN) in the Tiller certificate.</p>

<p>For example, to list 127.0.0.1 as an IP SAN when generating the Tiller certificate:</p>

<pre><code class="language-console">$ echo subjectAltName=IP:127.0.0.1 &gt; extfile.cnf
$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in tiller.csr.pem -out tiller.cert.pem -days 365 -extfile extfile.cnf
</code></pre>

<p>Alternatively, you can override the expected hostname of the tiller certificate using the <code>--tls-hostname</code> flag.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: certificate has expired or is not yet valid</code></em></p>

<p>Your helm certificate has expired, you need to sign a new certificate using your private key and the CA (and consider increasing the number of days)</p>

<p>If your tiller certificate has expired, you&rsquo;ll need to sign a new certificate, base64 encode it and update the Tiller Secret:
<code>kubectl edit secret tiller-secret</code></p>

<h2 id="references">References</h2>

<p><a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
<a href="https://www.openssl.org/docs/">https://www.openssl.org/docs/</a>
<a href="https://jamielinux.com/docs/openssl-certificate-authority/sign-server-and-client-certificates.html">https://jamielinux.com/docs/openssl-certificate-authority/sign-server-and-client-certificates.html</a></p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="using-helm">Using Helm</h1>

<p>This guide explains the basics of using Helm (and Tiller) to manage
packages on your Kubernetes cluster. It assumes that you have already
<a href="../using_helm/#installing-helm">installed</a> the Helm client and the Tiller server (typically by <code>helm
init</code>).</p>

<p>If you are simply interested in running a few quick commands, you may
wish to begin with the <a href="./#quickstart">Quickstart Guide</a>. This chapter
covers the particulars of Helm commands, and explains how to use Helm.</p>

<h2 id="three-big-concepts">Three Big Concepts</h2>

<p>A <em>Chart</em> is a Helm package. It contains all of the resource definitions
necessary to run an application, tool, or service inside of a Kubernetes
cluster. Think of it like the Kubernetes equivalent of a Homebrew formula,
an Apt dpkg, or a Yum RPM file.</p>

<p>A <em>Repository</em> is the place where charts can be collected and shared.
It&rsquo;s like Perl&rsquo;s <a href="http://www.cpan.org">CPAN archive</a> or the
<a href="https://admin.fedoraproject.org/pkgdb/">Fedora Package Database</a>, but for
Kubernetes packages.</p>

<p>A <em>Release</em> is an instance of a chart running in a Kubernetes cluster.
One chart can often be installed many times into the same cluster. And
each time it is installed, a new <em>release</em> is created. Consider a MySQL
chart. If you want two databases running in your cluster, you can
install that chart twice. Each one will have its own <em>release</em>, which
will in turn have its own <em>release name</em>.</p>

<p>With these concepts in mind, we can now explain Helm like this:</p>

<p>Helm installs <em>charts</em> into Kubernetes, creating a new <em>release</em> for
each installation. And to find new charts, you can search Helm chart
<em>repositories</em>.</p>

<h2 id="helm-search-finding-charts">&lsquo;helm search&rsquo;: Finding Charts</h2>

<p>When you first install Helm, it is preconfigured to talk to the official
Kubernetes charts repository. This repository contains a number of
carefully curated and maintained charts. This chart repository is named
<code>stable</code> by default.</p>

<p>You can see which charts are available by running <code>helm search</code>:</p>

<pre><code class="language-console">$ helm search
NAME                 	VERSION 	DESCRIPTION
stable/drupal   	0.3.2   	One of the most versatile open source content m...
stable/jenkins  	0.1.0   	A Jenkins Helm chart for Kubernetes.
stable/mariadb  	0.5.1   	Chart for MariaDB
stable/mysql    	0.1.0   	Chart for MySQL
...
</code></pre>

<p>With no filter, <code>helm search</code> shows you all of the available charts. You
can narrow down your results by searching with a filter:</p>

<pre><code class="language-console">$ helm search mysql
NAME               	VERSION	DESCRIPTION
stable/mysql  	0.1.0  	Chart for MySQL
stable/mariadb	0.5.1  	Chart for MariaDB
</code></pre>

<p>Now you will only see the results that match your filter.</p>

<p>Why is
<code>mariadb</code> in the list? Because its package description relates it to
MySQL. We can use <code>helm inspect chart</code> to see this:</p>

<pre><code class="language-console">$ helm inspect stable/mariadb
Fetched stable/mariadb to mariadb-0.5.1.tgz
description: Chart for MariaDB
engine: gotpl
home: https://mariadb.org
keywords:
- mariadb
- mysql
- database
- sql
...
</code></pre>

<p>Search is a good way to find available packages. Once you have found a
package you want to install, you can use <code>helm install</code> to install it.</p>

<h2 id="helm-install-installing-a-package">&lsquo;helm install&rsquo;: Installing a Package</h2>

<p>To install a new package, use the <code>helm install</code> command. At its
simplest, it takes only one argument: The name of the chart.</p>

<pre><code class="language-console">$ helm install stable/mariadb
Fetched stable/mariadb-0.3.0 to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
NAME: happy-panda
LAST DEPLOYED: Wed Sep 28 12:32:28 2016
NAMESPACE: default
STATUS: DEPLOYED

Resources:
==&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   1         0         0            0           1s

==&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    2         1s

==&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   1s


Notes:
MariaDB can be accessed via port 3306 on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre>

<p>Now the <code>mariadb</code> chart is installed. Note that installing a chart
creates a new <em>release</em> object. The release above is named
<code>happy-panda</code>. (If you want to use your own release name, simply use the
<code>--name</code> flag on <code>helm install</code>.)</p>

<p>During installation, the <code>helm</code> client will print useful information
about which resources were created, what the state of the release is,
and also whether there are additional configuration steps you can or
should take.</p>

<p>Helm does not wait until all of the resources are running before it
exits. Many charts require Docker images that are over 600M in size, and
may take a long time to install into the cluster.</p>

<p>To keep track of a release&rsquo;s state, or to re-read configuration
information, you can use <code>helm status</code>:</p>

<pre><code class="language-console">$ helm status happy-panda
Last Deployed: Wed Sep 28 12:32:28 2016
Namespace: default
Status: DEPLOYED

Resources:
==&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   4m

==&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   1         1         1            1           4m

==&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    2         4m


Notes:
MariaDB can be accessed via port 3306 on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre>

<p>The above shows the current state of your release.</p>

<h3 id="customizing-the-chart-before-installing">Customizing the Chart Before Installing</h3>

<p>Installing the way we have here will only use the default configuration
options for this chart. Many times, you will want to customize the chart
to use your preferred configuration.</p>

<p>To see what options are configurable on a chart, use <code>helm inspect
values</code>:</p>

<pre><code class="language-console">helm inspect values stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
## Bitnami MariaDB image version
## ref: https://hub.docker.com/r/bitnami/mariadb/tags/
##
## Default: none
imageTag: 10.1.14-r3

## Specify a imagePullPolicy
## Default to 'Always' if imageTag is 'latest', else set to 'IfNotPresent'
## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
##
# imagePullPolicy:

## Specify password for root user
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#setting-the-root-password-on-first-run
##
# mariadbRootPassword:

## Create a database user
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-user-on-first-run
##
# mariadbUser:
# mariadbPassword:

## Create a database
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-on-first-run
##
# mariadbDatabase:
</code></pre>

<p>You can then override any of these settings in a YAML formatted file,
and then pass that file during installation.</p>

<pre><code class="language-console">$ echo '{mariadbUser: user0, mariadbDatabase: user0db}' &gt; config.yaml
$ helm install -f config.yaml stable/mariadb
</code></pre>

<p>The above will create a default MariaDB user with the name <code>user0</code>, and
grant this user access to a newly created <code>user0db</code> database, but will
accept all the rest of the defaults for that chart.</p>

<p>There are two ways to pass configuration data during install:</p>

<ul>
<li><code>--values</code> (or <code>-f</code>): Specify a YAML file with overrides. This can be specified multiple times
and the rightmost file will take precedence</li>
<li><code>--set</code> (and its variants <code>--set-string</code> and <code>--set-file</code>): Specify overrides on the command line.</li>
</ul>

<p>If both are used, <code>--set</code> values are merged into <code>--values</code> with higher precedence.
Overrides specified with <code>--set</code> are persisted in a configmap. Values that have been
<code>--set</code> can be viewed for a given release with <code>helm get values &lt;release-name&gt;</code>.
Values that have been <code>--set</code> can be cleared by running <code>helm upgrade</code> with <code>--reset-values</code>
specified.</p>

<h4 id="the-format-and-limitations-of-set">The Format and Limitations of <code>--set</code></h4>

<p>The <code>--set</code> option takes zero or more name/value pairs. At its simplest, it is
used like this: <code>--set name=value</code>. The YAML equivalent of that is:</p>

<pre><code class="language-yaml">name: value
</code></pre>

<p>Multiple values are separated by <code>,</code> characters. So <code>--set a=b,c=d</code> becomes:</p>

<pre><code class="language-yaml">a: b
c: d
</code></pre>

<p>More complex expressions are supported. For example, <code>--set outer.inner=value</code> is
translated into this:</p>

<pre><code class="language-yaml">outer:
  inner: value
</code></pre>

<p>Lists can be expressed by enclosing values in <code>{</code> and <code>}</code>. For example,
<code>--set name={a, b, c}</code> translates to:</p>

<pre><code class="language-yaml">name:
  - a
  - b
  - c
</code></pre>

<p>As of Helm 2.5.0, it is possible to access list items using an array index syntax.
For example, <code>--set servers[0].port=80</code> becomes:</p>

<pre><code class="language-yaml">servers:
  - port: 80
</code></pre>

<p>Multiple values can be set this way. The line <code>--set servers[0].port=80,servers[0].host=example</code> becomes:</p>

<pre><code class="language-yaml">servers:
  - port: 80
    host: example
</code></pre>

<p>Sometimes you need to use special characters in your <code>--set</code> lines. You can use
a backslash to escape the characters; <code>--set name=&quot;value1\,value2&quot;</code> will become:</p>

<pre><code class="language-yaml">name: &quot;value1,value2&quot;
</code></pre>

<p>Similarly, you can escape dot sequences as well, which may come in handy when charts use the
<code>toYaml</code> function to parse annotations, labels and node selectors. The syntax for
<code>--set nodeSelector.&quot;kubernetes\.io/role&quot;=master</code> becomes:</p>

<pre><code class="language-yaml">nodeSelector:
  kubernetes.io/role: master
</code></pre>

<p>Deeply nested data structures can be difficult to express using <code>--set</code>. Chart
designers are encouraged to consider the <code>--set</code> usage when designing the format
of a <code>values.yaml</code> file.</p>

<p>Helm will cast certain values specified with <code>--set</code> to integers.
For example, <code>--set foo=true</code> results Helm to cast <code>true</code> into an int64 value.
In case you want a string, use a <code>--set</code>&rsquo;s variant named <code>--set-string</code>. <code>--set-string foo=true</code> results in a string value of <code>&quot;true&quot;</code>.</p>

<p><code>--set-file key=filepath</code> is another variant of <code>--set</code>.
It reads the file and use its content as a value.
An example use case of it is to inject a multi-line text into values without dealing with indentation in YAML.
Say you want to create a <a href="https://github.com/Azure/brigade">brigade</a> project with certain value containing 5 lines JavaScript code, you might write a <code>values.yaml</code> like:</p>

<pre><code class="language-yaml">defaultScript: |
  const { events, Job } = require(&quot;brigadier&quot;)
  function run(e, project) {
    console.log(&quot;hello default script&quot;)
  }
  events.on(&quot;run&quot;, run)
</code></pre>

<p>Being embedded in a YAML, this makes it harder for you to use IDE features and testing framework and so on that supports writing code.
Instead, you can use <code>--set-file defaultScript=brigade.js</code> with <code>brigade.js</code> containing:</p>

<pre><code class="language-javascript">const { events, Job } = require(&quot;brigadier&quot;)
function run(e, project) {
  console.log(&quot;hello default script&quot;)
}
events.on(&quot;run&quot;, run)
</code></pre>

<h3 id="more-installation-methods">More Installation Methods</h3>

<p>The <code>helm install</code> command can install from several sources:</p>

<ul>
<li>A chart repository (as we&rsquo;ve seen above)</li>
<li>A local chart archive (<code>helm install foo-0.1.1.tgz</code>)</li>
<li>An unpacked chart directory (<code>helm install path/to/foo</code>)</li>
<li>A full URL (<code>helm install https://example.com/charts/foo-1.2.3.tgz</code>)</li>
</ul>

<h2 id="helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure">&lsquo;helm upgrade&rsquo; and &lsquo;helm rollback&rsquo;: Upgrading a Release, and Recovering on Failure</h2>

<p>When a new version of a chart is released, or when you want to change
the configuration of your release, you can use the <code>helm upgrade</code>
command.</p>

<p>An upgrade takes an existing release and upgrades it according to the
information you provide. Because Kubernetes charts can be large and
complex, Helm tries to perform the least invasive upgrade. It will only
update things that have changed since the last release.</p>

<pre><code class="language-console">$ helm upgrade -f panda.yaml happy-panda stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
happy-panda has been upgraded. Happy Helming!
Last Deployed: Wed Sep 28 12:47:54 2016
Namespace: default
Status: DEPLOYED
...
</code></pre>

<p>In the above case, the <code>happy-panda</code> release is upgraded with the same
chart, but with a new YAML file:</p>

<pre><code class="language-yaml">mariadbUser: user1
</code></pre>

<p>We can use <code>helm get values</code> to see whether that new setting took
effect.</p>

<pre><code class="language-console">$ helm get values happy-panda
mariadbUser: user1
</code></pre>

<p>The <code>helm get</code> command is a useful tool for looking at a release in the
cluster. And as we can see above, it shows that our new values from
<code>panda.yaml</code> were deployed to the cluster.</p>

<p>Now, if something does not go as planned during a release, it is easy to
roll back to a previous release using <code>helm rollback [RELEASE] [REVISION]</code>.</p>

<pre><code class="language-console">$ helm rollback happy-panda 1
</code></pre>

<p>The above rolls back our happy-panda to its very first release version.
A release version is an incremental revision. Every time an install,
upgrade, or rollback happens, the revision number is incremented by 1.
The first revision number is always 1. And we can use <code>helm history [RELEASE]</code>
to see revision numbers for a certain release.</p>

<h2 id="helpful-options-for-install-upgrade-rollback">Helpful Options for Install/Upgrade/Rollback</h2>

<p>There are several other helpful options you can specify for customizing the
behavior of Helm during an install/upgrade/rollback. Please note that this
is not a full list of cli flags. To see a description of all flags, just run
<code>helm &lt;command&gt; --help</code>.</p>

<ul>
<li><code>--timeout</code>: A value in seconds to wait for Kubernetes commands to complete
This defaults to 300 (5 minutes)</li>
<li><code>--wait</code>: Waits until all Pods are in a ready state, PVCs are bound, Deployments
have minimum (<code>Desired</code> minus <code>maxUnavailable</code>) Pods in ready state and
Services have an IP address (and Ingress if a <code>LoadBalancer</code>) before
marking the release as successful. It will wait for as long as the
<code>--timeout</code> value. If timeout is reached, the release will be marked as
<code>FAILED</code>. Note: In scenario where Deployment has <code>replicas</code> set to 1 and
<code>maxUnavailable</code> is not set to 0 as part of rolling update strategy,
<code>--wait</code> will return as ready as it has satisfied the minimum Pod in ready condition.</li>
<li><code>--no-hooks</code>: This skips running hooks for the command</li>
<li><code>--recreate-pods</code> (only available for <code>upgrade</code> and <code>rollback</code>): This flag
will cause all pods to be recreated (with the exception of pods belonging to
deployments)</li>
</ul>

<h2 id="helm-delete-deleting-a-release">&lsquo;helm delete&rsquo;: Deleting a Release</h2>

<p>When it is time to uninstall or delete a release from the cluster, use
the <code>helm delete</code> command:</p>

<pre><code class="language-console">$ helm delete happy-panda
</code></pre>

<p>This will remove the release from the cluster. You can see all of your
currently deployed releases with the <code>helm list</code> command:</p>

<pre><code class="language-console">$ helm list
NAME           	VERSION	UPDATED                        	STATUS         	CHART
inky-cat       	1      	Wed Sep 28 12:59:46 2016       	DEPLOYED       	alpine-0.1.0
</code></pre>

<p>From the output above, we can see that the <code>happy-panda</code> release was
deleted.</p>

<p>However, Helm always keeps records of what releases happened. Need to
see the deleted releases? <code>helm list --deleted</code> shows those, and <code>helm
list --all</code> shows all of the releases (deleted and currently deployed,
as well as releases that failed):</p>

<pre><code class="language-console">⇒  helm list --all
NAME           	VERSION	UPDATED                        	STATUS         	CHART
happy-panda   	2      	Wed Sep 28 12:47:54 2016       	DELETED        	mariadb-0.3.0
inky-cat       	1      	Wed Sep 28 12:59:46 2016       	DEPLOYED       	alpine-0.1.0
kindred-angelf 	2      	Tue Sep 27 16:16:10 2016       	DELETED        	alpine-0.1.0
</code></pre>

<p>Because Helm keeps records of deleted releases, a release name cannot be
re-used. (If you <em>really</em> need to re-use a release name, you can use the
<code>--replace</code> flag, but it will simply re-use the existing release and
replace its resources.)</p>

<p>Note that because releases are preserved in this way, you can rollback a
deleted resource, and have it re-activate.</p>

<h2 id="helm-repo-working-with-repositories">&lsquo;helm repo&rsquo;: Working with Repositories</h2>

<p>So far, we&rsquo;ve been installing charts only from the <code>stable</code> repository.
But you can configure <code>helm</code> to use other repositories. Helm provides
several repository tools under the <code>helm repo</code> command.</p>

<p>You can see which repositories are configured using <code>helm repo list</code>:</p>

<pre><code class="language-console">$ helm repo list
NAME           	URL
stable         	https://kubernetes-charts.storage.googleapis.com
local          	http://localhost:8879/charts
mumoshu        	https://mumoshu.github.io/charts
</code></pre>

<p>And new repositories can be added with <code>helm repo add</code>:</p>

<pre><code class="language-console">$ helm repo add dev https://example.com/dev-charts
</code></pre>

<p>Because chart repositories change frequently, at any point you can make
sure your Helm client is up to date by running <code>helm repo update</code>.</p>

<h2 id="creating-your-own-charts">Creating Your Own Charts</h2>

<p>The <a href="./#charts">Chart Development Guide</a> explains how to develop your own
charts. But you can get started quickly by using the <code>helm create</code>
command:</p>

<pre><code class="language-console">$ helm create deis-workflow
Creating deis-workflow
</code></pre>

<p>Now there is a chart in <code>./deis-workflow</code>. You can edit it and create
your own templates.</p>

<p>As you edit your chart, you can validate that it is well-formatted by
running <code>helm lint</code>.</p>

<p>When it&rsquo;s time to package the chart up for distribution, you can run the
<code>helm package</code> command:</p>

<pre><code class="language-console">$ helm package deis-workflow
deis-workflow-0.1.0.tgz
</code></pre>

<p>And that chart can now easily be installed by <code>helm install</code>:</p>

<pre><code class="language-console">$ helm install ./deis-workflow-0.1.0.tgz
...
</code></pre>

<p>Charts that are archived can be loaded into chart repositories. See the
documentation for your chart repository server to learn how to upload.</p>

<p>Note: The <code>stable</code> repository is managed on the <a href="https://github.com/helm/charts">Helm Charts
GitHub repository</a>. That project
accepts chart source code, and (after audit) packages those for you.</p>

<h2 id="tiller-namespaces-and-rbac">Tiller, Namespaces and RBAC</h2>

<p>In some cases you may wish to scope Tiller or deploy multiple Tillers to a single cluster. Here are some best practices when operating in those circumstances.</p>

<ol>
<li>Tiller can be <a href="./#install">installed</a> into any namespace. By default, it is installed into kube-system. You can run multiple Tillers provided they each run in their own namespace.</li>
<li>Limiting Tiller to only be able to install into specific namespaces and/or resource types is controlled by Kubernetes <a href="./#https://kubernetes.io/docs/admin/authorization/rbac/">RBAC</a> roles and rolebindings. You can add a service account to Tiller when configuring Helm via <code>helm init --service-account &lt;NAME&gt;</code>. You can find more information about that <a href="rbac">here</a>.</li>
<li>Release names are unique PER TILLER INSTANCE.</li>
<li>Charts should only contain resources that exist in a single namespace.</li>
<li>It is not recommended to have multiple Tillers configured to manage resources in the same namespace.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>This chapter has covered the basic usage patterns of the <code>helm</code> client,
including searching, installation, upgrading, and deleting. It has also
covered useful utility commands like <code>helm status</code>, <code>helm get</code>, and
<code>helm repo</code>.</p>

<p>For more information on these commands, take a look at Helm&rsquo;s built-in
help: <code>helm help</code>.</p>

<p>In the next chapter, we look at the process of developing charts.</p>
</div>
</article>
          
            <article id="">
  <div>

<h1 id="quickstart-guide">Quickstart Guide</h1>

<p>This guide covers how you can quickly get started using Helm.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>The following prerequisites are required for a successful and properly secured use of Helm.</p>

<ol>
<li>A Kubernetes cluster</li>
<li>Deciding what security configurations to apply to your installation, if any</li>
<li>Installing and configuring Helm and Tiller, the cluster-side service.</li>
</ol>

<h3 id="install-kubernetes-or-have-access-to-a-cluster">Install Kubernetes or have access to a cluster</h3>

<ul>
<li>You must have Kubernetes installed. For the latest release of Helm, we recommend the latest stable release of Kubernetes, which in most cases is the second-latest minor release.</li>
<li>You should also have a local configured copy of <code>kubectl</code>.</li>
</ul>

<p>NOTE: Kubernetes versions prior to 1.6 have limited or no support for role-based access controls (RBAC).</p>

<p>Helm will figure out where to install Tiller by reading your Kubernetes
configuration file (usually <code>$HOME/.kube/config</code>). This is the same file
that <code>kubectl</code> uses.</p>

<p>To find out which cluster Tiller would install to, you can run
<code>kubectl config current-context</code> or <code>kubectl cluster-info</code>.</p>

<pre><code class="language-console">$ kubectl config current-context
my-cluster
</code></pre>

<h3 id="understand-your-security-context">Understand your Security Context</h3>

<p>As with all powerful tools, ensure you are installing it correctly for your scenario.</p>

<p>If you&rsquo;re using Helm on a cluster that you completely control, like minikube or a cluster on a private network in which sharing is not a concern, the default installation &ndash; which applies no security configuration &ndash; is fine, and it&rsquo;s definitely the easiest. To install Helm without additional security steps, <a href="#installing-helm">install Helm</a> and then <a href="#initialize-helm-and-install-tiller">initialize Helm</a>.</p>

<p>However, if your cluster is exposed to a larger network or if you share your cluster with others &ndash; production clusters fall into this category &ndash; you must take extra steps to secure your installation to prevent careless or malicious actors from damaging the cluster or its data. To apply configurations that secure Helm for use in production environments and other multi-tenant scenarios, see <a href="./#securing-your-helm-installation">Securing a Helm installation</a></p>

<p>If your cluster has Role-Based Access Control (RBAC) enabled, you may want
to <a href="./#role-based-access-control">configure a service account and rules</a> before proceeding.</p>

<h2 id="install-helm">Install Helm</h2>

<p>Download a binary release of the Helm client. You can use tools like
<code>homebrew</code>, or look at <a href="https://github.com/helm/helm/releases">the official releases page</a>.</p>

<p>For more details, or for other options, see <a href="../using_helm/#installing-helm">the installation
guide</a>.</p>

<h2 id="initialize-helm-and-install-tiller">Initialize Helm and Install Tiller</h2>

<p>Once you have Helm ready, you can initialize the local CLI and also
install Tiller into your Kubernetes cluster in one step:</p>

<pre><code class="language-console">$ helm init
</code></pre>

<p>This will install Tiller into the Kubernetes cluster you saw with
<code>kubectl config current-context</code>.</p>

<p><strong>TIP:</strong> Want to install into a different cluster? Use the
<code>--kube-context</code> flag.</p>

<p><strong>TIP:</strong> When you want to upgrade Tiller, just run <code>helm init --upgrade</code>.</p>

<p>By default, when Tiller is installed, it does not have authentication enabled.
To learn more about configuring strong TLS authentication for Tiller, consult
<a href="./#using-ssl-between-helm-and-tiller">the Tiller TLS guide</a>.</p>

<h2 id="install-an-example-chart">Install an Example Chart</h2>

<p>To install a chart, you can run the <code>helm install</code> command. Helm has
several ways to find and install a chart, but the easiest is to use one
of the official <code>stable</code> charts.</p>

<pre><code class="language-console">$ helm repo update              # Make sure we get the latest list of charts
$ helm install stable/mysql
NAME:   wintering-rodent
LAST DEPLOYED: Thu Oct 18 14:21:18 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/Secret
NAME                    AGE
wintering-rodent-mysql  0s

==&gt; v1/ConfigMap
wintering-rodent-mysql-test  0s

==&gt; v1/PersistentVolumeClaim
wintering-rodent-mysql  0s

==&gt; v1/Service
wintering-rodent-mysql  0s

==&gt; v1beta1/Deployment
wintering-rodent-mysql  0s

==&gt; v1/Pod(related)

NAME                                    READY  STATUS   RESTARTS  AGE
wintering-rodent-mysql-6986fd6fb-988x7  0/1    Pending  0         0s


NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
wintering-rodent-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default wintering-rodent-mysql -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update &amp;&amp; apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h wintering-rodent-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/wintering-rodent-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}

</code></pre>

<p>In the example above, the <code>stable/mysql</code> chart was released, and the name of
our new release is <code>wintering-rodent</code>. You get a simple idea of the
features of this MySQL chart by running <code>helm inspect stable/mysql</code>.</p>

<p>Whenever you install a chart, a new release is created. So one chart can
be installed multiple times into the same cluster. And each can be
independently managed and upgraded.</p>

<p>The <code>helm install</code> command is a very powerful command with many
capabilities. To learn more about it, check out the <a href="./#using_helm">Using Helm
Guide</a></p>

<h2 id="learn-about-releases">Learn About Releases</h2>

<p>It&rsquo;s easy to see what has been released using Helm:</p>

<pre><code class="language-console">$ helm ls
NAME            	REVISION	UPDATED                 	STATUS  	CHART       	APP VERSION	NAMESPACE
wintering-rodent	1       	Thu Oct 18 15:06:58 2018	DEPLOYED	mysql-0.10.1	5.7.14     	default
</code></pre>

<p>The <code>helm list</code> function will show you a list of all deployed releases.</p>

<h2 id="uninstall-a-release">Uninstall a Release</h2>

<p>To uninstall a release, use the <code>helm delete</code> command:</p>

<pre><code class="language-console">$ helm delete wintering-rodent
release &quot;wintering-rodent&quot; deleted
</code></pre>

<p>This will uninstall <code>wintering-rodent</code> from Kubernetes, but you will
still be able to request information about that release:</p>

<pre><code class="language-console">$ helm status wintering-rodent
LAST DEPLOYED: Thu Oct 18 14:21:18 2018
NAMESPACE: default
STATUS: DELETED

NOTES:
MySQL can be accessed via port 3306 on the following DNS name from within your cluster:
wintering-rodent-mysql.default.svc.cluster.local

To get your root password run:

    MYSQL_ROOT_PASSWORD=$(kubectl get secret --namespace default wintering-rodent-mysql -o jsonpath=&quot;{.data.mysql-root-password}&quot; | base64 --decode; echo)

To connect to your database:

1. Run an Ubuntu pod that you can use as a client:

    kubectl run -i --tty ubuntu --image=ubuntu:16.04 --restart=Never -- bash -il

2. Install the mysql client:

    $ apt-get update &amp;&amp; apt-get install mysql-client -y

3. Connect using the mysql cli, then provide your password:
    $ mysql -h wintering-rodent-mysql -p

To connect to your database directly from outside the K8s cluster:
    MYSQL_HOST=127.0.0.1
    MYSQL_PORT=3306

    # Execute the following command to route the connection:
    kubectl port-forward svc/wintering-rodent-mysql 3306

    mysql -h ${MYSQL_HOST} -P${MYSQL_PORT} -u root -p${MYSQL_ROOT_PASSWORD}
</code></pre>

<p>Because Helm tracks your releases even after you&rsquo;ve deleted them, you
can audit a cluster&rsquo;s history, and even undelete a release (with <code>helm
rollback</code>).</p>

<h2 id="reading-the-help-text">Reading the Help Text</h2>

<p>To learn more about the available Helm commands, use <code>helm help</code> or type
a command followed by the <code>-h</code> flag:</p>

<pre><code class="language-console">$ helm get -h
</code></pre>

<h1 id="installing-helm">Installing Helm</h1>

<p>There are two parts to Helm: The Helm client (<code>helm</code>) and the Helm
server (Tiller). This guide shows how to install the client, and then
proceeds to show two ways to install the server.</p>

<p><strong>IMPORTANT</strong>: If you are responsible for ensuring your cluster is a controlled environment, especially when resources are shared, it is strongly recommended installing Tiller using a secured configuration. For guidance, see <a href="./#securing-your-helm-installation">Securing your Helm Installation</a>.</p>

<h2 id="installing-the-helm-client">Installing the Helm Client</h2>

<p>The Helm client can be installed either from source, or from pre-built binary
releases.</p>

<h3 id="from-the-binary-releases">From the Binary Releases</h3>

<p>Every <a href="https://github.com/helm/helm/releases">release</a> of Helm
provides binary releases for a variety of OSes. These binary versions
can be manually downloaded and installed.</p>

<ol>
<li>Download your <a href="https://github.com/helm/helm/releases">desired version</a></li>
<li>Unpack it (<code>tar -zxvf helm-v2.0.0-linux-amd64.tgz</code>)</li>
<li>Find the <code>helm</code> binary in the unpacked directory, and move it to its
desired destination (<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li>
</ol>

<p>From there, you should be able to run the client: <code>helm help</code>.</p>

<h3 id="from-snap-linux">From Snap (Linux)</h3>

<p>The Snap package for Helm is maintained by
<a href="https://github.com/snapcrafters/helm">Snapcrafters</a>.</p>

<pre><code>$ sudo snap install helm --classic
</code></pre>

<h3 id="from-homebrew-macos">From Homebrew (macOS)</h3>

<p>Members of the Kubernetes community have contributed a Helm formula build to
Homebrew. This formula is generally up to date.</p>

<pre><code>brew install kubernetes-helm
</code></pre>

<p>(Note: There is also a formula for emacs-helm, which is a different
project.)</p>

<h3 id="from-chocolatey-windows">From Chocolatey (Windows)</h3>

<p>Members of the Kubernetes community have contributed a <a href="https://chocolatey.org/packages/kubernetes-helm">Helm package</a> build to
<a href="https://chocolatey.org/">Chocolatey</a>. This package is generally up to date.</p>

<pre><code>choco install kubernetes-helm
</code></pre>

<h2 id="from-script">From Script</h2>

<p>Helm now has an installer script that will automatically grab the latest version
of the Helm client and <a href="https://raw.githubusercontent.com/helm/helm/master/scripts/get">install it locally</a>.</p>

<p>You can fetch that script, and then execute it locally. It&rsquo;s well documented so
that you can read through it and understand what it is doing before you run it.</p>

<pre><code>$ curl https://raw.githubusercontent.com/helm/helm/master/scripts/get &gt; get_helm.sh
$ chmod 700 get_helm.sh
$ ./get_helm.sh
</code></pre>

<p>Yes, you can <code>curl https://raw.githubusercontent.com/helm/helm/master/scripts/get | bash</code> that if you want to live on the edge.</p>

<h3 id="from-canary-builds">From Canary Builds</h3>

<p>&ldquo;Canary&rdquo; builds are versions of the Helm software that are built from
the latest master branch. They are not official releases, and may not be
stable. However, they offer the opportunity to test the cutting edge
features.</p>

<p>Canary Helm binaries are stored in the <a href="https://kubernetes-helm.storage.googleapis.com">Kubernetes Helm GCS bucket</a>.
Here are links to the common builds:</p>

<ul>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-linux-amd64.tar.gz">Linux AMD64</a></li>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-darwin-amd64.tar.gz">macOS AMD64</a></li>
<li><a href="https://kubernetes-helm.storage.googleapis.com/helm-canary-windows-amd64.zip">Experimental Windows AMD64</a></li>
</ul>

<h3 id="from-source-linux-macos">From Source (Linux, macOS)</h3>

<p>Building Helm from source is slightly more work, but is the best way to
go if you want to test the latest (pre-release) Helm version.</p>

<p>You must have a working Go environment with
<a href="https://github.com/Masterminds/glide">glide</a> installed.</p>

<pre><code class="language-console">$ cd $GOPATH
$ mkdir -p src/k8s.io
$ cd src/k8s.io
$ git clone https://github.com/helm/helm.git
$ cd helm
$ make bootstrap build
</code></pre>

<p>The <code>bootstrap</code> target will attempt to install dependencies, rebuild the
<code>vendor/</code> tree, and validate configuration.</p>

<p>The <code>build</code> target will compile <code>helm</code> and place it in <code>bin/helm</code>.
Tiller is also compiled, and is placed in <code>bin/tiller</code>.</p>

<h2 id="installing-tiller">Installing Tiller</h2>

<p>Tiller, the server portion of Helm, typically runs inside of your
Kubernetes cluster. But for development, it can also be run locally, and
configured to talk to a remote Kubernetes cluster.</p>

<h3 id="special-note-for-rbac-users">Special Note for RBAC Users</h3>

<p>Most cloud providers enable a feature called Role-Based Access Control - RBAC for short. If your cloud provider enables this feature, you will need to create a service account for Tiller with the right roles and permissions to access resources.</p>

<p>Check the <a href="./#kubernetes_distros.md">Kubernetes Distribution Guide</a> to see if there&rsquo;s any further points of interest on using Helm with your cloud provider. Also check out the guide on <a href="rbac">Tiller and Role-Based Access Control</a> for more information on how to run Tiller in an RBAC-enabled Kubernetes cluster.</p>

<h3 id="easy-in-cluster-installation">Easy In-Cluster Installation</h3>

<p>The easiest way to install <code>tiller</code> into the cluster is simply to run
<code>helm init</code>. This will validate that <code>helm</code>&rsquo;s local environment is set
up correctly (and set it up if necessary). Then it will connect to
whatever cluster <code>kubectl</code> connects to by default (<code>kubectl config
view</code>). Once it connects, it will install <code>tiller</code> into the
<code>kube-system</code> namespace.</p>

<p>After <code>helm init</code>, you should be able to run <code>kubectl get pods --namespace
kube-system</code> and see Tiller running.</p>

<p>You can explicitly tell <code>helm init</code> to&hellip;</p>

<ul>
<li>Install the canary build with the <code>--canary-image</code> flag</li>
<li>Install a particular image (version) with <code>--tiller-image</code></li>
<li>Install to a particular cluster with <code>--kube-context</code></li>
<li>Install into a particular namespace with <code>--tiller-namespace</code></li>
<li>Install Tiller with a Service Account with <code>--service-account</code> (for <a href="securing-your-helm-installation.md#role-based-access-control">RBAC enabled clusters</a>)</li>
<li>Install Tiller without mounting a service account with <code>--automount-service-account false</code></li>
</ul>

<p>Once Tiller is installed, running <code>helm version</code> should show you both
the client and server version. (If it shows only the client version,
<code>helm</code> cannot yet connect to the server. Use <code>kubectl</code> to see if any
<code>tiller</code> pods are running.)</p>

<p>Helm will look for Tiller in the <code>kube-system</code> namespace unless
<code>--tiller-namespace</code> or <code>TILLER_NAMESPACE</code> is set.</p>

<h3 id="installing-tiller-canary-builds">Installing Tiller Canary Builds</h3>

<p>Canary images are built from the <code>master</code> branch. They may not be
stable, but they offer you the chance to test out the latest features.</p>

<p>The easiest way to install a canary image is to use <code>helm init</code> with the
<code>--canary-image</code> flag:</p>

<pre><code class="language-console">$ helm init --canary-image
</code></pre>

<p>This will use the most recently built container image. You can always
uninstall Tiller by deleting the Tiller deployment from the
<code>kube-system</code> namespace using <code>kubectl</code>.</p>

<h3 id="running-tiller-locally">Running Tiller Locally</h3>

<p>For development, it is sometimes easier to work on Tiller locally, and
configure it to connect to a remote Kubernetes cluster.</p>

<p>The process of building Tiller is explained above.</p>

<p>Once <code>tiller</code> has been built, simply start it:</p>

<pre><code class="language-console">$ bin/tiller
Tiller running on :44134
</code></pre>

<p>When Tiller is running locally, it will attempt to connect to the
Kubernetes cluster that is configured by <code>kubectl</code>. (Run <code>kubectl config
view</code> to see which cluster that is.)</p>

<p>You must tell <code>helm</code> to connect to this new local Tiller host instead of
connecting to the one in-cluster. There are two ways to do this. The
first is to specify the <code>--host</code> option on the command line. The second
is to set the <code>$HELM_HOST</code> environment variable.</p>

<pre><code class="language-console">$ export HELM_HOST=localhost:44134
$ helm version # Should connect to localhost.
Client: &amp;version.Version{SemVer:&quot;v2.0.0-alpha.4&quot;, GitCommit:&quot;db...&quot;, GitTreeState:&quot;dirty&quot;}
Server: &amp;version.Version{SemVer:&quot;v2.0.0-alpha.4&quot;, GitCommit:&quot;a5...&quot;, GitTreeState:&quot;dirty&quot;}
</code></pre>

<p>Importantly, even when running locally, Tiller will store release
configuration in ConfigMaps inside of Kubernetes.</p>

<h2 id="upgrading-tiller">Upgrading Tiller</h2>

<p>As of Helm 2.2.0, Tiller can be upgraded using <code>helm init --upgrade</code>.</p>

<p>For older versions of Helm, or for manual upgrades, you can use <code>kubectl</code> to modify
the Tiller image:</p>

<pre><code class="language-console">$ export TILLER_TAG=v2.0.0-beta.1        # Or whatever version you want
$ kubectl --namespace=kube-system set image deployments/tiller-deploy tiller=gcr.io/kubernetes-helm/tiller:$TILLER_TAG
deployment &quot;tiller-deploy&quot; image updated
</code></pre>

<p>Setting <code>TILLER_TAG=canary</code> will get the latest snapshot of master.</p>

<h2 id="deleting-or-reinstalling-tiller">Deleting or Reinstalling Tiller</h2>

<p>Because Tiller stores its data in Kubernetes ConfigMaps, you can safely
delete and re-install Tiller without worrying about losing any data. The
recommended way of deleting Tiller is with <code>kubectl delete deployment
tiller-deploy --namespace kube-system</code>, or more concisely <code>helm reset</code>.</p>

<p>Tiller can then be re-installed from the client with:</p>

<pre><code class="language-console">$ helm init
</code></pre>

<h2 id="advanced-usage">Advanced Usage</h2>

<p><code>helm init</code> provides additional flags for modifying Tiller&rsquo;s deployment
manifest before it is installed.</p>

<h3 id="using-node-selectors">Using <code>--node-selectors</code></h3>

<p>The <code>--node-selectors</code> flag allows us to specify the node labels required
for scheduling the Tiller pod.</p>

<p>The example below will create the specified label under the nodeSelector
property.</p>

<pre><code>helm init --node-selectors &quot;beta.kubernetes.io/os&quot;=&quot;linux&quot;
</code></pre>

<p>The installed deployment manifest will contain our node selector label.</p>

<pre><code>...
spec:
  template:
    spec:
      nodeSelector:
        beta.kubernetes.io/os: linux
...
</code></pre>

<h3 id="using-override">Using <code>--override</code></h3>

<p><code>--override</code> allows you to specify properties of Tiller&rsquo;s
deployment manifest. Unlike the <code>--set</code> command used elsewhere in Helm,
<code>helm init --override</code> manipulates the specified properties of the final
manifest (there is no &ldquo;values&rdquo; file). Therefore you may specify any valid
value for any valid property in the deployment manifest.</p>

<h4 id="override-annotation">Override annotation</h4>

<p>In the example below we use <code>--override</code> to add the revision property and set
its value to 1.</p>

<pre><code>helm init --override metadata.annotations.&quot;deployment\.kubernetes\.io/revision&quot;=&quot;1&quot;
</code></pre>

<p>Output:</p>

<pre><code>apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  annotations:
    deployment.kubernetes.io/revision: &quot;1&quot;
...
</code></pre>

<h4 id="override-affinity">Override affinity</h4>

<p>In the example below we set properties for node affinity. Multiple
<code>--override</code> commands may be combined to modify different properties of the
same list item.</p>

<pre><code>helm init --override &quot;spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].weight&quot;=&quot;1&quot; --override &quot;spec.template.spec.affinity.nodeAffinity.preferredDuringSchedulingIgnoredDuringExecution[0].preference.matchExpressions[0].key&quot;=&quot;e2e-az-name&quot;
</code></pre>

<p>The specified properties are combined into the
&ldquo;preferredDuringSchedulingIgnoredDuringExecution&rdquo; property&rsquo;s first
list item.</p>

<pre><code>...
spec:
  strategy: {}
  template:
    ...
    spec:
      affinity:
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - preference:
              matchExpressions:
              - key: e2e-az-name
                operator: &quot;&quot;
            weight: 1
...
</code></pre>

<h3 id="using-output">Using <code>--output</code></h3>

<p>The <code>--output</code> flag allows us skip the installation of Tiller&rsquo;s deployment
manifest and simply output the deployment manifest to stdout in either
JSON or YAML format. The output may then be modified with tools like <code>jq</code>
and installed manually with <code>kubectl</code>.</p>

<p>In the example below we execute <code>helm init</code> with the <code>--output json</code> flag.</p>

<pre><code>helm init --output json
</code></pre>

<p>The Tiller installation is skipped and the manifest is output to stdout
in JSON format.</p>

<pre><code>&quot;apiVersion&quot;: &quot;extensions/v1beta1&quot;,
&quot;kind&quot;: &quot;Deployment&quot;,
&quot;metadata&quot;: {
    &quot;creationTimestamp&quot;: null,
    &quot;labels&quot;: {
        &quot;app&quot;: &quot;helm&quot;,
        &quot;name&quot;: &quot;tiller&quot;
    },
    &quot;name&quot;: &quot;tiller-deploy&quot;,
    &quot;namespace&quot;: &quot;kube-system&quot;
},
...
</code></pre>

<h3 id="storage-backends">Storage backends</h3>

<p>By default, <code>tiller</code> stores release information in <code>ConfigMaps</code> in the namespace
where it is running. As of Helm 2.7.0, there is now a beta storage backend that
uses <code>Secrets</code> for storing release information. This was added for additional
security in protecting charts in conjunction with the release of <code>Secret</code>
encryption in Kubernetes.</p>

<p>To enable the secrets backend, you&rsquo;ll need to init Tiller with the following
options:</p>

<pre><code class="language-shell">helm init --override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}'
</code></pre>

<p>Currently, if you want to switch from the default backend to the secrets
backend, you&rsquo;ll have to do the migration for this on your own. When this backend
graduates from beta, there will be a more official path of migration</p>

<h2 id="conclusion">Conclusion</h2>

<p>In most cases, installation is as simple as getting a pre-built <code>helm</code> binary
and running <code>helm init</code>. This document covers additional cases for those
who want to do more sophisticated things with Helm.</p>

<p>Once you have the Helm Client and Tiller successfully installed, you can
move on to using Helm to manage charts.</p>

<h1 id="kubernetes-distribution-guide">Kubernetes Distribution Guide</h1>

<p>This document captures information about using Helm in specific Kubernetes
environments.</p>

<p>We are trying to add more details to this document. Please contribute via Pull
Requests if you can.</p>

<h2 id="minikube">MiniKube</h2>

<p>Helm is tested and known to work with <a href="https://github.com/kubernetes/minikube">minikube</a>.
It requires no additional configuration.</p>

<h2 id="scripts-local-cluster-and-hyperkube"><code>scripts/local-cluster</code> and Hyperkube</h2>

<p>Hyperkube configured via <code>scripts/local-cluster.sh</code> is known to work. For raw
Hyperkube you may need to do some manual configuration.</p>

<h2 id="gke">GKE</h2>

<p>Google&rsquo;s GKE hosted Kubernetes platform enables RBAC by default. You will need to create a service account for tiller, and use the &ndash;service-account flag when initializing the helm server.</p>

<p>See <a href="https://docs.helm.sh/using_helm/#role-based-access-control">Tiller and role-based access control</a> for more information.</p>

<h2 id="ubuntu-with-kubeadm">Ubuntu with &lsquo;kubeadm&rsquo;</h2>

<p>Kubernetes bootstrapped with <code>kubeadm</code> is known to work on the following Linux
distributions:</p>

<ul>
<li>Ubuntu 16.04</li>
<li>Fedora release 25</li>
</ul>

<p>Some versions of Helm (v2.0.0-beta2) require you to <code>export KUBECONFIG=/etc/kubernetes/admin.conf</code>
or create a <code>~/.kube/config</code>.</p>

<h2 id="container-linux-by-coreos">Container Linux by CoreOS</h2>

<p>Helm requires that kubelet have access to a copy of the <code>socat</code> program to proxy connections to the Tiller API. On Container Linux the Kubelet runs inside of a <a href="https://github.com/kubernetes/kubernetes/tree/master/cluster/images/hyperkube">hyperkube</a> container image that has socat. So, even though Container Linux doesn&rsquo;t ship <code>socat</code> the container filesystem running kubelet does have socat. To learn more read the <a href="https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html">Kubelet Wrapper</a> docs.</p>

<h2 id="openshift">Openshift</h2>

<p>Helm works straightforward on OpenShift Online, OpenShift Dedicated, OpenShift Container Platform (version &gt;= 3.6) or OpenShift Origin (version &gt;= 3.6). To learn more read <a href="https://blog.openshift.com/getting-started-helm-openshift/">this blog</a> post.</p>

<h2 id="platform9">Platform9</h2>

<p>Helm Client and Helm Server (Tiller) are pre-installed with <a href="https://platform9.com/managed-kubernetes/?utm_source=helm_distro_notes">Platform9 Managed Kubernetes</a>. Platform9 provides access to all official Helm charts through the App Catalog UI and native Kubernetes CLI. Additional repositories can be manually added. Further details are available in this <a href="https://platform9.com/support/deploying-kubernetes-apps-platform9-managed-kubernetes/?utm_source=helm_distro_notes">Platform9 App Catalog article</a>.</p>

<h2 id="dc-os">DC/OS</h2>

<p>Helm (both client and server) has been tested and is working on Mesospheres DC/OS 1.11 Kubernetes platform, and requires
no additional configuration.</p>

<h1 id="installation-frequently-asked-questions">Installation: Frequently Asked Questions</h1>

<p>This section tracks some of the more frequently encountered issues with installing
or getting started with Helm.</p>

<p><strong>We&rsquo;d love your help</strong> making this document better. To add, correct, or remove
information, <a href="https://github.com/helm/helm/issues">file an issue</a> or
send us a pull request.</p>

<h2 id="downloading">Downloading</h2>

<p>I want to know more about my downloading options.</p>

<p><strong>Q: I can&rsquo;t get to GitHub releases of the newest Helm. Where are they?</strong></p>

<p>A: We no longer use GitHub releases. Binaries are now stored in a
<a href="https://kubernetes-helm.storage.googleapis.com">GCS public bucket</a>.</p>

<p><strong>Q: Why aren&rsquo;t there Debian/Fedora/&hellip; native packages of Helm?</strong></p>

<p>We&rsquo;d love to provide these or point you toward a trusted provider. If you&rsquo;re
interested in helping, we&rsquo;d love it. This is how the Homebrew formula was
started.</p>

<p><strong>Q: Why do you provide a <code>curl ...|bash</code> script?</strong></p>

<p>A: There is a script in our repository (<code>scripts/get</code>) that can be executed as
a <code>curl ..|bash</code> script. The transfers are all protected by HTTPS, and the script
does some auditing of the packages it fetches. However, the script has all the
usual dangers of any shell script.</p>

<p>We provide it because it is useful, but we suggest that users carefully read the
script first. What we&rsquo;d really like, though, are better packaged releases of
Helm.</p>

<h2 id="installing">Installing</h2>

<p>I&rsquo;m trying to install Helm/Tiller, but something is not right.</p>

<p><strong>Q: How do I put the Helm client files somewhere other than ~/.helm?</strong></p>

<p>Set the <code>$HELM_HOME</code> environment variable, and then run <code>helm init</code>:</p>

<pre><code class="language-console">export HELM_HOME=/some/path
helm init --client-only
</code></pre>

<p>Note that if you have existing repositories, you will need to re-add them
with <code>helm repo add...</code>.</p>

<p><strong>Q: How do I configure Helm, but not install Tiller?</strong></p>

<p>A: By default, <code>helm init</code> will ensure that the local <code>$HELM_HOME</code> is configured,
and then install Tiller on your cluster. To locally configure, but not install
Tiller, use <code>helm init --client-only</code>.</p>

<p><strong>Q: How do I manually install Tiller on the cluster?</strong></p>

<p>A: Tiller is installed as a Kubernetes <code>deployment</code>. You can get the manifest
by running <code>helm init --dry-run --debug</code>, and then manually install it with
<code>kubectl</code>. It is suggested that you do not remove or change the labels on that
deployment, as they are sometimes used by supporting scripts and tools.</p>

<p><strong>Q: Why do I get <code>Error response from daemon: target is unknown</code> during Tiller install?</strong></p>

<p>A: Users have reported being unable to install Tiller on Kubernetes instances that
are using Docker 1.13.0. The root cause of this was a bug in Docker that made
that one version incompatible with images pushed to the Docker registry by
earlier versions of Docker.</p>

<p>This <a href="https://github.com/docker/docker/issues/30083">issue</a> was fixed shortly
after the release, and is available in Docker 1.13.1-RC1 and later.</p>

<h2 id="getting-started">Getting Started</h2>

<p>I successfully installed Helm/Tiller but I can&rsquo;t use it.</p>

<p><strong>Q: Trying to use Helm, I get the error &ldquo;client transport was broken&rdquo;</strong></p>

<pre><code>E1014 02:26:32.885226   16143 portforward.go:329] an error occurred forwarding 37008 -&gt; 44134: error forwarding port 44134 to pod tiller-deploy-2117266891-e4lev_kube-system, uid : unable to do port forwarding: socat not found.
2016/10/14 02:26:32 transport: http2Client.notifyError got notified that the client transport was broken EOF.
Error: transport is closing
</code></pre>

<p>A: This is usually a good indication that Kubernetes is not set up to allow port forwarding.</p>

<p>Typically, the missing piece is <code>socat</code>. If you are running CoreOS, we have been
told that it may have been misconfigured on installation. The CoreOS team
recommends reading this:</p>

<ul>
<li><a href="https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html">https://coreos.com/kubernetes/docs/latest/kubelet-wrapper.html</a></li>
</ul>

<p>Here are a few resolved issues that may help you get started:</p>

<ul>
<li><a href="https://github.com/helm/helm/issues/1371">https://github.com/helm/helm/issues/1371</a></li>
<li><a href="https://github.com/helm/helm/issues/966">https://github.com/helm/helm/issues/966</a></li>
</ul>

<p><strong>Q: Trying to use Helm, I get the error &ldquo;lookup XXXXX on 8.8.8.8:53: no such host&rdquo;</strong></p>

<pre><code>Error: Error forwarding ports: error upgrading connection: dial tcp: lookup kube-4gb-lon1-02 on 8.8.8.8:53: no such host
</code></pre>

<p>A: We have seen this issue with Ubuntu and Kubeadm in multi-node clusters. The
issue is that the nodes expect certain DNS records to be obtainable via global
DNS. Until this is resolved upstream, you can work around the issue as
follows. On each of the control plane nodes:</p>

<p>1) Add entries to <code>/etc/hosts</code>, mapping your hostnames to their public IPs
2) Install <code>dnsmasq</code> (e.g. <code>apt install -y dnsmasq</code>)
3) Remove the k8s api server container (kubelet will recreate it)
4) Then <code>systemctl restart docker</code> (or reboot the node) for it to pick up the /etc/resolv.conf changes</p>

<p>See this issue for more information: <a href="https://github.com/helm/helm/issues/1455">https://github.com/helm/helm/issues/1455</a></p>

<p><strong>Q: On GKE (Google Container Engine) I get &ldquo;No SSH tunnels currently open&rdquo;</strong></p>

<pre><code>Error: Error forwarding ports: error upgrading connection: No SSH tunnels currently open. Were the targets able to accept an ssh-key for user &quot;gke-[redacted]&quot;?
</code></pre>

<p>Another variation of the error message is:</p>

<pre><code>Unable to connect to the server: x509: certificate signed by unknown authority

</code></pre>

<p>A: The issue is that your local Kubernetes config file must have the correct credentials.</p>

<p>When you create a cluster on GKE, it will give you credentials, including SSL
certificates and certificate authorities. These need to be stored in a Kubernetes
config file (Default: <code>~/.kube/config</code> so that <code>kubectl</code> and <code>helm</code> can access
them.</p>

<p><strong>Q: When I run a Helm command, I get an error about the tunnel or proxy</strong></p>

<p>A: Helm uses the Kubernetes proxy service to connect to the Tiller server.
If the command <code>kubectl proxy</code> does not work for you, neither will Helm.
Typically, the error is related to a missing <code>socat</code> service.</p>

<p><strong>Q: Tiller crashes with a panic</strong></p>

<p>When I run a command on Helm, Tiller crashes with an error like this:</p>

<pre><code>Tiller is listening on :44134
Probes server is listening on :44135
Storage driver is ConfigMap
Cannot initialize Kubernetes connection: the server has asked for the client to provide credentials 2016-12-20 15:18:40.545739 I | storage.go:37: Getting release &quot;bailing-chinchilla&quot; (v1) from storage
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x8053d5]

goroutine 77 [running]:
panic(0x1abbfc0, 0xc42000a040)
        /usr/local/go/src/runtime/panic.go:500 +0x1a1
k8s.io/helm/vendor/k8s.io/kubernetes/pkg/client/unversioned.(*ConfigMaps).Get(0xc4200c6200, 0xc420536100, 0x15, 0x1ca7431, 0x6, 0xc42016b6a0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/k8s.io/kubernetes/pkg/client/unversioned/configmap.go:58 +0x75
k8s.io/helm/pkg/storage/driver.(*ConfigMaps).Get(0xc4201d6190, 0xc420536100, 0x15, 0xc420536100, 0x15, 0xc4205360c0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/storage/driver/cfgmaps.go:69 +0x62
k8s.io/helm/pkg/storage.(*Storage).Get(0xc4201d61a0, 0xc4205360c0, 0x12, 0xc400000001, 0x12, 0x0, 0xc420200070)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/storage/storage.go:38 +0x160
k8s.io/helm/pkg/tiller.(*ReleaseServer).uniqName(0xc42002a000, 0x0, 0x0, 0xc42016b800, 0xd66a13, 0xc42055a040, 0xc420558050, 0xc420122001)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:577 +0xd7
k8s.io/helm/pkg/tiller.(*ReleaseServer).prepareRelease(0xc42002a000, 0xc42027c1e0, 0xc42002a001, 0xc42016bad0, 0xc42016ba08)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:630 +0x71
k8s.io/helm/pkg/tiller.(*ReleaseServer).InstallRelease(0xc42002a000, 0x7f284c434068, 0xc420250c00, 0xc42027c1e0, 0x0, 0x31a9, 0x31a9)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/tiller/release_server.go:604 +0x78
k8s.io/helm/pkg/proto/hapi/services._ReleaseService_InstallRelease_Handler(0x1c51f80, 0xc42002a000, 0x7f284c434068, 0xc420250c00, 0xc42027c190, 0x0, 0x0, 0x0, 0x0, 0x0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/pkg/proto/hapi/services/tiller.pb.go:747 +0x27d
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).processUnaryRPC(0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690, 0xc420166150, 0x288cbe8, 0xc420250bd0, 0x0, 0x0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:608 +0xc50
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).handleStream(0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690, 0xc420250bd0)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:766 +0x6b0
k8s.io/helm/vendor/google.golang.org/grpc.(*Server).serveStreams.func1.1(0xc420124710, 0xc4202f3ea0, 0x28610a0, 0xc420078000, 0xc420264690)
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:419 +0xab
created by k8s.io/helm/vendor/google.golang.org/grpc.(*Server).serveStreams.func1
        /home/ubuntu/.go_workspace/src/k8s.io/helm/vendor/google.golang.org/grpc/server.go:420 +0xa3
</code></pre>

<p>A: Check your security settings for Kubernetes.</p>

<p>A panic in Tiller is almost always the result of a failure to negotiate with the
Kubernetes API server (at which point Tiller can no longer do anything useful, so
it panics and exits).</p>

<p>Often, this is a result of authentication failing because the Pod in which Tiller
is running does not have the right token.</p>

<p>To fix this, you will need to change your Kubernetes configuration. Make sure
that <code>--service-account-private-key-file</code> from <code>controller-manager</code> and
<code>--service-account-key-file</code> from apiserver point to the <em>same</em> x509 RSA key.</p>

<h2 id="upgrading">Upgrading</h2>

<p>My Helm used to work, then I upgrade. Now it is broken.</p>

<p><strong>Q: After upgrade, I get the error &ldquo;Client version is incompatible&rdquo;. What&rsquo;s wrong?</strong></p>

<p>Tiller and Helm have to negotiate a common version to make sure that they can safely
communicate without breaking API assumptions. That error means that the version
difference is too great to safely continue. Typically, you need to upgrade
Tiller manually for this.</p>

<p>The <a href="./#install">Installation Guide</a> has definitive information about safely
upgrading Helm and Tiller.</p>

<p>The rules for version numbers are as follows:</p>

<ul>
<li>Pre-release versions are incompatible with everything else. <code>Alpha.1</code> is incompatible with <code>Alpha.2</code>.</li>
<li>Patch revisions <em>are compatible</em>: 1.2.3 is compatible with 1.2.4</li>
<li>Minor revisions <em>are not compatible</em>: 1.2.0 is not compatible with 1.3.0,
though we may relax this constraint in the future.</li>
<li>Major revisions <em>are not compatible</em>: 1.0.0 is not compatible with 2.0.0.</li>
</ul>

<h2 id="uninstalling">Uninstalling</h2>

<p>I am trying to remove stuff.</p>

<p><strong>Q: When I delete the Tiller deployment, how come all the releases are still there?</strong></p>

<p>Releases are stored in ConfigMaps inside of the <code>kube-system</code> namespace. You will
have to manually delete them to get rid of the record, or use <code>helm delete --purge</code>.</p>

<p><strong>Q: I want to delete my local Helm. Where are all its files?</strong></p>

<p>Along with the <code>helm</code> binary, Helm stores some files in <code>$HELM_HOME</code>, which is
located by default in <code>~/.helm</code>.</p>

<h1 id="using-helm">Using Helm</h1>

<p>This guide explains the basics of using Helm (and Tiller) to manage
packages on your Kubernetes cluster. It assumes that you have already
<a href="./#install">installed</a> the Helm client and the Tiller server (typically by <code>helm
init</code>).</p>

<p>If you are simply interested in running a few quick commands, you may
wish to begin with the <a href="./#quickstart">Quickstart Guide</a>. This chapter
covers the particulars of Helm commands, and explains how to use Helm.</p>

<h2 id="three-big-concepts">Three Big Concepts</h2>

<p>A <em>Chart</em> is a Helm package. It contains all of the resource definitions
necessary to run an application, tool, or service inside of a Kubernetes
cluster. Think of it like the Kubernetes equivalent of a Homebrew formula,
an Apt dpkg, or a Yum RPM file.</p>

<p>A <em>Repository</em> is the place where charts can be collected and shared.
It&rsquo;s like Perl&rsquo;s <a href="http://www.cpan.org">CPAN archive</a> or the
<a href="https://admin.fedoraproject.org/pkgdb/">Fedora Package Database</a>, but for
Kubernetes packages.</p>

<p>A <em>Release</em> is an instance of a chart running in a Kubernetes cluster.
One chart can often be installed many times into the same cluster. And
each time it is installed, a new <em>release</em> is created. Consider a MySQL
chart. If you want two databases running in your cluster, you can
install that chart twice. Each one will have its own <em>release</em>, which
will in turn have its own <em>release name</em>.</p>

<p>With these concepts in mind, we can now explain Helm like this:</p>

<p>Helm installs <em>charts</em> into Kubernetes, creating a new <em>release</em> for
each installation. And to find new charts, you can search Helm chart
<em>repositories</em>.</p>

<h2 id="helm-search-finding-charts">&lsquo;helm search&rsquo;: Finding Charts</h2>

<p>When you first install Helm, it is preconfigured to talk to the official
Kubernetes charts repository. This repository contains a number of
carefully curated and maintained charts. This chart repository is named
<code>stable</code> by default.</p>

<p>You can see which charts are available by running <code>helm search</code>:</p>

<pre><code class="language-console">$ helm search
NAME                 	VERSION 	DESCRIPTION
stable/drupal   	0.3.2   	One of the most versatile open source content m...
stable/jenkins  	0.1.0   	A Jenkins Helm chart for Kubernetes.
stable/mariadb  	0.5.1   	Chart for MariaDB
stable/mysql    	0.1.0   	Chart for MySQL
...
</code></pre>

<p>With no filter, <code>helm search</code> shows you all of the available charts. You
can narrow down your results by searching with a filter:</p>

<pre><code class="language-console">$ helm search mysql
NAME               	VERSION	DESCRIPTION
stable/mysql  	0.1.0  	Chart for MySQL
stable/mariadb	0.5.1  	Chart for MariaDB
</code></pre>

<p>Now you will only see the results that match your filter.</p>

<p>Why is
<code>mariadb</code> in the list? Because its package description relates it to
MySQL. We can use <code>helm inspect chart</code> to see this:</p>

<pre><code class="language-console">$ helm inspect stable/mariadb
Fetched stable/mariadb to mariadb-0.5.1.tgz
description: Chart for MariaDB
engine: gotpl
home: https://mariadb.org
keywords:
- mariadb
- mysql
- database
- sql
...
</code></pre>

<p>Search is a good way to find available packages. Once you have found a
package you want to install, you can use <code>helm install</code> to install it.</p>

<h2 id="helm-install-installing-a-package">&lsquo;helm install&rsquo;: Installing a Package</h2>

<p>To install a new package, use the <code>helm install</code> command. At its
simplest, it takes only one argument: The name of the chart.</p>

<pre><code class="language-console">$ helm install stable/mariadb
Fetched stable/mariadb-0.3.0 to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
NAME: happy-panda
LAST DEPLOYED: Wed Sep 28 12:32:28 2016
NAMESPACE: default
STATUS: DEPLOYED

Resources:
==&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   1         0         0            0           1s

==&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    2         1s

==&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   1s


Notes:
MariaDB can be accessed via port 3306 on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre>

<p>Now the <code>mariadb</code> chart is installed. Note that installing a chart
creates a new <em>release</em> object. The release above is named
<code>happy-panda</code>. (If you want to use your own release name, simply use the
<code>--name</code> flag on <code>helm install</code>.)</p>

<p>During installation, the <code>helm</code> client will print useful information
about which resources were created, what the state of the release is,
and also whether there are additional configuration steps you can or
should take.</p>

<p>Helm does not wait until all of the resources are running before it
exits. Many charts require Docker images that are over 600M in size, and
may take a long time to install into the cluster.</p>

<p>To keep track of a release&rsquo;s state, or to re-read configuration
information, you can use <code>helm status</code>:</p>

<pre><code class="language-console">$ helm status happy-panda
Last Deployed: Wed Sep 28 12:32:28 2016
Namespace: default
Status: DEPLOYED

Resources:
==&gt; v1/Service
NAME                     CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
happy-panda-mariadb   10.0.0.70    &lt;none&gt;        3306/TCP   4m

==&gt; extensions/Deployment
NAME                     DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
happy-panda-mariadb   1         1         1            1           4m

==&gt; v1/Secret
NAME                     TYPE      DATA      AGE
happy-panda-mariadb   Opaque    2         4m


Notes:
MariaDB can be accessed via port 3306 on the following DNS name from within your cluster:
happy-panda-mariadb.default.svc.cluster.local

To connect to your database run the following command:

   kubectl run happy-panda-mariadb-client --rm --tty -i --image bitnami/mariadb --command -- mysql -h happy-panda-mariadb
</code></pre>

<p>The above shows the current state of your release.</p>

<h3 id="customizing-the-chart-before-installing">Customizing the Chart Before Installing</h3>

<p>Installing the way we have here will only use the default configuration
options for this chart. Many times, you will want to customize the chart
to use your preferred configuration.</p>

<p>To see what options are configurable on a chart, use <code>helm inspect
values</code>:</p>

<pre><code class="language-console">helm inspect values stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
## Bitnami MariaDB image version
## ref: https://hub.docker.com/r/bitnami/mariadb/tags/
##
## Default: none
imageTag: 10.1.14-r3

## Specify a imagePullPolicy
## Default to 'Always' if imageTag is 'latest', else set to 'IfNotPresent'
## ref: http://kubernetes.io/docs/user-guide/images/#pre-pulling-images
##
# imagePullPolicy:

## Specify password for root user
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#setting-the-root-password-on-first-run
##
# mariadbRootPassword:

## Create a database user
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-user-on-first-run
##
# mariadbUser:
# mariadbPassword:

## Create a database
## ref: https://github.com/bitnami/bitnami-docker-mariadb/blob/master/README.md#creating-a-database-on-first-run
##
# mariadbDatabase:
</code></pre>

<p>You can then override any of these settings in a YAML formatted file,
and then pass that file during installation.</p>

<pre><code class="language-console">$ echo '{mariadbUser: user0, mariadbDatabase: user0db}' &gt; config.yaml
$ helm install -f config.yaml stable/mariadb
</code></pre>

<p>The above will create a default MariaDB user with the name <code>user0</code>, and
grant this user access to a newly created <code>user0db</code> database, but will
accept all the rest of the defaults for that chart.</p>

<p>There are two ways to pass configuration data during install:</p>

<ul>
<li><code>--values</code> (or <code>-f</code>): Specify a YAML file with overrides. This can be specified multiple times
and the rightmost file will take precedence</li>
<li><code>--set</code> (and its variants <code>--set-string</code> and <code>--set-file</code>): Specify overrides on the command line.</li>
</ul>

<p>If both are used, <code>--set</code> values are merged into <code>--values</code> with higher precedence.
Overrides specified with <code>--set</code> are persisted in a configmap. Values that have been
<code>--set</code> can be viewed for a given release with <code>helm get values &lt;release-name&gt;</code>.
Values that have been <code>--set</code> can be cleared by running <code>helm upgrade</code> with <code>--reset-values</code>
specified.</p>

<h4 id="the-format-and-limitations-of-set">The Format and Limitations of <code>--set</code></h4>

<p>The <code>--set</code> option takes zero or more name/value pairs. At its simplest, it is
used like this: <code>--set name=value</code>. The YAML equivalent of that is:</p>

<pre><code class="language-yaml">name: value
</code></pre>

<p>Multiple values are separated by <code>,</code> characters. So <code>--set a=b,c=d</code> becomes:</p>

<pre><code class="language-yaml">a: b
c: d
</code></pre>

<p>More complex expressions are supported. For example, <code>--set outer.inner=value</code> is
translated into this:</p>

<pre><code class="language-yaml">outer:
  inner: value
</code></pre>

<p>Lists can be expressed by enclosing values in <code>{</code> and <code>}</code>. For example,
<code>--set name={a, b, c}</code> translates to:</p>

<pre><code class="language-yaml">name:
  - a
  - b
  - c
</code></pre>

<p>As of Helm 2.5.0, it is possible to access list items using an array index syntax.
For example, <code>--set servers[0].port=80</code> becomes:</p>

<pre><code class="language-yaml">servers:
  - port: 80
</code></pre>

<p>Multiple values can be set this way. The line <code>--set servers[0].port=80,servers[0].host=example</code> becomes:</p>

<pre><code class="language-yaml">servers:
  - port: 80
    host: example
</code></pre>

<p>Sometimes you need to use special characters in your <code>--set</code> lines. You can use
a backslash to escape the characters; <code>--set name=&quot;value1\,value2&quot;</code> will become:</p>

<pre><code class="language-yaml">name: &quot;value1,value2&quot;
</code></pre>

<p>Similarly, you can escape dot sequences as well, which may come in handy when charts use the
<code>toYaml</code> function to parse annotations, labels and node selectors. The syntax for
<code>--set nodeSelector.&quot;kubernetes\.io/role&quot;=master</code> becomes:</p>

<pre><code class="language-yaml">nodeSelector:
  kubernetes.io/role: master
</code></pre>

<p>Deeply nested data structures can be difficult to express using <code>--set</code>. Chart
designers are encouraged to consider the <code>--set</code> usage when designing the format
of a <code>values.yaml</code> file.</p>

<p>Helm will cast certain values specified with <code>--set</code> to integers.
For example, <code>--set foo=true</code> results Helm to cast <code>true</code> into an int64 value.
In case you want a string, use a <code>--set</code>&rsquo;s variant named <code>--set-string</code>. <code>--set-string foo=true</code> results in a string value of <code>&quot;true&quot;</code>.</p>

<p><code>--set-file key=filepath</code> is another variant of <code>--set</code>.
It reads the file and use its content as a value.
An example use case of it is to inject a multi-line text into values without dealing with indentation in YAML.
Say you want to create a <a href="https://github.com/Azure/brigade">brigade</a> project with certain value containing 5 lines JavaScript code, you might write a <code>values.yaml</code> like:</p>

<pre><code class="language-yaml">defaultScript: |
  const { events, Job } = require(&quot;brigadier&quot;)
  function run(e, project) {
    console.log(&quot;hello default script&quot;)
  }
  events.on(&quot;run&quot;, run)
</code></pre>

<p>Being embedded in a YAML, this makes it harder for you to use IDE features and testing framework and so on that supports writing code.
Instead, you can use <code>--set-file defaultScript=brigade.js</code> with <code>brigade.js</code> containing:</p>

<pre><code class="language-javascript">const { events, Job } = require(&quot;brigadier&quot;)
function run(e, project) {
  console.log(&quot;hello default script&quot;)
}
events.on(&quot;run&quot;, run)
</code></pre>

<h3 id="more-installation-methods">More Installation Methods</h3>

<p>The <code>helm install</code> command can install from several sources:</p>

<ul>
<li>A chart repository (as we&rsquo;ve seen above)</li>
<li>A local chart archive (<code>helm install foo-0.1.1.tgz</code>)</li>
<li>An unpacked chart directory (<code>helm install path/to/foo</code>)</li>
<li>A full URL (<code>helm install https://example.com/charts/foo-1.2.3.tgz</code>)</li>
</ul>

<h2 id="helm-upgrade-and-helm-rollback-upgrading-a-release-and-recovering-on-failure">&lsquo;helm upgrade&rsquo; and &lsquo;helm rollback&rsquo;: Upgrading a Release, and Recovering on Failure</h2>

<p>When a new version of a chart is released, or when you want to change
the configuration of your release, you can use the <code>helm upgrade</code>
command.</p>

<p>An upgrade takes an existing release and upgrades it according to the
information you provide. Because Kubernetes charts can be large and
complex, Helm tries to perform the least invasive upgrade. It will only
update things that have changed since the last release.</p>

<pre><code class="language-console">$ helm upgrade -f panda.yaml happy-panda stable/mariadb
Fetched stable/mariadb-0.3.0.tgz to /Users/mattbutcher/Code/Go/src/k8s.io/helm/mariadb-0.3.0.tgz
happy-panda has been upgraded. Happy Helming!
Last Deployed: Wed Sep 28 12:47:54 2016
Namespace: default
Status: DEPLOYED
...
</code></pre>

<p>In the above case, the <code>happy-panda</code> release is upgraded with the same
chart, but with a new YAML file:</p>

<pre><code class="language-yaml">mariadbUser: user1
</code></pre>

<p>We can use <code>helm get values</code> to see whether that new setting took
effect.</p>

<pre><code class="language-console">$ helm get values happy-panda
mariadbUser: user1
</code></pre>

<p>The <code>helm get</code> command is a useful tool for looking at a release in the
cluster. And as we can see above, it shows that our new values from
<code>panda.yaml</code> were deployed to the cluster.</p>

<p>Now, if something does not go as planned during a release, it is easy to
roll back to a previous release using <code>helm rollback [RELEASE] [REVISION]</code>.</p>

<pre><code class="language-console">$ helm rollback happy-panda 1
</code></pre>

<p>The above rolls back our happy-panda to its very first release version.
A release version is an incremental revision. Every time an install,
upgrade, or rollback happens, the revision number is incremented by 1.
The first revision number is always 1. And we can use <code>helm history [RELEASE]</code>
to see revision numbers for a certain release.</p>

<h2 id="helpful-options-for-install-upgrade-rollback">Helpful Options for Install/Upgrade/Rollback</h2>

<p>There are several other helpful options you can specify for customizing the
behavior of Helm during an install/upgrade/rollback. Please note that this
is not a full list of cli flags. To see a description of all flags, just run
<code>helm &lt;command&gt; --help</code>.</p>

<ul>
<li><code>--timeout</code>: A value in seconds to wait for Kubernetes commands to complete
This defaults to 300 (5 minutes)</li>
<li><code>--wait</code>: Waits until all Pods are in a ready state, PVCs are bound, Deployments
have minimum (<code>Desired</code> minus <code>maxUnavailable</code>) Pods in ready state and
Services have an IP address (and Ingress if a <code>LoadBalancer</code>) before
marking the release as successful. It will wait for as long as the
<code>--timeout</code> value. If timeout is reached, the release will be marked as
<code>FAILED</code>. Note: In scenario where Deployment has <code>replicas</code> set to 1 and
<code>maxUnavailable</code> is not set to 0 as part of rolling update strategy,
<code>--wait</code> will return as ready as it has satisfied the minimum Pod in ready condition.</li>
<li><code>--no-hooks</code>: This skips running hooks for the command</li>
<li><code>--recreate-pods</code> (only available for <code>upgrade</code> and <code>rollback</code>): This flag
will cause all pods to be recreated (with the exception of pods belonging to
deployments)</li>
</ul>

<h2 id="helm-delete-deleting-a-release">&lsquo;helm delete&rsquo;: Deleting a Release</h2>

<p>When it is time to uninstall or delete a release from the cluster, use
the <code>helm delete</code> command:</p>

<pre><code class="language-console">$ helm delete happy-panda
</code></pre>

<p>This will remove the release from the cluster. You can see all of your
currently deployed releases with the <code>helm list</code> command:</p>

<pre><code class="language-console">$ helm list
NAME           	VERSION	UPDATED                        	STATUS         	CHART
inky-cat       	1      	Wed Sep 28 12:59:46 2016       	DEPLOYED       	alpine-0.1.0
</code></pre>

<p>From the output above, we can see that the <code>happy-panda</code> release was
deleted.</p>

<p>However, Helm always keeps records of what releases happened. Need to
see the deleted releases? <code>helm list --deleted</code> shows those, and <code>helm
list --all</code> shows all of the releases (deleted and currently deployed,
as well as releases that failed):</p>

<pre><code class="language-console">⇒  helm list --all
NAME           	VERSION	UPDATED                        	STATUS         	CHART
happy-panda   	2      	Wed Sep 28 12:47:54 2016       	DELETED        	mariadb-0.3.0
inky-cat       	1      	Wed Sep 28 12:59:46 2016       	DEPLOYED       	alpine-0.1.0
kindred-angelf 	2      	Tue Sep 27 16:16:10 2016       	DELETED        	alpine-0.1.0
</code></pre>

<p>Because Helm keeps records of deleted releases, a release name cannot be
re-used. (If you <em>really</em> need to re-use a release name, you can use the
<code>--replace</code> flag, but it will simply re-use the existing release and
replace its resources.)</p>

<p>Note that because releases are preserved in this way, you can rollback a
deleted resource, and have it re-activate.</p>

<h2 id="helm-repo-working-with-repositories">&lsquo;helm repo&rsquo;: Working with Repositories</h2>

<p>So far, we&rsquo;ve been installing charts only from the <code>stable</code> repository.
But you can configure <code>helm</code> to use other repositories. Helm provides
several repository tools under the <code>helm repo</code> command.</p>

<p>You can see which repositories are configured using <code>helm repo list</code>:</p>

<pre><code class="language-console">$ helm repo list
NAME           	URL
stable         	https://kubernetes-charts.storage.googleapis.com
local          	http://localhost:8879/charts
mumoshu        	https://mumoshu.github.io/charts
</code></pre>

<p>And new repositories can be added with <code>helm repo add</code>:</p>

<pre><code class="language-console">$ helm repo add dev https://example.com/dev-charts
</code></pre>

<p>Because chart repositories change frequently, at any point you can make
sure your Helm client is up to date by running <code>helm repo update</code>.</p>

<h2 id="creating-your-own-charts">Creating Your Own Charts</h2>

<p>The <a href="./#charts">Chart Development Guide</a> explains how to develop your own
charts. But you can get started quickly by using the <code>helm create</code>
command:</p>

<pre><code class="language-console">$ helm create deis-workflow
Creating deis-workflow
</code></pre>

<p>Now there is a chart in <code>./deis-workflow</code>. You can edit it and create
your own templates.</p>

<p>As you edit your chart, you can validate that it is well-formatted by
running <code>helm lint</code>.</p>

<p>When it&rsquo;s time to package the chart up for distribution, you can run the
<code>helm package</code> command:</p>

<pre><code class="language-console">$ helm package deis-workflow
deis-workflow-0.1.0.tgz
</code></pre>

<p>And that chart can now easily be installed by <code>helm install</code>:</p>

<pre><code class="language-console">$ helm install ./deis-workflow-0.1.0.tgz
...
</code></pre>

<p>Charts that are archived can be loaded into chart repositories. See the
documentation for your chart repository server to learn how to upload.</p>

<p>Note: The <code>stable</code> repository is managed on the <a href="https://github.com/helm/charts">Helm Charts
GitHub repository</a>. That project
accepts chart source code, and (after audit) packages those for you.</p>

<h2 id="tiller-namespaces-and-rbac">Tiller, Namespaces and RBAC</h2>

<p>In some cases you may wish to scope Tiller or deploy multiple Tillers to a single cluster. Here are some best practices when operating in those circumstances.</p>

<ol>
<li>Tiller can be <a href="./#install">installed</a> into any namespace. By default, it is installed into kube-system. You can run multiple Tillers provided they each run in their own namespace.</li>
<li>Limiting Tiller to only be able to install into specific namespaces and/or resource types is controlled by Kubernetes <a href="./#https://kubernetes.io/docs/admin/authorization/rbac/">RBAC</a> roles and rolebindings. You can add a service account to Tiller when configuring Helm via <code>helm init --service-account &lt;NAME&gt;</code>. You can find more information about that <a href="rbac">here</a>.</li>
<li>Release names are unique PER TILLER INSTANCE.</li>
<li>Charts should only contain resources that exist in a single namespace.</li>
<li>It is not recommended to have multiple Tillers configured to manage resources in the same namespace.</li>
</ol>

<h2 id="conclusion-1">Conclusion</h2>

<p>This chapter has covered the basic usage patterns of the <code>helm</code> client,
including searching, installation, upgrading, and deleting. It has also
covered useful utility commands like <code>helm status</code>, <code>helm get</code>, and
<code>helm repo</code>.</p>

<p>For more information on these commands, take a look at Helm&rsquo;s built-in
help: <code>helm help</code>.</p>

<p>In the next chapter, we look at the process of developing charts.</p>

<h1 id="the-helm-plugins-guide">The Helm Plugins Guide</h1>

<p>Helm 2.1.0 introduced the concept of a client-side Helm <em>plugin</em>. A plugin is a
tool that can be accessed through the <code>helm</code> CLI, but which is not part of the
built-in Helm codebase.</p>

<p>Existing plugins can be found on <a href="related.md#helm-plugins">related</a> section or by searching <a href="https://github.com/search?q=topic%3Ahelm-plugin&amp;type=Repositories">Github</a>.</p>

<p>This guide explains how to use and create plugins.</p>

<h2 id="an-overview">An Overview</h2>

<p>Helm plugins are add-on tools that integrate seamlessly with Helm. They provide
a way to extend the core feature set of Helm, but without requiring every new
feature to be written in Go and added to the core tool.</p>

<p>Helm plugins have the following features:</p>

<ul>
<li>They can be added and removed from a Helm installation without impacting the
core Helm tool.</li>
<li>They can be written in any programming language.</li>
<li>They integrate with Helm, and will show up in <code>helm help</code> and other places.</li>
</ul>

<p>Helm plugins live in <code>$(helm home)/plugins</code>.</p>

<p>The Helm plugin model is partially modeled on Git&rsquo;s plugin model. To that end,
you may sometimes hear <code>helm</code> referred to as the <em>porcelain</em> layer, with
plugins being the <em>plumbing</em>. This is a shorthand way of suggesting that
Helm provides the user experience and top level processing logic, while the
plugins do the &ldquo;detail work&rdquo; of performing a desired action.</p>

<h2 id="installing-a-plugin">Installing a Plugin</h2>

<p>Plugins are installed using the <code>$ helm plugin install &lt;path|url&gt;</code> command. You can pass in a path to a plugin on your local file system or a url of a remote VCS repo. The <code>helm plugin install</code> command clones or copies the plugin at the path/url given into <code>$ (helm home)/plugins</code></p>

<pre><code class="language-console">$ helm plugin install https://github.com/technosophos/helm-template
</code></pre>

<p>If you have a plugin tar distribution, simply untar the plugin into the
<code>$(helm home)/plugins</code> directory.</p>

<p>You can also install tarball plugins directly from url by issuing <code>helm plugin install http://domain/path/to/plugin.tar.gz</code></p>

<h2 id="building-plugins">Building Plugins</h2>

<p>In many ways, a plugin is similar to a chart. Each plugin has a top-level
directory, and then a <code>plugin.yaml</code> file.</p>

<pre><code>$(helm home)/plugins/
  |- keybase/
      |
      |- plugin.yaml
      |- keybase.sh

</code></pre>

<p>In the example above, the <code>keybase</code> plugin is contained inside of a directory
named <code>keybase</code>. It has two files: <code>plugin.yaml</code> (required) and an executable
script, <code>keybase.sh</code> (optional).</p>

<p>The core of a plugin is a simple YAML file named <code>plugin.yaml</code>.
Here is a plugin YAML for a plugin that adds support for Keybase operations:</p>

<pre><code>name: &quot;keybase&quot;
version: &quot;0.1.0&quot;
usage: &quot;Integrate Keybase.io tools with Helm&quot;
description: |-
  This plugin provides Keybase services to Helm.
ignoreFlags: false
useTunnel: false
command: &quot;$HELM_PLUGIN_DIR/keybase.sh&quot;
</code></pre>

<p>The <code>name</code> is the name of the plugin. When Helm executes it plugin, this is the
name it will use (e.g. <code>helm NAME</code> will invoke this plugin).</p>

<p><em><code>name</code> should match the directory name.</em> In our example above, that means the
plugin with <code>name: keybase</code> should be contained in a directory named <code>keybase</code>.</p>

<p>Restrictions on <code>name</code>:</p>

<ul>
<li><code>name</code> cannot duplicate one of the existing <code>helm</code> top-level commands.</li>
<li><code>name</code> must be restricted to the characters ASCII a-z, A-Z, 0-9, <code>_</code> and <code>-</code>.</li>
</ul>

<p><code>version</code> is the SemVer 2 version of the plugin.
<code>usage</code> and <code>description</code> are both used to generate the help text of a command.</p>

<p>The <code>ignoreFlags</code> switch tells Helm to <em>not</em> pass flags to the plugin. So if a
plugin is called with <code>helm myplugin --foo</code> and <code>ignoreFlags: true</code>, then <code>--foo</code>
is silently discarded.</p>

<p>The <code>useTunnel</code> switch indicates that the plugin needs a tunnel to Tiller. This
should be set to <code>true</code> <em>anytime a plugin talks to Tiller</em>. It will cause Helm
to open a tunnel, and then set <code>$TILLER_HOST</code> to the right local address for that
tunnel. But don&rsquo;t worry: if Helm detects that a tunnel is not necessary because
Tiller is running locally, it will not create the tunnel.</p>

<p>Finally, and most importantly, <code>command</code> is the command that this plugin will
execute when it is called. Environment variables are interpolated before the plugin
is executed. The pattern above illustrates the preferred way to indicate where
the plugin program lives.</p>

<p>There are some strategies for working with plugin commands:</p>

<ul>
<li>If a plugin includes an executable, the executable for a <code>command:</code> should be
packaged in the plugin directory.</li>
<li>The <code>command:</code> line will have any environment variables expanded before
execution. <code>$HELM_PLUGIN_DIR</code> will point to the plugin directory.</li>
<li>The command itself is not executed in a shell. So you can&rsquo;t oneline a shell script.</li>
<li>Helm injects lots of configuration into environment variables. Take a look at
the environment to see what information is available.</li>
<li>Helm makes no assumptions about the language of the plugin. You can write it
in whatever you prefer.</li>
<li>Commands are responsible for implementing specific help text for <code>-h</code> and <code>--help</code>.
Helm will use <code>usage</code> and <code>description</code> for <code>helm help</code> and <code>helm help myplugin</code>,
but will not handle <code>helm myplugin --help</code>.</li>
</ul>

<h2 id="downloader-plugins">Downloader Plugins</h2>

<p>By default, Helm is able to fetch Charts using HTTP/S. As of Helm 2.4.0, plugins
can have a special capability to download Charts from arbitrary sources.</p>

<p>Plugins shall declare this special capability in the <code>plugin.yaml</code> file (top level):</p>

<pre><code>downloaders:
- command: &quot;bin/mydownloader&quot;
  protocols:
  - &quot;myprotocol&quot;
  - &quot;myprotocols&quot;
</code></pre>

<p>If such plugin is installed, Helm can interact with the repository using the specified
protocol scheme by invoking the <code>command</code>. The special repository shall be added
similarly to the regular ones: <code>helm repo add favorite myprotocol://example.com/</code>
The rules for the special repos are the same to the regular ones: Helm must be able
to download the <code>index.yaml</code> file in order to discover and cache the list of
available Charts.</p>

<p>The defined command will be invoked with the following scheme:
<code>command certFile keyFile caFile full-URL</code>. The SSL credentials are coming from the
repo definition, stored in <code>$HELM_HOME/repository/repositories.yaml</code>. Downloader
plugin is expected to dump the raw content to stdout and report errors on stderr.</p>

<h2 id="environment-variables">Environment Variables</h2>

<p>When Helm executes a plugin, it passes the outer environment to the plugin, and
also injects some additional environment variables.</p>

<p>Variables like <code>KUBECONFIG</code> are set for the plugin if they are set in the
outer environment.</p>

<p>The following variables are guaranteed to be set:</p>

<ul>
<li><code>HELM_PLUGIN</code>: The path to the plugins directory</li>
<li><code>HELM_PLUGIN_NAME</code>: The name of the plugin, as invoked by <code>helm</code>. So
<code>helm myplug</code> will have the short name <code>myplug</code>.</li>
<li><code>HELM_PLUGIN_DIR</code>: The directory that contains the plugin.</li>
<li><code>HELM_BIN</code>: The path to the <code>helm</code> command (as executed by the user).</li>
<li><code>HELM_HOME</code>: The path to the Helm home.</li>
<li><code>HELM_PATH_*</code>: Paths to important Helm files and directories are stored in
environment variables prefixed by <code>HELM_PATH</code>.</li>
<li><code>TILLER_HOST</code>: The <code>domain:port</code> to Tiller. If a tunnel is created, this
will point to the local endpoint for the tunnel. Otherwise, it will point
to <code>$HELM_HOST</code>, <code>--host</code>, or the default host (according to Helm&rsquo;s rules of
precedence).</li>
</ul>

<p>While <code>HELM_HOST</code> <em>may</em> be set, there is no guarantee that it will point to the
correct Tiller instance. This is done to allow plugin developer to access
<code>HELM_HOST</code> in its raw state when the plugin itself needs to manually configure
a connection.</p>

<h2 id="a-note-on-usetunnel">A Note on <code>useTunnel</code></h2>

<p>If a plugin specifies <code>useTunnel: true</code>, Helm will do the following (in order):</p>

<ol>
<li>Parse global flags and the environment</li>
<li>Create the tunnel</li>
<li>Set <code>TILLER_HOST</code></li>
<li>Execute the plugin</li>
<li>Close the tunnel</li>
</ol>

<p>The tunnel is removed as soon as the <code>command</code> returns. So, for example, a
command cannot background a process and assume that process will be able
to use the tunnel.</p>

<h2 id="a-note-on-flag-parsing">A Note on Flag Parsing</h2>

<p>When executing a plugin, Helm will parse global flags for its own use. Some of
these flags are <em>not</em> passed on to the plugin.</p>

<ul>
<li><code>--debug</code>: If this is specified, <code>$HELM_DEBUG</code> is set to <code>1</code></li>
<li><code>--home</code>: This is converted to <code>$HELM_HOME</code></li>
<li><code>--host</code>: This is converted to <code>$HELM_HOST</code></li>
<li><code>--kube-context</code>: This is simply dropped. If your plugin uses <code>useTunnel</code>, this
is used to set up the tunnel for you.</li>
</ul>

<p>Plugins <em>should</em> display help text and then exit for <code>-h</code> and <code>--help</code>. In all
other cases, plugins may use flags as appropriate.</p>

<h1 id="role-based-access-control">Role-based Access Control</h1>

<p>In Kubernetes, granting a role to an application-specific service account is a best practice to ensure that your application is operating in the scope that you have specified. Read more about service account permissions <a href="https://kubernetes.io/docs/admin/authorization/rbac/#service-account-permissions">in the official Kubernetes docs</a>.</p>

<p>Bitnami also has a fantastic guide for <a href="https://docs.bitnami.com/kubernetes/how-to/configure-rbac-in-your-kubernetes-cluster/">configuring RBAC in your cluster</a> that takes you through RBAC basics.</p>

<p>This guide is for users who want to restrict Tiller&rsquo;s capabilities to install resources to certain namespaces, or to grant a Helm client running access to a Tiller instance.</p>

<h2 id="tiller-and-role-based-access-control">Tiller and Role-based Access Control</h2>

<p>You can add a service account to Tiller using the <code>--service-account &lt;NAME&gt;</code> flag while you&rsquo;re configuring Helm. As a prerequisite, you&rsquo;ll have to create a role binding which specifies a <a href="https://kubernetes.io/docs/admin/authorization/rbac/#role-and-clusterrole">role</a> and a <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">service account</a> name that have been set up in advance.</p>

<p>Once you have satisfied the pre-requisite and have a service account with the correct permissions, you&rsquo;ll run a command like this: <code>helm init --service-account &lt;NAME&gt;</code></p>

<h3 id="example-service-account-with-cluster-admin-role">Example: Service account with cluster-admin role</h3>

<p>In <code>rbac-config.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: tiller
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: tiller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
  - kind: ServiceAccount
    name: tiller
    namespace: kube-system
</code></pre>

<p><em>Note: The cluster-admin role is created by default in a Kubernetes cluster, so you don&rsquo;t have to define it explicitly.</em></p>

<pre><code class="language-console">$ kubectl create -f rbac-config.yaml
serviceaccount &quot;tiller&quot; created
clusterrolebinding &quot;tiller&quot; created
$ helm init --service-account tiller
</code></pre>

<h3 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-only-in-that-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources only in that namespace</h3>

<p>In the example above, we gave Tiller admin access to the entire cluster. You are not at all required to give Tiller cluster-admin access for it to work. Instead of specifying a ClusterRole or a ClusterRoleBinding, you can specify a Role and RoleBinding to limit Tiller&rsquo;s scope to a particular namespace.</p>

<pre><code class="language-console">$ kubectl create namespace tiller-world
namespace &quot;tiller-world&quot; created
$ kubectl create serviceaccount tiller --namespace tiller-world
serviceaccount &quot;tiller&quot; created
</code></pre>

<p>Define a Role that allows Tiller to manage all resources in <code>tiller-world</code> like in <code>role-tiller.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: tiller-world
rules:
- apiGroups: [&quot;&quot;, &quot;batch&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;*&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>In <code>rolebinding-tiller.yaml</code>,</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: tiller-world
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: tiller-world
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<p>Afterwards you can run <code>helm init</code> to install Tiller in the <code>tiller-world</code> namespace.</p>

<pre><code class="language-console">$ helm init --service-account tiller --tiller-namespace tiller-world
$HELM_HOME has been configured at /Users/awesome-user/.helm.

Tiller (the Helm server side component) has been installed into your Kubernetes Cluster.
Happy Helming!

$ helm install nginx --tiller-namespace tiller-world --namespace tiller-world
NAME:   wayfaring-yak
LAST DEPLOYED: Mon Aug  7 16:00:16 2017
NAMESPACE: tiller-world
STATUS: DEPLOYED

RESOURCES:
==&gt; v1/Pod
NAME                  READY  STATUS             RESTARTS  AGE
wayfaring-yak-alpine  0/1    ContainerCreating  0         0s
</code></pre>

<h3 id="example-deploy-tiller-in-a-namespace-restricted-to-deploying-resources-in-another-namespace">Example: Deploy Tiller in a namespace, restricted to deploying resources in another namespace</h3>

<p>In the example above, we gave Tiller admin access to the namespace it was deployed inside. Now, let&rsquo;s limit Tiller&rsquo;s scope to deploy resources in a different namespace!</p>

<p>For example, let&rsquo;s install Tiller in the namespace <code>myorg-system</code> and allow Tiller to deploy resources in the namespace <code>myorg-users</code>.</p>

<pre><code class="language-console">$ kubectl create namespace myorg-system
namespace &quot;myorg-system&quot; created
$ kubectl create serviceaccount tiller --namespace myorg-system
serviceaccount &quot;tiller&quot; created
</code></pre>

<p>Define a Role that allows Tiller to manage all resources in <code>myorg-users</code> like in <code>role-tiller.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-manager
  namespace: myorg-users
rules:
- apiGroups: [&quot;&quot;, &quot;batch&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;*&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>Bind the service account to that role. In <code>rolebinding-tiller.yaml</code>,</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-users
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<p>We&rsquo;ll also need to grant Tiller access to read configmaps in myorg-system so it can store release information. In <code>role-tiller-myorg-system.yaml</code>:</p>

<pre><code class="language-yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: myorg-system
  name: tiller-manager
rules:
- apiGroups: [&quot;&quot;, &quot;extensions&quot;, &quot;apps&quot;]
  resources: [&quot;configmaps&quot;]
  verbs: [&quot;*&quot;]
</code></pre>

<pre><code class="language-console">$ kubectl create -f role-tiller-myorg-system.yaml
role &quot;tiller-manager&quot; created
</code></pre>

<p>And the respective role binding. In <code>rolebinding-tiller-myorg-system.yaml</code>:</p>

<pre><code class="language-yaml">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: tiller-binding
  namespace: myorg-system
subjects:
- kind: ServiceAccount
  name: tiller
  namespace: myorg-system
roleRef:
  kind: Role
  name: tiller-manager
  apiGroup: rbac.authorization.k8s.io
</code></pre>

<pre><code class="language-console">$ kubectl create -f rolebinding-tiller-myorg-system.yaml
rolebinding &quot;tiller-binding&quot; created
</code></pre>

<h2 id="helm-and-role-based-access-control">Helm and Role-based Access Control</h2>

<p>When running a Helm client in a pod, in order for the Helm client to talk to a Tiller instance, it will need certain privileges to be granted. Specifically, the Helm client will need to be able to create pods, forward ports and be able to list pods in the namespace where Tiller is running (so it can find Tiller).</p>

<h3 id="example-deploy-helm-in-a-namespace-talking-to-tiller-in-another-namespace">Example: Deploy Helm in a namespace, talking to Tiller in another namespace</h3>

<p>In this example, we will assume Tiller is running in a namespace called <code>tiller-world</code> and that the Helm client is running in a namespace called <code>helm-world</code>. By default, Tiller is running in the <code>kube-system</code> namespace.</p>

<p>In <code>helm-user.yaml</code>:</p>

<pre><code class="language-yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm
  namespace: helm-world
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: tiller-user
  namespace: tiller-world
rules:
- apiGroups:
  - &quot;&quot;
  resources:
  - pods/portforward
  verbs:
  - create
- apiGroups:
  - &quot;&quot;
  resources:
  - pods
  verbs:
  - list
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tiller-user-binding
  namespace: tiller-world
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: tiller-user
subjects:
- kind: ServiceAccount
  name: helm
  namespace: helm-world
</code></pre>

<pre><code class="language-console">$ kubectl create -f helm-user.yaml
serviceaccount &quot;helm&quot; created
role &quot;tiller-user&quot; created
rolebinding &quot;tiller-user-binding&quot; created
</code></pre>

<h1 id="using-ssl-between-helm-and-tiller">Using SSL Between Helm and Tiller</h1>

<p>This document explains how to create strong SSL/TLS connections between Helm and
Tiller. The emphasis here is on creating an internal CA, and using both the
cryptographic and identity functions of SSL.</p>

<blockquote>
<p>Support for TLS-based auth was introduced in Helm 2.3.0</p>
</blockquote>

<p>Configuring SSL is considered an advanced topic, and knowledge of Helm and Tiller
is assumed.</p>

<h2 id="overview">Overview</h2>

<p>The Tiller authentication model uses client-side SSL certificates. Tiller itself
verifies these certificates using a certificate authority. Likewise, the client
also verifies Tiller&rsquo;s identity by certificate authority.</p>

<p>There are numerous possible configurations for setting up certificates and authorities,
but the method we cover here will work for most situations.</p>

<blockquote>
<p>As of Helm 2.7.2, Tiller <em>requires</em> that the client certificate be validated
by its CA. In prior versions, Tiller used a weaker validation strategy that
allowed self-signed certificates.</p>
</blockquote>

<p>In this guide, we will show how to:</p>

<ul>
<li>Create a private CA that is used to issue certificates for Tiller clients and
servers.</li>
<li>Create a certificate for Tiller</li>
<li>Create a certificate for the Helm client</li>
<li>Create a Tiller instance that uses the certificate</li>
<li>Configure the Helm client to use the CA and client-side certificate</li>
</ul>

<p>By the end of this guide, you should have a Tiller instance running that will
only accept connections from clients who can be authenticated by SSL certificate.</p>

<h2 id="generating-certificate-authorities-and-certificates">Generating Certificate Authorities and Certificates</h2>

<p>One way to generate SSL CAs is via the <code>openssl</code> command line tool. There are many
guides and best practices documents available online. This explanation is focused
on getting ready within a small amount of time. For production configurations,
we urge readers to read <a href="https://www.openssl.org">the official documentation</a> and
consult other resources.</p>

<h3 id="generate-a-certificate-authority">Generate a Certificate Authority</h3>

<p>The simplest way to generate a certificate authority is to run two commands:</p>

<pre><code class="language-console">$ openssl genrsa -out ./ca.key.pem 4096
$ openssl req -key ca.key.pem -new -x509 -days 7300 -sha256 -out ca.cert.pem -extensions v3_ca
Enter pass phrase for ca.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:CO
Locality Name (eg, city) []:Boulder
Organization Name (eg, company) [Internet Widgits Pty Ltd]:tiller
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:tiller
Email Address []:tiller@example.com
</code></pre>

<p>Note that the data input above is <em>sample data</em>. You should customize to your own
specifications.</p>

<p>The above will generate both a secret key and a CA. Note that these two files are
very important. The key in particular should be handled with particular care.</p>

<p>Often, you will want to generate an intermediate signing key. For the sake of brevity,
we will be signing keys with our root CA.</p>

<h3 id="generating-certificates">Generating Certificates</h3>

<p>We will be generating two certificates, each representing a type of certificate:</p>

<ul>
<li>One certificate is for Tiller. You will want one of these <em>per tiller host</em> that
you run.</li>
<li>One certificate is for the user. You will want one of these <em>per helm user</em>.</li>
</ul>

<p>Since the commands to generate these are the same, we&rsquo;ll be creating both at the
same time. The names will indicate their target.</p>

<p>First, the Tiller key:</p>

<pre><code class="language-console">$ openssl genrsa -out ./tiller.key.pem 4096
Generating RSA private key, 4096 bit long modulus
..........................................................................................................................................................................................................................................................................................................................++
............................................................................++
e is 65537 (0x10001)
Enter pass phrase for ./tiller.key.pem:
Verifying - Enter pass phrase for ./tiller.key.pem:
</code></pre>

<p>Next, generate the Helm client&rsquo;s key:</p>

<pre><code class="language-console">$ openssl genrsa -out ./helm.key.pem 4096
Generating RSA private key, 4096 bit long modulus
.....++
......................................................................................................................................................................................++
e is 65537 (0x10001)
Enter pass phrase for ./helm.key.pem:
Verifying - Enter pass phrase for ./helm.key.pem:
</code></pre>

<p>Again, for production use you will generate one client certificate for each user.</p>

<p>Next we need to create certificates from these keys. For each certificate, this is
a two-step process of creating a CSR, and then creating the certificate.</p>

<pre><code class="language-console">$ openssl req -key tiller.key.pem -new -sha256 -out tiller.csr.pem
Enter pass phrase for tiller.key.pem:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:CO
Locality Name (eg, city) []:Boulder
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Tiller Server
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:tiller-server
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
</code></pre>

<p>And we repeat this step for the Helm client certificate:</p>

<pre><code class="language-console">$ openssl req -key helm.key.pem -new -sha256 -out helm.csr.pem
# Answer the questions with your client user's info
</code></pre>

<p>(In rare cases, we&rsquo;ve had to add the <code>-nodes</code> flag when generating the request.)</p>

<p>Now we sign each of these CSRs with the CA certificate we created (adjust the days parameter to suit your requirements):</p>

<pre><code class="language-console">$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in tiller.csr.pem -out tiller.cert.pem -days 365
Signature ok
subject=/C=US/ST=CO/L=Boulder/O=Tiller Server/CN=tiller-server
Getting CA Private Key
Enter pass phrase for ca.key.pem:
</code></pre>

<p>And again for the client certificate:</p>

<pre><code class="language-console">$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in helm.csr.pem -out helm.cert.pem  -days 365
</code></pre>

<p>At this point, the important files for us are these:</p>

<pre><code># The CA. Make sure the key is kept secret.
ca.cert.pem
ca.key.pem
# The Helm client files
helm.cert.pem
helm.key.pem
# The Tiller server files.
tiller.cert.pem
tiller.key.pem
</code></pre>

<p>Now we&rsquo;re ready to move on to the next steps.</p>

<h2 id="creating-a-custom-tiller-installation">Creating a Custom Tiller Installation</h2>

<p>Helm includes full support for creating a deployment configured for SSL. By specifying
a few flags, the <code>helm init</code> command can create a new Tiller installation complete
with all of our SSL configuration.</p>

<p>To take a look at what this will generate, run this command:</p>

<pre><code class="language-console">$ helm init --dry-run --debug --tiller-tls --tiller-tls-cert ./tiller.cert.pem --tiller-tls-key ./tiller.key.pem --tiller-tls-verify --tls-ca-cert ca.cert.pem
</code></pre>

<p>The output will show you a Deployment, a Secret, and a Service. Your SSL information
will be preloaded into the Secret, which the Deployment will mount to pods as they
start up.</p>

<p>If you want to customize the manifest, you can save that output to a file and then
use <code>kubectl create</code> to load it into your cluster.</p>

<blockquote>
<p>We strongly recommend enabling RBAC on your cluster and adding <a href="./#role-based-access-control">service accounts</a>
with RBAC.</p>
</blockquote>

<p>Otherwise, you can remove the <code>--dry-run</code> and <code>--debug</code> flags. We also recommend
putting Tiller in a non-system namespace (<code>--tiller-namespace=something</code>) and enable
a service account (<code>--service-account=somename</code>). But for this example we will stay
with the basics:</p>

<pre><code class="language-console">$ helm init --tiller-tls --tiller-tls-cert ./tiller.cert.pem --tiller-tls-key ./tiller.key.pem --tiller-tls-verify --tls-ca-cert ca.cert.pem
</code></pre>

<p>In a minute or two it should be ready. We can check Tiller like this:</p>

<pre><code class="language-console">$ kubectl -n kube-system get deployment
NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
... other stuff
tiller-deploy   1         1         1            1           2m
</code></pre>

<p>If there is a problem, you may want to use <code>kubectl get pods -n kube-system</code> to
find out what went wrong. With the SSL/TLS support, the most common problems all
have to do with improperly generated TLS certificates or accidentally swapping the
cert and the key.</p>

<p>At this point, you should get a <em>failure</em> when you run basic Helm commands:</p>

<pre><code class="language-console">$ helm ls
Error: transport is closing
</code></pre>

<p>This is because your Helm client does not have the correct certificate to authenticate
to Tiller.</p>

<h2 id="configuring-the-helm-client">Configuring the Helm Client</h2>

<p>The Tiller server is now running with TLS protection. It&rsquo;s time to configure the
Helm client to also perform TLS operations.</p>

<p>For a quick test, we can specify our configuration manually. We&rsquo;ll run a normal
Helm command (<code>helm ls</code>), but with SSL/TLS enabled.</p>

<pre><code class="language-console">helm ls --tls --tls-ca-cert ca.cert.pem --tls-cert helm.cert.pem --tls-key helm.key.pem
</code></pre>

<p>This configuration sends our client-side certificate to establish identity, uses
the client key for encryption, and uses the CA certificate to validate the remote
Tiller&rsquo;s identity.</p>

<p>Typing a line that is cumbersome, though. The shortcut is to move the key,
cert, and CA into <code>$HELM_HOME</code>:</p>

<pre><code class="language-console">$ cp ca.cert.pem $(helm home)/ca.pem
$ cp helm.cert.pem $(helm home)/cert.pem
$ cp helm.key.pem $(helm home)/key.pem
</code></pre>

<p>With this, you can simply run <code>helm ls --tls</code> to enable TLS.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p><em>Running a command, I get <code>Error: transport is closing</code></em></p>

<p>This is almost always due to a configuration error in which the client is missing
a certificate (<code>--tls-cert</code>) or the certificate is bad.</p>

<p><em>I&rsquo;m using a certificate, but get <code>Error: remote error: tls: bad certificate</code></em></p>

<p>This means that Tiller&rsquo;s CA cannot verify your certificate. In the examples above,
we used a single CA to generate both the client and server certificates. In these
examples, the CA has <em>signed</em> the client&rsquo;s certificate. We then load that CA
up to Tiller. So when the client certificate is sent to the server, Tiller
checks the client certificate against the CA.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: certificate is valid for tiller-server, not localhost</code></em></p>

<p>If you plan to use <code>--tls-verify</code> on the client, you will need to make sure that
the host name that Helm connects to matches the host name on the certificate. In
some cases this is awkward, since Helm will connect over localhost, or the FQDN is
not available for public resolution.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: cannot validate certificate for 127.0.0.1 because it doesn't contain any IP SANs</code></em></p>

<p>By default, the Helm client connects to Tiller via tunnel (i.e. kube proxy) at 127.0.0.1. During the TLS handshake,
a target, usually provided as a hostname (e.g. example.com), is checked against the subject and subject alternative
names of the certificate (i.e. hostname verficiation). However, because of the tunnel, the target is an IP address.
Therefore, to validate the certificate, the IP address 127.0.0.1 must be listed as an IP subject alternative name
(IP SAN) in the Tiller certificate.</p>

<p>For example, to list 127.0.0.1 as an IP SAN when generating the Tiller certificate:</p>

<pre><code class="language-console">$ echo subjectAltName=IP:127.0.0.1 &gt; extfile.cnf
$ openssl x509 -req -CA ca.cert.pem -CAkey ca.key.pem -CAcreateserial -in tiller.csr.pem -out tiller.cert.pem -days 365 -extfile extfile.cnf
</code></pre>

<p>Alternatively, you can override the expected hostname of the tiller certificate using the <code>--tls-hostname</code> flag.</p>

<p><em>If I use <code>--tls-verify</code> on the client, I get <code>Error: x509: certificate has expired or is not yet valid</code></em></p>

<p>Your helm certificate has expired, you need to sign a new certificate using your private key and the CA (and consider increasing the number of days)</p>

<p>If your tiller certificate has expired, you&rsquo;ll need to sign a new certificate, base64 encode it and update the Tiller Secret:
<code>kubectl edit secret tiller-secret</code></p>

<h2 id="references">References</h2>

<p><a href="https://github.com/denji/golang-tls">https://github.com/denji/golang-tls</a>
<a href="https://www.openssl.org/docs/">https://www.openssl.org/docs/</a>
<a href="https://jamielinux.com/docs/openssl-certificate-authority/sign-server-and-client-certificates.html">https://jamielinux.com/docs/openssl-certificate-authority/sign-server-and-client-certificates.html</a></p>

<h1 id="securing-your-helm-installation">Securing your Helm Installation</h1>

<p>Helm is a powerful and flexible package-management and operations tool for Kubernetes. Installing it using the default installation command &ndash; <code>helm init</code> &ndash; quickly and easily installs <strong>Tiller</strong>, the server-side component with which Helm corresponds.</p>

<p>This default installation applies <strong><em>no security configurations</em></strong>, however. It&rsquo;s completely appropriate to use this type of installation when you are working against a cluster with no or very few security concerns, such as local development with Minikube or with a cluster that is well-secured in a private network with no data-sharing or no other users or teams. If this is the case, then the default installation is fine, but remember: With great power comes great responsibility. Always use due diligence when deciding to use the default installation.</p>

<h2 id="who-needs-security-configurations">Who Needs Security Configurations?</h2>

<p>For the following types of clusters we strongly recommend that you apply the proper security configurations to Helm and Tiller to ensure the safety of the cluster, the data in it, and the network to which it is connected.</p>

<ul>
<li>Clusters that are exposed to uncontrolled network environments: either untrusted network actors can access the cluster, or untrusted applications that can access the network environment.</li>
<li>Clusters that are for many people to use &ndash; <em>multitenant</em> clusters &ndash; as a shared environment</li>
<li>Clusters that have access to or use high-value data or networks of any type</li>
</ul>

<p>Often, environments like these are referred to as <em>production grade</em> or <em>production quality</em> because the damage done to any company by misuse of the cluster can be profound for either customers, the company itself, or both. Once the risk of damage becomes high enough, you need to ensure the integrity of your cluster no matter what the actual risk.</p>

<p>To configure your installation properly for your environment, you must:</p>

<ul>
<li>Understand the security context of your cluster</li>
<li>Choose the Best Practices you should apply to your helm installation</li>
</ul>

<p>The following assumes you have a Kubernetes configuration file (a <em>kubeconfig</em> file) or one was given to you to access a cluster.</p>

<h2 id="understanding-the-security-context-of-your-cluster">Understanding the Security Context of your Cluster</h2>

<p><code>helm init</code> installs Tiller into the cluster in the <code>kube-system</code> namespace and without any RBAC rules applied. This is appropriate for local development and other private scenarios because it enables you to be productive immediately. It also enables you to continue running Helm with existing Kubernetes clusters that do not have role-based access control (RBAC) support until you can move your workloads to a more recent Kubernetes version.</p>

<p>There are four main areas to consider when securing a tiller installation:</p>

<ol>
<li>Role-based access control, or RBAC</li>
<li>Tiller&rsquo;s gRPC endpoint and its usage by Helm</li>
<li>Tiller release information</li>
<li>Helm charts</li>
</ol>

<h3 id="rbac">RBAC</h3>

<p>Recent versions of Kubernetes employ a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">role-based access control (or RBAC)</a> system (as do modern operating systems) to help mitigate the damage that can be done if credentials are misused or bugs exist. Even where an identity is hijacked, the identity has only so many permissions to a controlled space. This effectively adds a layer of security to limit the scope of any attack with that identity.</p>

<p>Helm and Tiller are designed to install, remove, and modify logical applications that can contain many services interacting together. As a result, often its usefulness involves cluster-wide operations, which in a multitenant cluster means that great care must be taken with access to a cluster-wide Tiller installation to prevent improper activity.</p>

<p>Specific users and teams &ndash; developers, operators, system and network administrators &ndash; will need their own portion of the cluster in which they can use Helm and Tiller without risking other portions of the cluster. This means using a Kubernetes cluster with RBAC enabled and Tiller configured to enforce them. For more information about using RBAC in Kubernetes, see <a href="./#role-based-access-control">Using RBAC Authorization</a>.</p>

<h4 id="tiller-and-user-permissions">Tiller and User Permissions</h4>

<p>Tiller in its current form does not provide a way to map user credentials to specific permissions within Kubernetes. When Tiller is running inside of the cluster, it operates with the permissions of its service account. If no service account name is supplied to Tiller, it runs with the default service account for that namespace. This means that all Tiller operations on that server are executed using the Tiller pod&rsquo;s credentials and permissions.</p>

<p>To properly limit what Tiller itself can do, the standard Kubernetes RBAC mechanisms must be attached to Tiller, including Roles and RoleBindings that place explicit limits on what things a Tiller instance can install, and where.</p>

<p>This situation may change in the future. While the community has several methods that might address this, at the moment performing actions using the rights of the client, instead of the rights of Tiller, is contingent upon the outcome of the Pod Identity Working Group, which has taken on the task of solving the problem in a general way.</p>

<h3 id="the-tiller-grpc-endpoint">The Tiller gRPC Endpoint</h3>

<p>In the default installation the gRPC endpoint that Tiller offers is available inside the cluster (not external to the cluster) without authentication configuration applied. Without applying authentication, any process in the cluster can use the gRPC endpoint to perform operations inside the cluster. In a local or secured private cluster, this enables rapid usage and is normal. (When running outside the cluster, Helm authenticates through the Kubernetes API server to reach Tiller, leveraging existing Kubernetes authentication support.)</p>

<p>The following two sub-sections describe options of how to setup Tiller so there isn&rsquo;t an unauthenticated endpoint (i.e. gRPC) in your cluster.</p>

<h4 id="enabling-tls">Enabling TLS</h4>

<p>(Note that out of the two options, this is the recommended one for Helm 2.)</p>

<p>Shared and production clusters &ndash; for the most part &ndash; should use Helm 2.7.2 at a minimum and configure TLS for each Tiller gRPC endpoint to ensure that within the cluster usage of gRPC endpoints is only for the properly authenticated identity for that endpoint (i.e. configure each endpoint to use a separate TLS certificate). Doing so enables any number of Tiller instances to be deployed in any number of namespaces and yet no unauthenticated usage of any gRPC endpoint is possible. Finally, use Helm <code>init</code> with the <code>--tiller-tls-verify</code> option to install Tiller with TLS enabled and to verify remote certificates, and all other Helm commands should use the <code>--tls</code> option.</p>

<p>For more information about the proper steps to configure Tiller and use Helm properly with TLS configured, see the <a href="./##best-practices-for-securing-helm-and-tiller">Best Practices</a> section below, and <a href="tiller_ssl">Using SSL between Helm and Tiller</a>.</p>

<p>When Helm clients are connecting from outside of the cluster, the security between the Helm client and the API server is managed by Kubernetes itself. You may want to ensure that this link is secure. Note that if you are using the TLS configuration recommended above, not even the Kubernetes API server has access to the encrypted messages between the client and Tiller.</p>

<h4 id="running-tiller-locally-1">Running Tiller Locally</h4>

<p>Contrary to the previous <a href="./##enabling-tls">Enabling TLS</a> section, this section does not involve running a tiller server pod in your cluster (for what it&rsquo;s worth, that lines up with the current <a href="https://github.com/helm/community/blob/master/helm-v3/000-helm-v3">helm v3 proposal</a>), thus there is no gRPC endpoint (and thus there&rsquo;s no need to create &amp; manage TLS certificates to secure each gRPC endpoint).</p>

<p>Steps:
 * Fetch the latest helm release tarball from the <a href="https://github.com/helm/helm/releases">GitHub release page</a>, and extract and move <code>helm</code> and <code>tiller</code> somewhere on your <code>$PATH</code>.
 * &ldquo;Server&rdquo;: Run <code>tiller --storage=secret</code>. (Note that <code>tiller</code> has a default value of &ldquo;:44134&rdquo; for the <code>--listen</code> argument.)
 * Client: In another terminal (and on the same host that the aforementioned <code>tiller</code> command was run for the previous bullet): Run <code>export HELM_HOST=:44134</code>, and then run <code>helm</code> commands as usual.</p>

<h3 id="tiller-s-release-information">Tiller&rsquo;s Release Information</h3>

<p>For historical reasons, Tiller stores its release information in ConfigMaps. We suggest changing the default to Secrets.</p>

<p>Secrets are the Kubernetes accepted mechanism for saving configuration data that is considered sensitive. While secrets don&rsquo;t themselves offer many protections, Kubernetes cluster management software often treats them differently than other objects. Thus, we suggest using secrets to store releases.</p>

<p>Enabling this feature currently requires setting the <code>--storage=secret</code> flag in the tiller-deploy deployment. This entails directly modifying the deployment or using <code>helm init --override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}'</code>, as no helm init flag is currently available to do this for you.</p>

<h3 id="thinking-about-charts">Thinking about Charts</h3>

<p>Because of the relative longevity of Helm, the Helm chart ecosystem evolved without the immediate concern for cluster-wide control, and especially in the developer space this makes complete sense. However, charts are a kind of package that not only installs containers you may or may not have validated yourself, but it may also install into more than one namespace.</p>

<p>As with all shared software, in a controlled or shared environment you must validate all software you install yourself <em>before</em> you install it. If you have secured Tiller with TLS and have installed it with permissions to only one or a subset of namespaces, some charts may fail to install &ndash; but in these environments, that is exactly what you want. If you need to use the chart, you may have to work with the creator or modify it yourself in order to use it securely in a multitenant cluster with proper RBAC rules applied. The <code>helm template</code> command renders the chart locally and displays the output.</p>

<p>Once vetted, you can use Helm&rsquo;s provenance tools to <a href="./#helm-provenance-and-integrity">ensure the provenance and integrity of charts</a> that you use.</p>

<h3 id="grpc-tools-and-secured-tiller-configurations">gRPC Tools and Secured Tiller Configurations</h3>

<p>Many very useful tools use the gRPC interface directly, and having been built against the default installation &ndash; which provides cluster-wide access &ndash; may fail once security configurations have been applied. RBAC policies are controlled by you or by the cluster operator, and either can be adjusted for the tool, or the tool can be configured to work properly within the constraints of specific RBAC policies applied to Tiller. The same may need to be done if the gRPC endpoint is secured: the tools need their own secure TLS configuration in order to use a specific Tiller instance. The combination of RBAC policies and a secured gRPC endpoint configured in conjunction with gRPC tools enables you to control your cluster environment as you should.</p>

<h2 id="best-practices-for-securing-helm-and-tiller">Best Practices for Securing Helm and Tiller</h2>

<p>The following guidelines reiterate the Best Practices for securing Helm and Tiller and using them correctly.</p>

<ol>
<li>Create a cluster with RBAC enabled</li>
<li>Configure each Tiller gRPC endpoint to use a separate TLS certificate</li>
<li>Release information should be a Kubernetes Secret</li>
<li>Install one Tiller per user, team, or other organizational entity with the <code>--service-account</code> flag, Roles, and RoleBindings</li>
<li>Use the <code>--tiller-tls-verify</code> option with <code>helm init</code> and the <code>--tls</code> flag with other Helm commands to enforce verification</li>
</ol>

<p>If these steps are followed, an example <code>helm init</code> command might look something like this:</p>

<pre><code class="language-bash">$ helm init \
--override 'spec.template.spec.containers[0].command'='{/tiller,--storage=secret}' \
--tiller-tls \
--tiller-tls-verify \
--tiller-tls-cert=cert.pem \
--tiller-tls-key=key.pem \
--tls-ca-cert=ca.pem \
--service-account=accountname
</code></pre>

<p>This command will start Tiller with strong authentication over gRPC, release information stored in a Kubernetes Secret, and a service account to which RBAC policies have been applied.</p>
</div>
</article>
          
        </div>
        <div class="small-1 columns">&nbsp;</div>
      </div>

      <div class="row collapse" id="contrib">
        <div class="contrib-text">
          <p class="text-center lead">
            <a href="https://helm.sh">Helm</a> is supported by and built with a community of over 250 developers.
          </p>
          <p class="text-center">
            <a href="https://helm.sh">helm.sh</a> and <a href="https://docs.helm.sh">docs.helm.sh</a> are maintained by <img src="/src/img/microsoft.png" alt="Microsoft" class="">
          </p>
        </div>
      </div>
    </div>

          <div class="row collapse full-width cncf-wrap">
  <div class="small-12 medium-12 large-12 columns cncf">
    <a href="https://www.cncf.io/" title="Cloud Native Computing Foundation" target="_blank">
      <img src="https://helm.sh//src/img/cncf-color.png" alt="We are a Cloud Native Computing Foundation project" />
      <p>We are a <strong>Cloud Native Computing Foundation</strong> incubating project.</p>
    </a>
  </div>
</div>
    </div> 

    <a class="exit-off-canvas"></a>

    </div> 
  </div> 

    

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.8.3/modernizr.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
  <script src="/src/js/main.min.js"></script>
  <script src="/src/js/app_init.min.js"></script>

</body>
</html>